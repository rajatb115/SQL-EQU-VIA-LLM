[
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM ( SELECT VISITS.CUSTOMER_ID AS CUSTOMER_ID FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.TRANSACTION_ID IS NULL ) AS T GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(CLASS)>1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT P.PRODUCT_ID, 'STORE1' AS STORE, P.STORE1 AS PRICE FROM PRODUCTS AS P WHERE STORE1 IS NOT NULL UNION SELECT P.PRODUCT_ID, 'STORE2' AS STORE, P.STORE2 AS PRICE FROM PRODUCTS AS P WHERE STORE2 IS NOT NULL UNION SELECT P.PRODUCT_ID, 'STORE3' AS STORE, P.STORE3 AS PRICE FROM PRODUCTS AS P WHERE STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT A.BUYER_ID FROM SALES A LEFT JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'S8' AND A.BUYER_ID NOT IN (SELECT A.BUYER_ID FROM SALES A LEFT JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 CROSS JOIN LOGINFO L2 WHERE L1.IP_ADDRESS != L2.IP_ADDRESS AND L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L2.LOGIN >= L1.LOGIN AND L1.LOGOUT >= L2.LOGIN;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH A AS (SELECT USER1_ID AS ID, USER2_ID AS FRIEND FROM FRIENDSHIP WHERE USER1_ID=1 UNION ALL SELECT USER2_ID AS ID,USER1_ID AS FRIEND FROM FRIENDSHIP WHERE USER2_ID=1) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT DISTINCT PAGE_ID FROM A INNER JOIN LIKES L ON A.FRIEND=L.USER_ID) AS T WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT O1.CUSTOMER_ID, C.CUSTOMER_NAME FROM ORDERS AS O1, ORDERS AS O2, CUSTOMERS AS C WHERE O1.CUSTOMER_ID = C.CUSTOMER_ID AND O1.CUSTOMER_ID = O2.CUSTOMER_ID AND O1.PRODUCT_NAME = 'A' AND O2.PRODUCT_NAME = 'B' AND O1.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY O1.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE PRODUCT_NAME WHEN 'S8' THEN 1 ELSE 0 END) >= 1 AND SUM(CASE PRODUCT_NAME WHEN 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH UNIQUE_LOCATIONS AS ( SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(PID) = 1 ), TIVS AS ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(PID) > 1 ) SELECT SUM(I.TIV_2016) AS TIV_2016 FROM INSURANCE I INNER JOIN UNIQUE_LOCATIONS U ON U.LAT = I.LAT AND U.LON = I.LON INNER JOIN TIVS T ON T.TIV_2015 = I.TIV_2015;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(VISITS.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISITS.VISIT_ID NOT IN (SELECT T.VISIT_ID FROM TRANSACTIONS T ) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM ( SELECT COUNT(EMAIL) AS C, EMAIL FROM PERSON GROUP BY EMAIL ) AS DUPE WHERE C>1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT STUDENTS.ID AS ID, STUDENTS.NAME AS NAME FROM STUDENTS LEFT JOIN DEPARTMENTS ON STUDENTS.DEPARTMENT_ID = DEPARTMENTS.ID WHERE DEPARTMENTS.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH CTE1 AS ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) > 1 ), CTE2 AS ( SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*) = 1 ) SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT * FROM CTE1) AND (LAT,LON) IN (SELECT * FROM CTE2);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.VIEWER_ID AS ID FROM VIEWS V1 INNER JOIN VIEWS V2 ON V1.VIEWER_ID = V2.VIEWER_ID AND V1.VIEW_DATE = V2.VIEW_DATE AND V1.ARTICLE_ID != V2.ARTICLE_ID ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT P WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(*) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE AS (SELECT USER_ID, COUNT(USER_ID) AS CONTACTS_CNT, COUNT(CU.EMAIL) AS TRUSTED_CONTACTS_CNT FROM CONTACTS C LEFT JOIN CUSTOMERS CU ON C.CONTACT_EMAIL = CU.EMAIL GROUP BY USER_ID) SELECT INVOICE_ID, CU.CUSTOMER_NAME, PRICE, COALESCE(CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS CU ON I.USER_ID = CU.CUSTOMER_ID LEFT JOIN CTE ON CTE.USER_ID = I.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID AS PRODUCT_ID, CASE WHEN STORE1 IS NOT NULL THEN STORE1 END AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID AS PRODUCT_ID, CASE WHEN STORE2 IS NOT NULL THEN STORE2 END AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION SELECT PRODUCT_ID AS PRODUCT_ID, CASE WHEN STORE3 IS NOT NULL THEN STORE3 END AS STORE, STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] WITH CTE AS (SELECT SESSION_ID, DURATION/60 AS DUR_MIN FROM SESSIONS ) SELECT '[0-5>' AS BIN, SUM(CASE WHEN DUR_MIN BETWEEN 0 AND 5 THEN 1 ELSE 0 END) AS TOTAL FROM CTE UNION SELECT '[5-10>' AS BIN, SUM(CASE WHEN DUR_MIN BETWEEN 5 AND 10 THEN 1 ELSE 0 END) AS TOTAL FROM CTE UNION SELECT '[10-15>' AS BIN, SUM(CASE WHEN DUR_MIN BETWEEN 10 AND 15 THEN 1 ELSE 0 END) AS TOTAL FROM CTE UNION SELECT '15 OR MORE' AS BIN, SUM(CASE WHEN DUR_MIN > 15 THEN 1 ELSE 0 END) AS TOTAL FROM CTE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT A.PRODUCT_ID, A.PRODUCT_NAME FROM PRODUCT A WHERE A.PRODUCT_ID NOT IN ( SELECT C.PRODUCT_ID FROM SALES C WHERE C.SALE_DATE > '2019-03-31' OR C.SALE_DATE < '2019-01-01' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT SQ1.PROJECT_ID,ROUND(AVG(SQ1.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM (SELECT P.PROJECT_ID,E.EMPLOYEE_ID,E.EXPERIENCE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID)AS SQ1 GROUP BY SQ1.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN ( SELECT CASE WHEN USER1_ID = 1 THEN USER2_ID WHEN USER2_ID = 1 THEN USER1_ID END AS FRIENDS FROM FRIENDSHIP WHERE USER1_ID = 1 OR USER2_ID = 1 ) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT(A.ACCOUNT_ID) FROM LOGINFO AS A JOIN LOGINFO AS B ON A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS != B.IP_ADDRESS WHERE B.LOGIN <= A.LOGOUT AND A.LOGIN <= B.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME='S8' AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME='IPHONE' ) GROUP BY BUYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V.AUTHOR_ID AS ID FROM VIEWS V WHERE V.AUTHOR_ID=V.VIEWER_ID ORDER BY V.AUTHOR_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID, CUST.CUSTOMER_NAME FROM ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A' ) A INNER JOIN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B' ) B ON A.CUSTOMER_ID = B.CUSTOMER_ID INNER JOIN CUSTOMERS CUST ON A.CUSTOMER_ID = CUST.CUSTOMER_ID WHERE A.CUSTOMER_ID NOT IN ( SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT(CUSTOMER_ID), COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT S.PRODUCT_ID,P.PRODUCT_NAME FROM (SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MAX(SALE_DATE)<='2019-03-31' AND MIN(SALE_DATE)>='2019-01-01')S LEFT JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT SALES.PRODUCT_ID, PRODUCT_NAME FROM SALES INNER JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND SALES.PRODUCT_ID NOT IN ( SELECT DISTINCT SALES.PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM DEPARTMENTS AS D RIGHT JOIN STUDENTS AS S ON D.ID = S.DEPARTMENT_ID WHERE D.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT DISTINCT ABS(A.X-B.X) AS SHORTEST FROM POINT A, POINT B WHERE A.X != B.X ORDER BY 1 LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT T1.CUSTOMER_ID, T1.CUSTOMER_NAME FROM CUSTOMERS T1 JOIN ORDERS T2 ON T1.CUSTOMER_ID = T2.CUSTOMER_ID WHERE T2.PRODUCT_NAME = 'A' AND T1.CUSTOMER_ID IN (SELECT T1.CUSTOMER_ID FROM CUSTOMERS T1 JOIN ORDERS T2 ON T1.CUSTOMER_ID = T2.CUSTOMER_ID WHERE T2.PRODUCT_NAME = 'B') AND T1.CUSTOMER_ID NOT IN (SELECT T1.CUSTOMER_ID FROM CUSTOMERS T1 JOIN ORDERS T2 ON T1.CUSTOMER_ID = T2.CUSTOMER_ID WHERE T2.PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT P1.EMAIL FROM PERSON AS P1 GROUP BY P1.EMAIL HAVING COUNT(*) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(L) AS SHORTEST FROM (SELECT ABS(A.X -B.X) AS L FROM POINT A JOIN POINT B ON A.X <> B.X)P;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT O.CUSTOMER_ID, C.CUSTOMER_NAME FROM ORDERS O LEFT JOIN CUSTOMERS C ON O.CUSTOMER_ID = C.CUSTOMER_ID WHERE O.PRODUCT_NAME = 'A' AND O.CUSTOMER_ID IN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B' ) AND O.CUSTOMER_ID NOT IN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C' ) ORDER BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND(AVG(E.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT P LEFT JOIN EMPLOYEE E ON E.EMPLOYEE_ID = P.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND((SUM(P.PRICE * US.UNITS) / SUM(US.UNITS)), 2) AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD US ON P.PRODUCT_ID = US.PRODUCT_ID AND US.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH T AS (SELECT CUSTOMER_ID FROM ORDERS O WHERE PRODUCT_NAME = 'B' AND CUSTOMER_ID IN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ) SELECT T.CUSTOMER_ID, C.CUSTOMER_NAME FROM T JOIN CUSTOMERS C ON T.CUSTOMER_ID = C.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH AB AS (SELECT C.CUSTOMER_ID ID, C.CUSTOMER_NAME NAME FROM CUSTOMERS C JOIN ORDERS O ON O.CUSTOMER_ID = C.CUSTOMER_ID JOIN ORDERS O2 ON O2.CUSTOMER_ID = C.CUSTOMER_ID WHERE O.PRODUCT_NAME = 'A' AND O2.PRODUCT_NAME = 'B'), HAVEC AS (SELECT C2.CUSTOMER_ID ID2 , C2.CUSTOMER_NAME NAME2 FROM CUSTOMERS C2 JOIN ORDERS O4 ON O4.CUSTOMER_ID = C2.CUSTOMER_ID WHERE O4.PRODUCT_NAME = 'C'), JOINER AS (SELECT * FROM AB LEFT JOIN HAVEC ON AB.ID = HAVEC.ID2) SELECT ID CUSTOMER_ID , NAME CUSTOMER_NAME FROM JOINER WHERE ID2 IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID ,C1.CUSTOMER_NAME ,I.PRICE ,COUNT(M.CONTACT_EMAIL) AS CONTACTS_CNT ,COUNT(C2.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C1 ON I.USER_ID = C1.CUSTOMER_ID LEFT JOIN CONTACTS M ON C1.CUSTOMER_ID = M.USER_ID LEFT JOIN CUSTOMERS C2 ON M.CONTACT_NAME = C2.CUSTOMER_NAME AND M.CONTACT_EMAIL = C2.EMAIL GROUP BY I.INVOICE_ID, C1.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT X.ACCOUNT_ID FROM LOGINFO X JOIN LOGINFO Y ON X.ACCOUNT_ID=Y.ACCOUNT_ID AND X.IP_ADDRESS<>Y.IP_ADDRESS WHERE X.LOGIN BETWEEN Y.LOGIN AND Y.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, E.NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI I ON E.ID = I.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE ( CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') ) AND ( CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') ) AND ( CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COALESCE(CONTACTS_CNT,0) AS CONTACTS_CNT, COALESCE(TRUSTED_CONTACTS_CNT,0) AS TRUSTED_CONTACTS_CNT FROM (SELECT INVOICE_ID,CUSTOMER_NAME,PRICE,USER_ID FROM INVOICES LEFT JOIN CUSTOMERS ON INVOICES.USER_ID=CUSTOMERS.CUSTOMER_ID) AS I LEFT JOIN (SELECT USER_ID, COUNT(*) AS CONTACTS_CNT, SUM(CASE WHEN CUSTOMER_ID IS NULL THEN 0 ELSE 1 END) AS TRUSTED_CONTACTS_CNT FROM CONTACTS LEFT JOIN CUSTOMERS ON CONTACTS.CONTACT_EMAIL=CUSTOMERS.EMAIL GROUP BY USER_ID) AS C ON I.USER_ID=C.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM (SELECT DISTINCT * FROM VIEWS) A GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(ARTICLE_ID) >1 ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT P.PRODUCT_ID FROM SALES S LEFT JOIN PRODUCT P USING (PRODUCT_ID) WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING AVG(CASE WHEN SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' THEN 1 ELSE 0 END) = 1 );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(VISIT_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID ORDER BY 2;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT BUYER_ID, PRODUCT_NAME FROM PRODUCT P LEFT JOIN SALES S ON S.PRODUCT_ID = P.PRODUCT_ID) SELECT DISTINCT(BUYER_ID) FROM CTE WHERE BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT U.UNIQUE_ID AS UNIQUE_ID, E.NAME FROM EMPLOYEES AS E LEFT JOIN EMPLOYEEUNI AS U ON U.ID = E.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT PERSON.FIRSTNAME, PERSON.LASTNAME, ADDRESS.CITY, ADDRESS.STATE FROM PERSON LEFT JOIN ADDRESS ON PERSON.PERSONID=ADDRESS.PERSONID ORDER BY PERSON.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH IPHONEBUYERS AS ( SELECT BUYER_ID FROM SALES A, PRODUCT B WHERE A.PRODUCT_ID = B.PRODUCT_ID AND B.PRODUCT_NAME = 'IPHONE' ), S8BUYERS AS ( SELECT BUYER_ID FROM SALES A, PRODUCT B WHERE A.PRODUCT_ID = B.PRODUCT_ID AND B.PRODUCT_NAME = 'S8' ) SELECT DISTINCT A.BUYER_ID FROM SALES A,S8BUYERS I WHERE A.BUYER_ID = I.BUYER_ID AND A.BUYER_ID NOT IN (SELECT BUYER_ID FROM IPHONEBUYERS);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT (AUTHOR_ID )AS ID FROM VIEWS V WHERE AUTHOR_ID = VIEWER_ID ORDER BY AUTHOR_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID ID FROM VIEWS WHERE VIEWER_ID IN (SELECT VIEWER_ID FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID) >1 ) ORDER BY ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT CASE WHEN USER1_ID = 1 THEN USER2_ID WHEN USER2_ID = 1 THEN USER1_ID ELSE 0 END AS ID FROM FRIENDSHIP) AND PAGE_ID NOT IN (SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH SALES_WITH_PRODUCT AS (SELECT A.BUYER_ID, A.PRODUCT_ID, B.PRODUCT_NAME FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID) SELECT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM SALES_WITH_PRODUCT WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES_WITH_PRODUCT WHERE PRODUCT_NAME = 'IPHONE') GROUP BY BUYER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM BONUS B RIGHT JOIN EMPLOYEE E USING (EMPID) WHERE BONUS < 1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.TRANSACTION_ID IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT C.CLASS FROM COURSES C GROUP BY C.CLASS HAVING COUNT(DISTINCT STUDENT) >= 5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN( SELECT DISTINCT VISIT_ID FROM TRANSACTIONS WHERE AMOUNT > 0 ) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(PRICE * U.UNITS) / SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME='IPHONE' THEN 1 ELSE 0 END) = 0 AND SUM(CASE WHEN P.PRODUCT_NAME='S8' THEN 1 ELSE 0 END) >0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(ID) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT(VIEWER_ID) AS ID FROM ( SELECT VIEWER_ID, VIEW_DATE, ARTICLE_ID FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE, ARTICLE_ID)A GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(*) > 1 ORDER BY VIEWER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM PERSON P GROUP BY EMAIL HAVING COUNT(*) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) >= 1 AND SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT SALES.BUYER_ID FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT.PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT DISTINCT SALES.BUYER_ID FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE BUYER_ID IN ( SELECT S.BUYER_ID FROM SALES S, PRODUCT P WHERE P.PRODUCT_ID = S.PRODUCT_ID AND PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN ( SELECT S.BUYER_ID FROM SALES S, PRODUCT P WHERE P.PRODUCT_ID = S.PRODUCT_ID AND PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND P.PRODUCT_ID NOT IN ( SELECT P.PRODUCT_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH T1 AS (SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) SELECT T1.PLAYER_ID, ACTIVITY.DEVICE_ID FROM T1 LEFT JOIN ACTIVITY ON T1.PLAYER_ID=ACTIVITY.PLAYER_ID AND T1.EVENT_DATE=ACTIVITY.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(N) AS NUM FROM ( SELECT NUM AS N FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*) = 1) AS T;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID GROUP BY AUTHOR_ID HAVING COUNT(*) >= 1 ORDER BY AUTHOR_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME AS CUSTOMERS FROM CUSTOMERS C WHERE C.ID NOT IN (SELECT X.ID FROM CUSTOMERS X INNER JOIN ORDERS R ON R.CUSTOMERID = X.ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS (SELECT * FROM SALES LEFT JOIN PRODUCT USING (PRODUCT_ID)) SELECT DISTINCT BUYER_ID FROM TEMP WHERE BUYER_ID NOT IN (SELECT A.BUYER_ID FROM TEMP AS A JOIN TEMP AS B ON A.BUYER_ID=B.BUYER_ID WHERE A.PRODUCT_NAME='S8' AND B.PRODUCT_NAME='IPHONE') AND PRODUCT_NAME='S8';\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT STUDENTS.ID,STUDENTS.NAME FROM STUDENTS LEFT JOIN DEPARTMENTS D ON STUDENTS.DEPARTMENT_ID = D.ID WHERE D.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT S.PRODUCT_ID, P.PRODUCT_NAME, S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM CTE WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE') AND PRODUCT_NAME = 'S8';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME AS CUSTOMERS FROM CUSTOMERS AS C WHERE C.ID NOT IN (SELECT DISTINCT CUSTOMERID FROM ORDERS) ORDER BY NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEES A LEFT OUTER JOIN EMPLOYEEUNI B ON A.ID = B.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P USING(PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH S8 AS ( SELECT DISTINCT(SALES.BUYER_ID) BUYER FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' ), IPHONE AS( SELECT DISTINCT(SALES.BUYER_ID) BUYER FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE' ) SELECT DISTINCT(BUYER_ID) FROM SALES WHERE BUYER_ID IN (SELECT * FROM S8) AND BUYER_ID NOT IN (SELECT * FROM IPHONE);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID, DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID HAVING COUNT(ACTOR_ID - DIRECTOR_ID = 0)>=3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM (SELECT CUSTOMER_ID, TRANSACTION_ID FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID) AS NEWTABLE WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A JOIN LOGINFO B ON A.ACCOUNT_ID=B.ACCOUNT_ID WHERE A.IP_ADDRESS<>B.IP_ADDRESS AND ((A.LOGIN<B.LOGIN AND A.LOGOUT>=B.LOGIN) OR (B.LOGIN<A.LOGIN AND B.LOGOUT>=A.LOGIN));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' GROUP BY EXTRA HAVING EXTRA IS NOT NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID=U.PRODUCT_ID WHERE U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT A.NAME, B.BONUS FROM EMPLOYEE A LEFT OUTER JOIN BONUS B ON A.EMPID = B.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , (COUNT(*)) AS COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID ORDER BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN( SELECT A.PRODUCT_ID FROM SALES A WHERE A.SALE_DATE < '2019-01-01' OR A.SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE, COUNT(DISTINCT C.CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN C.CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM INVOICES A LEFT JOIN CUSTOMERS B ON A.USER_ID = B.CUSTOMER_ID LEFT JOIN CONTACTS C ON B.CUSTOMER_ID = C.USER_ID GROUP BY A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS AS C WHERE ID NOT IN (SELECT DISTINCT(CUSTOMERID) FROM ORDERS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN SALES S ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND P.PRODUCT_ID NOT IN (SELECT P1.PRODUCT_ID FROM PRODUCT P1 INNER JOIN SALES S1 ON S1.PRODUCT_ID = P1.PRODUCT_ID WHERE S1.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT AS P INNER JOIN EMPLOYEE AS E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S WHERE S.DEPARTMENT_ID NOT IN (SELECT DEPARTMENTS.ID FROM DEPARTMENTS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY AS A JOIN (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRSTDATE FROM ACTIVITY GROUP BY PLAYER_ID) AS B ON A.PLAYER_ID = B.PLAYER_ID AND A.EVENT_DATE = B.FIRSTDATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE '2019-01-01' > SALE_DATE OR SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT DISTINCT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON LEFT JOIN ADDRESS ON PERSON.PERSONID = ADDRESS.PERSONID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS (SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE') SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH BUYS AS ( SELECT S.BUYER_ID, P.PRODUCT_NAME FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM BUYS WHERE PRODUCT_NAME = 'S8' ) AND BUYER_ID NOT IN (SELECT BUYER_ID FROM BUYS WHERE PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT T.EMAIL FROM (SELECT EMAIL,COUNT(*) AS C FROM PERSON GROUP BY EMAIL) AS T WHERE T.C > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH CTE AS ( SELECT CUSTOMER_NAME, O.CUSTOMER_ID, SUM( CASE WHEN PRODUCT_NAME IN ('A','B') THEN 1 WHEN PRODUCT_NAME = 'C' THEN -1 END) SUMS FROM ORDERS O INNER JOIN CUSTOMERS C ON O.CUSTOMER_ID = C.CUSTOMER_ID GROUP BY CUSTOMER_NAME, O.CUSTOMER_ID ) SELECT CUSTOMER_ID,CUSTOMER_NAME FROM CTE WHERE SUMS =2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE C.CUSTOMER_ID IN (SELECT D.CUSTOMER_ID FROM CUSTOMERS D JOIN ORDERS E ON D.CUSTOMER_ID = E.CUSTOMER_ID WHERE E.PRODUCT_NAME= 'A') AND C.CUSTOMER_ID IN (SELECT D.CUSTOMER_ID FROM CUSTOMERS D JOIN ORDERS E ON D.CUSTOMER_ID = E.CUSTOMER_ID WHERE E.PRODUCT_NAME= 'B') AND C.CUSTOMER_ID NOT IN (SELECT D.CUSTOMER_ID FROM CUSTOMERS D JOIN ORDERS E ON D.CUSTOMER_ID = E.CUSTOMER_ID WHERE E.PRODUCT_NAME= 'C') ORDER BY C.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM PRODUCT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE PRODUCT.PRODUCT_ID NOT IN ( SELECT PRODUCT.PRODUCT_ID FROM PRODUCT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE SALES.SALE_DATE > '2019-03-31' OR SALES.SALE_DATE < '2019-01-01' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID ID FROM VIEWS WHERE VIEWER_ID = AUTHOR_ID ORDER BY VIEWER_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT O.CUSTOMER_ID, C.CUSTOMER_NAME FROM ORDERS O LEFT JOIN CUSTOMERS C ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE O.CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='A') AND O.CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='B') AND O.CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT B.USER_ID, B.PAGE_ID FROM FRIENDSHIP A LEFT OUTER JOIN LIKES B ON (A.USER2_ID=B.USER_ID OR A.USER1_ID=B.USER_ID) AND (A.USER1_ID=1 OR A.USER2_ID=1) WHERE B.PAGE_ID NOT IN (SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID=1)) T;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT T.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN ( SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' ) ) AS T ON T.PRODUCT_ID = P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT P.LASTNAME, P.FIRSTNAME, A.CITY, A.STATE FROM PERSON AS P LEFT JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH A AS ( SELECT COMPANY_ID, MAX(SALARY) MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID ), B AS ( SELECT COMPANY_ID, CASE WHEN MAX_SALARY < 1000 THEN 0 WHEN MAX_SALARY <= 10000 THEN 0.24 ELSE 0.49 END TAX_RATE FROM A ) SELECT C.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY - SALARY * TAX_RATE) SALARY FROM SALARIES C JOIN B ON C.COMPANY_ID = B.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CC AS ( SELECT USER_ID, COUNT(*) NUMBER FROM CONTACTS GROUP BY USER_ID ) , TC AS ( SELECT USER_ID, SUM(CASE WHEN CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TCO FROM CONTACTS GROUP BY USER_ID ) , TEMP AS ( SELECT A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE, A.USER_ID FROM INVOICES A INNER JOIN CUSTOMERS B ON A.USER_ID=B.CUSTOMER_ID ) SELECT A.INVOICE_ID, A.CUSTOMER_NAME, A.PRICE, CASE WHEN B.NUMBER IS NULL THEN 0 ELSE B.NUMBER END AS CONTACTS_CNT, CASE WHEN C.TCO IS NULL THEN 0 ELSE C.TCO END AS TRUSTED_CONTACTS_CNT FROM TEMP A LEFT JOIN CC B ON A.USER_ID=B.USER_ID LEFT JOIN TC C ON A.USER_ID=C.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] WITH T1 AS(SELECT EMAIL, COUNT(*) FROM PERSON GROUP BY EMAIL HAVING COUNT(*) > 1) SELECT EMAIL FROM T1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME AS NAME, B.BONUS AS BONUS FROM BONUS B RIGHT JOIN EMPLOYEE E ON B.EMPID = E.EMPID WHERE B.BONUS < 1000 OR B.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID=TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT A.COMPANY_ID, A.EMPLOYEE_ID, A.EMPLOYEE_NAME, ROUND(A.SALARY - (A.SALARY * CASE WHEN B.MAX_SALARY > 10000 THEN 0.49 WHEN B.MAX_SALARY > 1000 THEN 0.24 ELSE 0 END),0) AS SALARY FROM SALARIES AS A JOIN ( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID ) AS B ON A.COMPANY_ID=B.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT X.CLASS FROM (SELECT DISTINCT(CLASS) AS CLASS, COUNT(DISTINCT(STUDENT)) FROM COURSES GROUP BY CLASS HAVING COUNT(DISTINCT(STUDENT))>4) AS X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT PERSON.LASTNAME, PERSON.FIRSTNAME, ADDRESS.CITY, ADDRESS.STATE FROM PERSON LEFT JOIN ADDRESS ON PERSON.PERSONID = ADDRESS.PERSONID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(I1.TIV_2016),2) AS TIV_2016 FROM INSURANCE AS I1 WHERE I1.TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) > 1) AND (I1.LAT, I1.LON) NOT IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) > 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND S.BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID WHERE S.DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, SUM(CASE WHEN DURATION/60 < 5 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS UNION SELECT '[5-10>' AS BIN, SUM(CASE WHEN DURATION/60 >= 5 AND DURATION/60 < 10 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS UNION SELECT '[10-15>' AS BIN, SUM(CASE WHEN DURATION/60 >= 10 AND DURATION/60 < 15 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS UNION SELECT '15 OR MORE' AS BIN, SUM(CASE WHEN DURATION/60 >= 15 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME='S8' THEN 1 ELSE 0 END)>=1 AND SUM(CASE WHEN PRODUCT_NAME='IPHONE' THEN 1 ELSE 0 END)=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH UNIQUES AS ( SELECT DISTINCT PRODUCT_ID, PURCHASE_DATE, UNITS FROM UNITSSOLD ) SELECT U.PRODUCT_ID, ROUND(SUM(U.UNITS * P.PRICE) / SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM UNIQUES U JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT USER2_ID AS FRIEND FROM FRIENDSHIP WHERE USER1_ID =1 UNION SELECT USER1_ID AS FRIEND FROM FRIENDSHIP WHERE USER2_ID =1) F JOIN LIKES L ON F.FRIEND=L.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(VISITS.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AS AVERAGE_PRICE FROM (SELECT P.*, U.UNITS FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID WHERE U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) SUB GROUP BY PRODUCT_ID ORDER BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T1 AS ( SELECT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME IN('S8', 'IPHONE') GROUP BY BUYER_ID HAVING COUNT(DISTINCT S.PRODUCT_ID) = 2 ), T2 AS ( SELECT DISTINCT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' ) SELECT T2.BUYER_ID FROM T2 LEFT JOIN T1 ON T2.BUYER_ID = T1.BUYER_ID WHERE T1.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(*) >= 2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH T AS ( SELECT DISTINCT A.* FROM INSURANCE A LEFT JOIN INSURANCE B ON A.TIV_2015 = B.TIV_2015 AND A.PID != B.PID WHERE B.PID IS NOT NULL ) SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM T WHERE (LAT,LON) NOT IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(DISTINCT PID) > 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM FRIENDSHIP F, LIKES L WHERE ((F.USER1_ID = 1 AND L.USER_ID = F.USER2_ID) OR (F.USER2_ID = 1 AND L.USER_ID = F.USER1_ID)) AND L.PAGE_ID NOT IN ( SELECT L2.PAGE_ID FROM LIKES L2 WHERE L2.USER_ID = 1 );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT U.UNIQUE_ID UNIQUE_ID, E.NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI U ON E.ID = U.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID WHERE PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH T1 AS ( SELECT USER_ID, COUNT(*) AS CONTACTS_CNT, SUM(TRUSTED_FLAG) AS TRUSTED_CONTACTS_CNT FROM (SELECT A.*, CASE WHEN B.CUSTOMER_NAME IS NOT NULL THEN 1 ELSE 0 END AS TRUSTED_FLAG FROM CONTACTS A LEFT JOIN CUSTOMERS B ON A.CONTACT_NAME=B.CUSTOMER_NAME AND A.CONTACT_EMAIL=B.EMAIL) C GROUP BY USER_ID ) SELECT A.INVOICE_ID,B.CUSTOMER_NAME, A.PRICE, COALESCE(C.CONTACTS_CNT,0) AS CONTACTS_CNT , COALESCE(C.TRUSTED_CONTACTS_CNT,0) AS TRUSTED_CONTACTS_CNT FROM INVOICES A LEFT JOIN CUSTOMERS B ON A.USER_ID=B.CUSTOMER_ID LEFT JOIN T1 C ON A.USER_ID=C.USER_ID ORDER BY A.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(P2.X-P1.X) SHORTEST FROM POINT P1 JOIN POINT P2 ON P1.X<P2.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE * US.UNITS) / SUM(US.UNITS), 2) AS AVERAGE_PRICE FROM PRICES AS P LEFT OUTER JOIN UNITSSOLD AS US ON P.PRODUCT_ID = US.PRODUCT_ID AND P.START_DATE <= US.PURCHASE_DATE AND US.PURCHASE_DATE <= P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT AUTHOR_ID AS ID FROM (SELECT AUTHOR_ID,VIEWER_ID FROM VIEWS GROUP BY AUTHOR_ID,VIEWER_ID HAVING AUTHOR_ID = VIEWER_ID) TEMP ORDER BY TEMP.AUTHOR_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID AS PROJECT_ID ,ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM EMPLOYEE E INNER JOIN PROJECT P ON E.EMPLOYEE_ID = P.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE AS( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID) SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, CASE WHEN MAX_SALARY < 1000 THEN ROUND(S.SALARY, 0) WHEN MAX_SALARY>=1000 AND MAX_SALARY<=10000 THEN ROUND(S.SALARY*(1-0.24),0) WHEN MAX_SALARY > 10000 THEN ROUND(S.SALARY*(1-0.49),0) END AS SALARY FROM SALARIES S JOIN CTE ON CTE.COMPANY_ID = S.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM (SELECT CLASS,COUNT(CLASS)FROM COURSES GROUP BY CLASS HAVING COUNT(CLASS)>=5) AS B;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH TABLE1 AS ( SELECT USER2_ID AS USERS FROM FRIENDSHIP WHERE USER1_ID=1 UNION SELECT USER1_ID AS USERS FROM FRIENDSHIP WHERE USER2_ID=1 ) SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM TABLE1 T JOIN LIKES L ON T.USERS=L.USER_ID WHERE L.PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID ORDER BY NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CONTACTS_COUNT AS ( SELECT USER_ID, COUNT(CONTACT_EMAIL) AS TOTAL_CONTACTS FROM CONTACTS GROUP BY USER_ID ), TRUSTED_CONTACT_COUNTS AS ( SELECT USER_ID, COUNT(CONTACT_EMAIL) AS TOTAL_TRUTSED_CONTACTS FROM ( SELECT A.CUSTOMER_ID, A.EMAIL, B.USER_ID, B.CONTACT_EMAIL FROM CUSTOMERS A INNER JOIN CONTACTS B ON A.EMAIL=B.CONTACT_EMAIL ) T1 GROUP BY USER_ID ), INVOICEINFO_JOINED AS ( SELECT INVOICE_ID, PRICE, T1.USER_ID, (CASE WHEN TOTAL_CONTACTS IS NOT NULL THEN TOTAL_CONTACTS ELSE 0 END) AS CONTACTS_CNT , (CASE WHEN TOTAL_TRUTSED_CONTACTS IS NOT NULL THEN TOTAL_TRUTSED_CONTACTS ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM ( SELECT INVOICE_ID, PRICE, A.USER_ID, TOTAL_CONTACTS FROM INVOICES A LEFT JOIN CONTACTS_COUNT B ON A.USER_ID=B.USER_ID) T1 LEFT JOIN TRUSTED_CONTACT_COUNTS T2 ON T1.USER_ID=T2.USER_ID ) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICEINFO_JOINED A INNER JOIN CUSTOMERS B ON A.USER_ID=B.CUSTOMER_ID ORDER BY INVOICE_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT O.CUSTOMER_ID,CUSTOMER_NAME FROM ORDERS O JOIN CUSTOMERS C ON O.CUSTOMER_ID = C.CUSTOMER_ID WHERE PRODUCT_NAME='B' AND O.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='A') AND O.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='C');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT C.BUYER_ID FROM SALES C JOIN PRODUCT D ON C.PRODUCT_ID = D.PRODUCT_ID WHERE BUYER_ID IN (SELECT B.BUYER_ID FROM SALES B JOIN PRODUCT A ON B.PRODUCT_ID = A.PRODUCT_ID WHERE A.PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT F.BUYER_ID FROM SALES F JOIN PRODUCT E ON F.PRODUCT_ID = E.PRODUCT_ID WHERE E.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(I_4.TIV_2016) AS TIV_2016 FROM ( SELECT TIV_2016 FROM INSURANCE AS I_1, (SELECT TIV_2015, COUNT(*) FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(TIV_2015) > 1) AS I_2, (SELECT LAT, LON, COUNT(*) FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) = 1) AS I_3 WHERE I_1.TIV_2015 = I_2.TIV_2015 AND I_1.LAT = I_3.LAT AND I_1.LON = I_3.LON ) I_4;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] WITH A AS (SELECT EMAIL, COUNT(*) AS NUM FROM PERSON GROUP BY EMAIL) SELECT EMAIL AS EMAIL FROM A WHERE NUM>1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(C2.CONTACT_NAME) AS CONTACTS_CNT , COUNT(C1.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS C2 ON C.CUSTOMER_ID = C2.USER_ID LEFT JOIN CUSTOMERS C1 ON C2.CONTACT_EMAIL = C1.EMAIL GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.SALE_DATE BETWEEN '2019-01-01 ' AND '2019-03-31' AND P.PRODUCT_ID NOT IN ( SELECT P.PRODUCT_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*) = 1 ORDER BY 1 DESC LIMIT 1) A;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID GROUP BY AUTHOR_ID HAVING COUNT(ARTICLE_ID) >= 1 ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(A.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS AS A LEFT JOIN TRANSACTIONS AS B ON A.VISIT_ID = B.VISIT_ID WHERE B.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(CT.CONTACT_EMAIL) AS CONTACTS_CNT , SUM(CASE WHEN CT.CONTACT_EMAIL IN (SELECT DISTINCT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS CT ON CT.USER_ID = C.CUSTOMER_ID GROUP BY I.INVOICE_ID,C.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT AS P WHERE P.PRODUCT_ID IN ( SELECT PRODUCT_ID FROM SALES AS S GROUP BY S.PRODUCT_ID HAVING MAX(S.SALE_DATE) BETWEEN '2019-01-01' AND '2019-04-01' AND MIN(S.SALE_DATE) BETWEEN '2019-01-01' AND '2019-04-01');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE PID IN (SELECT DISTINCT I1.PID FROM INSURANCE I1 INNER JOIN INSURANCE I2 ON I1.PID != I2.PID AND I1.TIV_2015 = I2.TIV_2015 WHERE I1.PID NOT IN (SELECT I1.PID FROM INSURANCE I1 INNER JOIN INSURANCE I2 ON I1.PID != I2.PID AND (I1.LAT = I2.LAT AND I1.LON = I2.LON)));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM (SELECT E.EMPID, E.NAME, B.BONUS FROM EMPLOYEE AS E LEFT JOIN BONUS AS B ON E.EMPID = B.EMPID) AS TEMP WHERE BONUS IS NULL OR BONUS < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM STUDENTS LEFT OUTER JOIN (SELECT ID AS DEPARTMENT_ID, NAME AS DEPARTMENT_NAME FROM DEPARTMENTS) AS TEMP ON STUDENTS.DEPARTMENT_ID = TEMP.DEPARTMENT_ID WHERE DEPARTMENT_NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT AS P JOIN SALES AS S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_ID NOT IN (SELECT P.PRODUCT_ID FROM PRODUCT AS P JOIN SALES AS S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE (S.SALE_DATE > '2019-03-31'OR S.SALE_DATE < '2019-01-01'));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T1 AS ( SELECT SALES.BUYER_ID, PRODUCT.PRODUCT_NAME FROM SALES LEFT OUTER JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE (PRODUCT_NAME = 'S8') OR (PRODUCT_NAME = 'IPHONE') ), T2 AS ( SELECT BUYER_ID FROM T1 WHERE PRODUCT_NAME = 'S8' ), T3 AS ( SELECT BUYER_ID FROM T1 WHERE PRODUCT_NAME = 'IPHONE' ) SELECT DISTINCT BUYER_ID FROM T2 WHERE BUYER_ID NOT IN (SELECT * FROM T3) ORDER BY BUYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT DISTINCT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID,MAKE_NAME ORDER BY MAKE_NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE='2019-07-04' AND EXTRA<>'NULL' AND ACTION='REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS ( SELECT SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE, PRDT.PRODUCT_NAME AS PRODUCT_NAME FROM SALES SALES LEFT JOIN PRODUCT PRDT ON SALES.PRODUCT_ID = PRDT.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM TEMP WHERE BUYER_ID IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME IN ('S8')) AND BUYER_ID NOT IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME IN ('IPHONE'));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT DISTINCT A.EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS AS A WHERE A.EXTRA IS NOT NULL AND A.ACTION_DATE='2019-07-04' AND A.ACTION='REPORT' GROUP BY A.EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE2', STORE2 FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE3', STORE3 FROM PRODUCTS WHERE STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT A.PROJECT_ID, ROUND(SUM(B.EXPERIENCE_YEARS)/COUNT(B.NAME), 2) AS AVERAGE_YEARS FROM PROJECT A LEFT JOIN EMPLOYEE B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S RIGHT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND S.BUYER_ID NOT IN (SELECT DISTINCT S.BUYER_ID FROM SALES S RIGHT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE (V.VISIT_ID,T.TRANSACTION_ID) NOT IN (SELECT VISIT_ID, TRANSACTION_ID FROM TRANSACTIONS) GROUP BY V.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE1 AS( SELECT COMPANY_ID, MAX(SALARY) AS MAXX FROM SALARIES GROUP BY COMPANY_ID) SELECT CTE1.COMPANY_ID,S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(S.SALARY - S.SALARY*0.49,0) AS SALARY FROM SALARIES S JOIN CTE1 ON S.COMPANY_ID = CTE1.COMPANY_ID WHERE MAXX > 10000 UNION SELECT CTE1.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(S.SALARY,0) AS SALARY FROM SALARIES S JOIN CTE1 ON S.COMPANY_ID = CTE1.COMPANY_ID WHERE MAXX < 1000 UNION SELECT CTE1.COMPANY_ID,S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(S.SALARY - S.SALARY*0.24,0) AS SALARY FROM SALARIES S JOIN CTE1 ON S.COMPANY_ID = CTE1.COMPANY_ID WHERE MAXX > 1000 AND MAXX < 10000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID=U.PRODUCT_ID WHERE U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT DISTINCT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID)AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND ACTION ='REPORT' AND EXTRA IS NOT NULL GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EU.UNIQUE_ID, E.NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EU ON E.ID = EU.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A JOIN LOGINFO B ON A.ACCOUNT_ID = B.ACCOUNT_ID WHERE B.LOGIN BETWEEN A.LOGIN AND A.LOGOUT AND A.IP_ADDRESS != B.IP_ADDRESS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT(ARTICLE_ID)) >1 ORDER BY 1 ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE AS( SELECT CON.USER_ID, COUNT(CON.CONTACT_NAME) AS CONTACTS_CNT, COUNT(CUS.CUSTOMER_NAME) AS TRUSTED_CONTACTS_CNT FROM CONTACTS CON LEFT JOIN CUSTOMERS CUS ON CON.CONTACT_NAME = CUS.CUSTOMER_NAME GROUP BY CON.USER_ID ) SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COALESCE(CTE.CONTACTS_CNT,0) AS CONTACTS_CNT, COALESCE(CTE.TRUSTED_CONTACTS_CNT,0) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CTE ON I.USER_ID = CTE.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH STAGING AS (SELECT CUSTOMER_ID , COUNT(DISTINCT(CASE WHEN PRODUCT_NAME IN ('A', 'B') THEN PRODUCT_NAME ELSE NULL END)) AS AANDBCOUNT , COUNT(DISTINCT(CASE WHEN PRODUCT_NAME = 'C' THEN PRODUCT_NAME ELSE NULL END)) AS CCOUNT FROM ORDERS GROUP BY CUSTOMER_ID) SELECT CUSTOMERS.CUSTOMER_ID, CUSTOMERS.CUSTOMER_NAME FROM STAGING JOIN CUSTOMERS ON STAGING.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID WHERE AANDBCOUNT >= 2 AND CCOUNT = 0;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM ( SELECT EMAIL AS EMAIL, COUNT(ID) AS NUM FROM PERSON GROUP BY EMAIL ) AS HIMAN WHERE NUM > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME, B.BONUS FROM EMPLOYEE AS E LEFT OUTER JOIN BONUS AS B ON E.EMPID = B.EMPID WHERE B.BONUS<1000 OR B.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] WITH C AS (SELECT DISTINCT * FROM COURSES) SELECT CLASS FROM C GROUP BY CLASS HAVING COUNT(*)>=5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM (SELECT COUNT(*) C, EMAIL FROM PERSON GROUP BY EMAIL) T WHERE C > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE S.BUYER_ID NOT IN( SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME='IPHONE') AND P.PRODUCT_NAME='S8';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' ) AND PRODUCT_ID IN ( SELECT PRODUCT_ID FROM SALES );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE,COALESCE(C.CONTACTS_CNT,0) AS CONTACTS_CNT, COALESCE(D.TRUSTED_CONTACTS_CNT,0) AS TRUSTED_CONTACTS_CNT FROM INVOICES AS A LEFT JOIN CUSTOMERS AS B ON A.USER_ID=B.CUSTOMER_ID LEFT JOIN (SELECT USER_ID, COUNT(DISTINCT CONTACT_NAME) AS CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID) AS C ON A.USER_ID=C.USER_ID LEFT JOIN (SELECT USER_ID, COUNT(DISTINCT CONTACT_NAME) AS TRUSTED_CONTACTS_CNT FROM CONTACTS WHERE CONTACT_NAME IN ( SELECT DISTINCT CUSTOMER_NAME FROM CUSTOMERS) GROUP BY USER_ID) AS D ON A.USER_ID= D.USER_ID ORDER BY A.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID, COUNT(VISITS.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN (SELECT T.VISIT_ID, V.CUSTOMER_ID FROM TRANSACTIONS T LEFT JOIN VISITS V ON V.VISIT_ID = T.VISIT_ID) A ON VISITS.VISIT_ID = A.VISIT_ID WHERE A.VISIT_ID IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH CTE AS ( SELECT U.PRODUCT_ID AS PRODUCT_ID, UNITS, PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE >= P.START_DATE AND U.PURCHASE_DATE <= P.END_DATE) SELECT PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AS AVERAGE_PRICE FROM CTE GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD W WHERE W.POPULATION > 25000000 OR W.AREA > 3000000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH CTE AS ( SELECT A.CID AS CUSTOMERID FROM (SELECT CUSTOMER_ID AS CID FROM ORDERS WHERE PRODUCT_NAME = 'A' ) A JOIN (SELECT CUSTOMER_ID AS CID FROM ORDERS WHERE PRODUCT_NAME = 'B') B ON A.CID = B.CID WHERE A.CID NOT IN (SELECT DISTINCT CUSTOMER_ID AS CID FROM ORDERS WHERE PRODUCT_NAME = 'C') ) SELECT DISTINCT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN CTE ON C.CUSTOMER_ID = CTE.CUSTOMERID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH T1 AS (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31') SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT AS P WHERE P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM T1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRODUCT_ID, ROUND(SUM(A) / SUM(UNITS), 2) AS AVERAGE_PRICE FROM (SELECT P.PRODUCT_ID AS PRODUCT_ID, PRICE, UNITS, PRICE * UNITS AS A FROM PRICES AS P LEFT JOIN UNITSSOLD AS U ON P.PRODUCT_ID = U.PRODUCT_ID AND (PURCHASE_DATE <= END_DATE AND PURCHASE_DATE >= START_DATE) ) AS T GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01 00:00:00' AND '2019-03-31 23:59:59' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME, B.BONUS FROM EMPLOYEE E LEFT OUTER JOIN BONUS B ON (E.EMPID = B.EMPID) WHERE B.BONUS < 1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS USING(VISIT_ID) WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE AS ( SELECT COMPANY_ID, CASE WHEN MAX(SALARY) > 10000 THEN 0.49 WHEN MAX(SALARY) BETWEEN 1000 AND 10000 THEN 0.24 ELSE 0 END AS TAX_RATES FROM SALARIES GROUP BY COMPANY_ID ) SELECT S.COMPANY_ID,S.EMPLOYEE_ID,S.EMPLOYEE_NAME,ROUND((S.SALARY - S.SALARY * C.TAX_RATES),0) AS SALARY FROM SALARIES S LEFT JOIN CTE C ON S.COMPANY_ID = C.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN (SELECT DISTINCT S.PRODUCT_ID FROM SALES S WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < CAST('2019-01-01' AS DATE) OR SALE_DATE > CAST('2019-03-31' AS DATE));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES,FRIENDSHIP WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1) AND ( USER_ID IN (SELECT USER1_ID FROM FRIENDSHIP WHERE USER2_ID=1) OR USER_ID IN (SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID=1));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH MAX_SALARIES AS ( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID ) SELECT S.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(CASE WHEN MAX_SALARY < 1000 THEN SALARY WHEN MAX_SALARY > 10000 THEN SALARY*0.51 ELSE SALARY*0.76 END) AS SALARY FROM SALARIES AS S JOIN MAX_SALARIES AS M ON S.COMPANY_ID = M.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID IN(SELECT DEPARTMENT_ID FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V WHERE V.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] WITH R1 AS( SELECT EMAIL, COUNT(EMAIL) AS EMAILCOUNT FROM PERSON GROUP BY EMAIL ) SELECT EMAIL FROM R1 WHERE EMAILCOUNT>1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON ,COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION_DATE='2019/07/04' AND ACTION='REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, E.NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI U ON E.ID = U.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T1 AS ( SELECT S.BUYER_ID, S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM T1 WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM T1 WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND S.BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S1 JOIN PRODUCT P1 ON S1.PRODUCT_ID = P1.PRODUCT_ID WHERE P1.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES AS A WHERE (USER_ID IN (SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID=1) OR USER_ID IN (SELECT USER1_ID FROM FRIENDSHIP WHERE USER2_ID=1)) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID =1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(1.00 * EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT AS P JOIN EMPLOYEE AS E ON P.EMPLOYEE_ID=E.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'IPHONE') AND BUYER_ID IN (SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT S.BUYER_ID, S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID ) SELECT DISTINCT C1.BUYER_ID FROM CTE C1 LEFT JOIN ( SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE' ) C2 ON C1.BUYER_ID = C2.BUYER_ID WHERE C1.PRODUCT_NAME = 'S8' AND C2.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS A ON A.CUSTOMER_ID = C.CUSTOMER_ID AND A.PRODUCT_NAME = 'A' JOIN ORDERS B ON B.CUSTOMER_ID = C.CUSTOMER_ID AND B.PRODUCT_NAME = 'B' LEFT OUTER JOIN ORDERS O ON O.CUSTOMER_ID = C.CUSTOMER_ID AND O.PRODUCT_NAME = 'C' WHERE O.ORDER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S WHERE S.DEPARTMENT_ID NOT IN (SELECT DISTINCT ID FROM DEPARTMENTS D);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.VIEWER_ID AS ID FROM VIEWS V1, VIEWS V2 WHERE V1.VIEWER_ID = V2.VIEWER_ID AND V1.VIEW_DATE = V2.VIEW_DATE AND V1.ARTICLE_ID <> V2.ARTICLE_ID ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE AS ( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID ) SELECT S.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND((CASE WHEN MAX_SALARY BETWEEN 1000 AND 10000 THEN SALARY*0.76 WHEN MAX_SALARY > 10000 THEN SALARY*0.51 ELSE SALARY END), 0) AS SALARY FROM SALARIES S JOIN CTE ON CTE.COMPANY_ID = S.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT A.EMAIL FROM PERSON AS A JOIN PERSON AS B ON A.EMAIL = B.EMAIL WHERE A.ID <> B.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT V.CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS AS V WHERE V.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN ( SELECT A.BUYER_ID FROM SALES AS A INNER JOIN PRODUCT AS B ON A.PRODUCT_ID=B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT A.BUYER_ID FROM SALES AS A INNER JOIN PRODUCT AS B ON A.PRODUCT_ID=B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID, COUNT(A.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS A LEFT JOIN TRANSACTIONS AS B ON A.VISIT_ID = B.VISIT_ID WHERE B.TRANSACTION_ID IS NULL GROUP BY A.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT DISTINCT ACTOR_ID ,DIRECTOR_ID FROM(SELECT ACTOR_ID, DIRECTOR_ID, COUNT(ACTOR_ID) AS CNT FROM ACTORDIRECTOR GROUP BY DIRECTOR_ID, ACTOR_ID) AS INN WHERE CNT > 2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN ((SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID = 1) UNION (SELECT DISTINCT USER1_ID FROM FRIENDSHIP WHERE USER2_ID = 1)) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, DEVICE_ID FROM ACTIVITY A LEFT JOIN ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_EVENT FROM ACTIVITY GROUP BY PLAYER_ID ) Z ON A.PLAYER_ID = Z.PLAYER_ID WHERE EVENT_DATE = FIRST_EVENT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH T1 AS ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A' AND CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C')) SELECT T1.CUSTOMER_ID, C.CUSTOMER_NAME FROM T1 LEFT JOIN CUSTOMERS C ON T1.CUSTOMER_ID = C.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT JOIN EMPLOYEE ON PROJECT.EMPLOYEE_ID = EMPLOYEE.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT DISTINCT ABS(P1.X - P2.X) AS SHORTEST FROM POINT P1, POINT P2 WHERE ABS(P1.X - P2.X) >0 ORDER BY ABS(P1.X - P2.X) LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN ( SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' ) AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM PRODUCT RIGHT JOIN SALES USING(PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(T2.PLAYER_ID) / COUNT(T1.PLAYER_ID), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) T1 LEFT JOIN ACTIVITY T2 ON T1.PLAYER_ID = T2.PLAYER_ID AND T1.FIRST_LOGIN = T2.EVENT_DATE - 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME , POPULATION , AREA FROM WORLD WHERE (AREA > 3000000) OR(POPULATION>25000000);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID AS PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON E.EMPLOYEE_ID=P.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(A2.PLAYER_ID)/COUNT(A1.PLAYER_ID),2) AS FRACTION FROM ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGING FROM ACTIVITY GROUP BY PLAYER_ID) A1 LEFT JOIN ACTIVITY A2 ON A1.PLAYER_ID = A2.PLAYER_ID AND A2.EVENT_DATE - 1 = A1.FIRST_LOGING;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CONTACT_COUNT AS ( SELECT CU.CUSTOMER_ID, COUNT(*) AS CONTACTS_CNT FROM CUSTOMERS CU JOIN CONTACTS CO ON CU.CUSTOMER_ID = CO.USER_ID GROUP BY CU.CUSTOMER_ID ), TRUSTED_CONTACT AS ( SELECT CU.CUSTOMER_ID, COUNT(*) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS CU JOIN (SELECT * FROM CONTACTS WHERE CONTACT_EMAIL IN (SELECT DISTINCT EMAIL FROM CUSTOMERS)) CO ON CU.CUSTOMER_ID = CO.USER_ID GROUP BY CU.CUSTOMER_ID ) SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COALESCE(CC.CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(TC.TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACT_COUNT CC ON I.USER_ID = CC.CUSTOMER_ID LEFT JOIN TRUSTED_CONTACT TC ON I.USER_ID = TC.CUSTOMER_ID ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT SS8.BUYER_ID FROM SALES AS SS8 INNER JOIN PRODUCT AS PS8 ON PS8.PRODUCT_ID = SS8.PRODUCT_ID AND PRODUCT_NAME = 'S8' LEFT JOIN (SELECT S.BUYER_ID, S.PRODUCT_ID FROM SALES S INNER JOIN PRODUCT AS PIPHONE ON PIPHONE.PRODUCT_ID = S.PRODUCT_ID AND PIPHONE.PRODUCT_NAME = 'IPHONE') AS SIPHONE ON SS8.BUYER_ID = SIPHONE.BUYER_ID WHERE SIPHONE.PRODUCT_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH FRIENDSHIP_TABLE AS ( SELECT CASE WHEN USER1_ID < USER2_ID THEN USER1_ID ELSE USER2_ID END AS USER1_ID, CASE WHEN USER1_ID > USER2_ID THEN USER1_ID ELSE USER2_ID END AS USER2_ID FROM FRIENDSHIP WHERE USER1_ID = 1 OR USER2_ID = 1 ) SELECT DISTINCT T2.PAGE_ID AS RECOMMENDED_PAGE FROM FRIENDSHIP_TABLE T1 JOIN LIKES T2 ON T1.USER2_ID = T2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT A.* FROM CUSTOMERS A JOIN ORDERS B ON A.CUSTOMER_ID = B.CUSTOMER_ID WHERE A.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME ='A') AND A.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME ='B') AND A.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME ='C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND S.BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(DISTINCT T2.PLAYER_ID)/COUNT(DISTINCT T1.PLAYER_ID),2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) T1 LEFT JOIN ACTIVITY T2 ON T1.PLAYER_ID = T2.PLAYER_ID AND T1.FIRST_LOGIN = T2.EVENT_DATE - 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT(LEAD_ID)) AS UNIQUE_LEADS, COUNT(DISTINCT(PARTNER_ID)) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME ORDER BY UNIQUE_PARTNERS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(DISTINCT T1.PLAYER_ID)/COUNT(DISTINCT A1.PLAYER_ID),2) AS FRACTION FROM ACTIVITY A1 LEFT JOIN ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID ) T1 ON A1.PLAYER_ID = T1.PLAYER_ID AND A1.EVENT_DATE = T1.MIN_DATE+1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH FRIENDS AS ( SELECT USER2_ID AS ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER1_ID AS ID FROM FRIENDSHIP WHERE USER2_ID = 1) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM FRIENDS F JOIN LIKES L ON F.ID = L.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM PRODUCT A INNER JOIN SALES B ON A.PRODUCT_ID=B.PRODUCT_ID WHERE PRODUCT_NAME='S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM PRODUCT A INNER JOIN SALES B ON A.PRODUCT_ID=B.PRODUCT_ID WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS C WHERE C.ID NOT IN (SELECT CUSTOMERID FROM ORDERS O);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON T.VISIT_ID = V.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME AS CUSTOMERS FROM CUSTOMERS AS C WHERE C.ID NOT IN (SELECT ORDERS.CUSTOMERID FROM ORDERS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH A1 AS( SELECT COMPANY_ID, MAX(SALARY) AS MAXSALA FROM SALARIES GROUP BY COMPANY_ID ) SELECT S.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY * CASE WHEN MAXSALA<1000 THEN 1 WHEN MAXSALA>=1000 AND MAXSALA<=10000 THEN 0.76 WHEN MAXSALA>10000 THEN 0.51 END,0) AS SALARY FROM A1 RIGHT JOIN SALARIES S ON A1.COMPANY_ID = S.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] WITH CTE_FINAL AS ( SELECT NAME FROM CUSTOMER WHERE COALESCE(REFEREE_ID, 'SOME BOGUS VALUE OF YOUR CHOOSING') != 2 ) SELECT * FROM CTE_FINAL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT DISTINCT C.PRODUCT_ID, CAST((SUM(C.TOTPRICE)/SUM(C.UNITS)) AS DECIMAL(5,2)) AVERAGE_PRICE FROM ( SELECT B.PRODUCT_ID, A.PRICE*B.UNITS AS TOTPRICE, B.UNITS FROM UNITSSOLD B LEFT JOIN PRICES A ON B.PRODUCT_ID = A.PRODUCT_ID WHERE B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE ) AS C GROUP BY C.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT SALES.BUYER_ID FROM SALES INNER JOIN PRODUCT ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE BUYER_ID IN ( SELECT DISTINCT SALES.BUYER_ID FROM SALES LEFT JOIN ( SELECT SALES.BUYER_ID FROM SALES INNER JOIN PRODUCT ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE PRODUCT.PRODUCT_NAME='IPHONE') IPHONEUSERS ON SALES.BUYER_ID = IPHONEUSERS.BUYER_ID WHERE IPHONEUSERS.BUYER_ID IS NULL ) AND PRODUCT_NAME='S8';\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT (POST_ID)) AS REPORT_COUNT FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT T1.ID, T1.NAME FROM STUDENTS T1 LEFT JOIN DEPARTMENTS T2 ON T2.ID = T1.DEPARTMENT_ID WHERE T2.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEES AS EMP LEFT JOIN EMPLOYEEUNI AS UNI ON EMP.ID = UNI.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE BUYER_ID IN ( SELECT S.BUYER_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P. PRODUCT_ID WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN ( SELECT S.BUYER_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P. PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE1 AS (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME='S8'), CTE2 AS (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME='IPHONE'), CTE3 AS (SELECT DISTINCT BUYER_ID FROM SALES S JOIN CTE1 ON CTE1.PRODUCT_ID=S.PRODUCT_ID), CTE4 AS (SELECT DISTINCT BUYER_ID FROM SALES S JOIN CTE2 ON CTE2.PRODUCT_ID=S.PRODUCT_ID) SELECT CTE3.BUYER_ID FROM CTE3 LEFT JOIN CTE4 ON CTE3.BUYER_ID=CTE4.BUYER_ID WHERE CTE4.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(1) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID=T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND( COUNT(T2.PLAYER_ID) / COUNT(T1.PLAYER_ID), 2 ) AS FRACTION FROM (SELECT DISTINCT PLAYER_ID , MIN(EVENT_DATE) AS FIRST_DAY FROM ACTIVITY GROUP BY PLAYER_ID ) T1 LEFT JOIN ACTIVITY T2 ON T1.PLAYER_ID = T2.PLAYER_ID AND T1.FIRST_DAY + 1 = T2.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(T.NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*) = 1) T;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] WITH COUNT_TABLE AS ( SELECT ACTOR_ID, DIRECTOR_ID, COUNT(ACTOR_ID) AS CT FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID ) SELECT ACTOR_ID, DIRECTOR_ID FROM COUNT_TABLE WHERE CT >= 3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(T1.X - T2.X)) AS SHORTEST FROM POINT T1,POINT T2 WHERE T1.X<>T2.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS A WHERE A.ACTION_DATE='2019-07-04' AND EXTRA IS NOT NULL AND ACTION='REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.NAME, UNI.UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI UNI ON E.ID = UNI.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID=T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT A.EMAIL FROM PERSON A, PERSON B WHERE A.ID != B.ID AND A.EMAIL = B.EMAIL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(A.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS AS A LEFT JOIN TRANSACTIONS AS B ON A.VISIT_ID = B.VISIT_ID WHERE A.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES L JOIN FRIENDSHIP F ON L.USER_ID = F.USER1_ID OR L.USER_ID = F.USER2_ID WHERE ( F.USER1_ID =1 OR F.USER2_ID=1) AND PAGE_ID NOT IN (SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT.PRODUCT_ID FROM SALES JOIN PRODUCT USING (PRODUCT_ID) WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH FRIENDSHIP_TABLE AS ( SELECT CASE WHEN USER1_ID < USER2_ID THEN USER1_ID ELSE USER2_ID END AS USER1_ID, CASE WHEN USER1_ID > USER2_ID THEN USER1_ID ELSE USER2_ID END AS USER2_ID FROM FRIENDSHIP ) SELECT DISTINCT T2.PAGE_ID AS RECOMMENDED_PAGE FROM FRIENDSHIP_TABLE T1 JOIN LIKES T2 ON T1.USER2_ID = T2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1) AND T1.USER1_ID = 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID ,A.DEVICE_ID FROM ACTIVITY A LEFT JOIN (SELECT PLAYER_ID ,MIN(EVENT_DATE) EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID ) B ON A.PLAYER_ID = B.PLAYER_ID WHERE A.EVENT_DATE = B.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH M_SAL AS ( SELECT COMPANY_ID, MAX(SALARY) AS SAL_MAX FROM SALARIES GROUP BY COMPANY_ID ) SELECT S.COMPANY_ID , S.EMPLOYEE_ID , S.EMPLOYEE_NAME , CASE WHEN M.SAL_MAX < 1000 THEN ROUND(S.SALARY,0) WHEN M.SAL_MAX BETWEEN 1000 AND 10000 THEN ROUND((S.SALARY-S.SALARY*.24),0) WHEN M.SAL_MAX > 10000 THEN ROUND((S.SALARY-S.SALARY*.49),0) END AS SALARY FROM SALARIES S LEFT JOIN M_SAL M ON S.COMPANY_ID = M.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01') AND P.PRODUCT_ID IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE >= '2019-01-01' AND SALE_DATE <= '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE AS ( SELECT CUST1.CUSTOMER_ID, CUST1.CUSTOMER_NAME, CUST1.CONTACT_NAME, CUST1.CONTACT_EMAIL FROM ( SELECT CUST.CUSTOMER_ID, CUST.CUSTOMER_NAME, C.CONTACT_NAME, C.CONTACT_EMAIL FROM CUSTOMERS CUST LEFT JOIN CONTACTS C ON CUST.CUSTOMER_ID=C.USER_ID ) CUST1 ) SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, TEMP.CONTACTS_CNT, TEMP.TRUSTED_CONTACTS_CNT FROM INVOICES I INNER JOIN ( SELECT A.CUSTOMER_ID, COUNT(A.CONTACT_NAME) AS CONTACTS_CNT, COUNT(B.CUSTOMER_ID) AS TRUSTED_CONTACTS_CNT FROM CTE A LEFT JOIN CUSTOMERS B ON A.CONTACT_EMAIL=B.EMAIL GROUP BY A.CUSTOMER_ID ) TEMP ON I.USER_ID = TEMP.CUSTOMER_ID INNER JOIN CUSTOMERS C ON I.USER_ID=C.CUSTOMER_ID ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.NAME, U.UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI U ON U.ID = E.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM (SELECT O.CUSTOMER_ID, C.CUSTOMER_NAME, SUM(CASE WHEN PRODUCT_NAME = 'A' THEN 100 WHEN PRODUCT_NAME = 'B' THEN 10 WHEN PRODUCT_NAME = 'C' THEN 1 ELSE 0 END) AS PRODUCT_INDEX FROM ORDERS AS O JOIN CUSTOMERS AS C ON O.CUSTOMER_ID = C.CUSTOMER_ID GROUP BY O.CUSTOMER_ID, C.CUSTOMER_NAME) AS TMP WHERE PRODUCT_INDEX = 110;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE (PRODUCT_NAME = 'A' OR PRODUCT_NAME = 'B') AND C.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') GROUP BY C.CUSTOMER_ID, CUSTOMER_NAME HAVING COUNT(CUSTOMER_NAME) = 2 ORDER BY C.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(VISIT_ID) AS COUNT_NO_TRANS FROM( SELECT V.VISIT_ID, V.CUSTOMER_ID, TRANSACTION_ID, AMOUNT FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE AMOUNT IS NULL ) SUB GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN ( SELECT USER2_ID AS FRIENDS FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER1_ID AS FRIENDS FROM FRIENDSHIP WHERE USER2_ID = 1) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT BUYER_ID, S.PRODUCT_ID, PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM ( SELECT EMAIL, COUNT(EMAIL) AS CNT FROM PERSON GROUP BY EMAIL )TEMP WHERE CNT > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID RECOMMENDED_PAGE FROM( SELECT USER1_ID FIRSTFRIEND, USER2_ID SECONDFRIEND FROM FRIENDSHIP WHERE USER1_ID = '1' UNION SELECT USER2_ID FIRSTFRIEND, USER1_ID SECONDFRIEND FROM FRIENDSHIP WHERE USER2_ID = '1' ) FRIEND INNER JOIN LIKES L ON FRIEND.SECONDFRIEND = L.USER_ID WHERE L.PAGE_ID NOT IN (SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID = '1');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT.PRODUCT_ID,PRODUCT.PRODUCT_NAME FROM PRODUCT WHERE PRODUCT.PRODUCT_ID NOT IN (SELECT SALES.PRODUCT_ID FROM SALES WHERE SALES.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, (CASE WHEN TEMP.MAX_SALARY < 1000 THEN S.SALARY WHEN TEMP.MAX_SALARY > 10000 THEN ROUND(S.SALARY*(1-0.49), 0) ELSE ROUND(S.SALARY*(1-0.24), 0) END) AS SALARY FROM SALARIES S JOIN (SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID) TEMP USING (COMPANY_ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT(EMAIL) FROM PERSON GROUP BY EMAIL HAVING COUNT(*) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON T.VISIT_ID = V.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM(SELECT VIEWER_ID,COUNT(DISTINCT ARTICLE_ID),VIEW_DATE FROM VIEWS GROUP BY VIEW_DATE,VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID)>1)ABC ORDER BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM (SELECT CLASS, COUNT(DISTINCT STUDENT) AS CNT FROM COURSES GROUP BY CLASS) AS TEMP WHERE CNT >= 5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID, DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID HAVING COUNT(ACTOR_ID) >= 3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] WITH CLASS_CT (CLASS, STUDENT_CT) AS ( SELECT CLASS, COUNT(CLASS) AS STUDENT_CT FROM COURSES GROUP BY CLASS ) SELECT CLASS FROM CLASS_CT WHERE STUDENT_CT >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH FRIENDS AS ( SELECT USER1_ID AS USER1, USER2_ID AS USER2 FROM FRIENDSHIP WHERE USER1_ID<USER2_ID UNION SELECT USER2_ID AS USER1, USER1_ID AS USER2 FROM FRIENDSHIP WHERE USER1_ID>USER2_ID ) SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM FRIENDS F JOIN LIKES L ON F.USER2 = L.USER_ID WHERE F.USER1 = 1 AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM ( SELECT DISTINCT STUDENT , CLASS FROM COURSES ) AS T1 GROUP BY CLASS HAVING COUNT(CLASS) >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID AS CUSTOMER_ID, C.CUSTOMER_NAME AS CUSTOMER_NAME FROM CUSTOMERS C INNER JOIN ORDERS A ON C.CUSTOMER_ID = A.CUSTOMER_ID AND A.PRODUCT_NAME = 'A' INNER JOIN ORDERS B ON C.CUSTOMER_ID = B.CUSTOMER_ID AND B.PRODUCT_NAME = 'B' LEFT OUTER JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID AND O.PRODUCT_NAME = 'C' WHERE O.ORDER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN ( SELECT DISTINCT USER2_ID AS USER_ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT DISTINCT USER1_ID AS USER_ID FROM FRIENDSHIP WHERE USER2_ID = 1 ) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.AUTHOR_ID AS ID FROM VIEWS V1 LEFT JOIN VIEWS V2 ON V1.AUTHOR_ID = V2.VIEWER_ID AND V2.ARTICLE_ID = V1.ARTICLE_ID WHERE V2.VIEWER_ID IS NOT NULL ORDER BY V1.AUTHOR_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT P1.PRODUCT_ID, 'STORE1' AS STORE, P1.STORE1 AS PRICE FROM PRODUCTS P1 WHERE P1.STORE1 IS NOT NULL UNION SELECT P2.PRODUCT_ID, 'STORE2' AS STORE, P2.STORE2 AS PRICE FROM PRODUCTS P2 WHERE P2.STORE2 IS NOT NULL UNION SELECT P3.PRODUCT_ID, 'STORE3' AS STORE, P3.STORE3 AS PRICE FROM PRODUCTS P3 WHERE P3.STORE3 IS NOT NULL ORDER BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(UNITS*PRICE)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALES.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND EXTRA IS NOT NULL AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS USING(VISIT_ID) WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID ORDER BY 2 DESC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME, B.BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE (B.BONUS <1000 OR B.BONUS IS NULL);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICES.INVOICE_ID ,CUSTOMERS.CUSTOMER_NAME ,INVOICES.PRICE ,COUNT(CONTACT_NAME) AS CONTACTS_CNT ,COUNT(EMAILS.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES INVOICES LEFT JOIN CUSTOMERS CUSTOMERS ON INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID LEFT JOIN CONTACTS CONTACTS ON INVOICES.USER_ID = CONTACTS.USER_ID LEFT JOIN CUSTOMERS EMAILS ON EMAILS.EMAIL = CONTACTS.CONTACT_EMAIL GROUP BY INVOICES.INVOICE_ID,INVOICES.PRICE,CUSTOMERS.CUSTOMER_NAME ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH SELL_HISTORY AS ( SELECT S.PRODUCT_ID, SUM(CASE WHEN SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' THEN 1 ELSE 0 END) SOLD_OUTSIDE, SUM(CASE WHEN SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' THEN 1 ELSE 0 END) SOLD_INSIDE FROM SALES S GROUP BY S.PRODUCT_ID ) SELECT S.PRODUCT_ID, P.PRODUCT_NAME FROM SELL_HISTORY S LEFT JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SOLD_OUTSIDE = 0 AND S.SOLD_INSIDE > 0;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH ORDER_CNT AS ( SELECT CUSTOMER_ID, SUM( CASE WHEN PRODUCT_NAME IN ('A', 'B') THEN 1 WHEN PRODUCT_NAME = 'C' THEN -1 ELSE 0 END ) AS CNT FROM ORDERS GROUP BY CUSTOMER_ID ) SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM ORDER_CNT JOIN CUSTOMERS C ON C.CUSTOMER_ID = ORDER_CNT.CUSTOMER_ID WHERE ORDER_CNT.CNT = 2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH PRICED_UNITS AS ( SELECT U.PRODUCT_ID, U.UNITS, P.PRICE*U.UNITS AS TOTAL_PRICE FROM UNITSSOLD U INNER JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ) SELECT PRODUCT_ID, ROUND(SUM(TOTAL_PRICE)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM PRICED_UNITS GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT(ACCOUNT_ID) FROM (SELECT L1.ACCOUNT_ID, L1.IP_ADDRESS, L1.LOGIN, L1.LOGOUT FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS !=L2.IP_ADDRESS WHERE (L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT) OR (L1.LOGOUT BETWEEN L2.LOGIN AND L2.LOGOUT) OR (L2.LOGIN BETWEEN L1.LOGIN AND L1.LOGOUT) OR (L2.LOGOUT BETWEEN L1.LOGIN AND L1.LOGOUT)) X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN,COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION / 60 >= 0 AND DURATION / 60 < 5 UNION SELECT '[5-10>' AS BIN, COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION / 60 >= 5 AND DURATION / 60 < 10 UNION SELECT '[10-15>' AS BIN,COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION / 60 >= 10 AND DURATION / 60 < 15 UNION SELECT '15 OR MORE' AS BIN,COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION / 60 >= 15;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(CON.USER_ID) AS CONTACTS_CNT, COUNT(C2.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS C ON(C.CUSTOMER_ID=I.USER_ID) LEFT JOIN CONTACTS CON ON(CON.USER_ID=C.CUSTOMER_ID) LEFT JOIN CUSTOMERS C2 ON (C2.EMAIL=CON.CONTACT_EMAIL) GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH COMPANYMAXSALARIES AS ( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID ), COMPANYTAX AS ( SELECT COMPANY_ID, (CASE WHEN MAX_SALARY > 10000 THEN 0.49 WHEN MAX_SALARY > 1000 THEN 0.24 ELSE 0 END) AS TAX_PERCENT FROM COMPANYMAXSALARIES ), EMPLOYEEPAYCHECKAFTERTAX AS ( SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(S.SALARY * (1-C.TAX_PERCENT),0) AS SALARY FROM SALARIES S INNER JOIN COMPANYTAX C ON S.COMPANY_ID = C.COMPANY_ID ) SELECT * FROM EMPLOYEEPAYCHECKAFTERTAX;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CNT AS( SELECT CUS.CUSTOMER_ID, COUNT(CON.CONTACT_EMAIL) AS CONTACTS_CNT, COUNT(TMP.CONTACT_EMAIL) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS CUS LEFT JOIN CONTACTS CON ON CUS.CUSTOMER_ID = CON.USER_ID LEFT JOIN (SELECT USER_ID, CONTACT_EMAIL FROM CONTACTS WHERE CONTACT_EMAIL IN (SELECT DISTINCT EMAIL FROM CUSTOMERS)) TMP ON CON.CONTACT_EMAIL = TMP.CONTACT_EMAIL AND CUS.CUSTOMER_ID = TMP.USER_ID GROUP BY CUSTOMER_ID) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, CNT.CONTACTS_CNT, CNT.TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID JOIN CNT ON I.USER_ID = CNT.CUSTOMER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT T.VIEWER_ID ID FROM (SELECT DISTINCT ARTICLE_ID, VIEWER_ID, VIEW_DATE FROM VIEWS) T GROUP BY T.VIEWER_ID, T.VIEW_DATE HAVING COUNT(*) > 1 ORDER BY T.VIEWER_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT S1.PRODUCT_ID FROM SALES S1 WHERE S1.SALE_DATE < '2019-01-01' OR S1.SALE_DATE >'2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT DISTINCT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME ='S8' ) AND BUYER_ID NOT IN (SELECT DISTINCT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME ='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT B.PRODUCT_ID, A.PRODUCT_NAME FROM PRODUCT AS A JOIN SALES AS B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.PRODUCT_ID NOT IN ( SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS)*1.0/SUM(U.UNITS)*1.0,2) AS AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID=U.PRODUCT_ID WHERE U.PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND S.PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] WITH YESTERDAY_REPORTS AS (SELECT * FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT') SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM YESTERDAY_REPORTS GROUP BY EXTRA;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(P2.X - P1.X) AS SHORTEST FROM POINT P1, POINT P2 WHERE P1.X < P2.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(*) AS REPORT_COUNT FROM (SELECT DISTINCT EXTRA, POST_ID FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT') AS T1 GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH USER1_FRIEND AS ( SELECT (CASE WHEN USER1_ID<USER2_ID THEN USER1_ID ELSE USER2_ID END) AS USER1, (CASE WHEN USER1_ID>USER2_ID THEN USER1_ID ELSE USER2_ID END) AS USER2 FROM FRIENDSHIP) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT USER2 FROM USER1_FRIEND WHERE USER1=1) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID , COUNT(*) AS COUNT_NO_TRANS FROM VISITS A WHERE A.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY A.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE,COALESCE(C.CONTACTS_CNT,0) AS CONTACTS_CNT, COALESCE(D.TRUSTED_CONTACTS_CNT,0) AS TRUSTED_CONTACTS_CNT FROM INVOICES AS A LEFT JOIN CUSTOMERS AS B ON A.USER_ID=B.CUSTOMER_ID LEFT JOIN (SELECT USER_ID, COUNT(DISTINCT CONTACT_NAME) AS CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID) AS C ON A.USER_ID=C.USER_ID LEFT JOIN (SELECT USER_ID, COUNT(DISTINCT CONTACT_NAME) AS TRUSTED_CONTACTS_CNT FROM CONTACTS A INNER JOIN CUSTOMERS B ON A.CONTACT_NAME=B.CUSTOMER_NAME GROUP BY USER_ID) AS D ON A.USER_ID= D.USER_ID ORDER BY A.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID WHERE D.NAME IS NULL ORDER BY S.DEPARTMENT_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME AS CUSTOMERS FROM CUSTOMERS C LEFT JOIN ORDERS O ON C.ID = O.CUSTOMERID WHERE O.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' ) AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND( SALARY*(1-T.TAX_RATE) , 0) AS SALARY FROM SALARIES S JOIN ( SELECT COMPANY_ID, CASE WHEN MAX(SALARY) < 1000 THEN 0 WHEN MAX(SALARY) BETWEEN 1000 AND 10000 THEN 0.24 WHEN MAX(SALARY) > 10000 THEN 0.49 END AS TAX_RATE FROM SALARIES GROUP BY COMPANY_ID ) T ON S.COMPANY_ID = T.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(E.EXPERIENCE_YEARS), 2) AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM SALES WHERE BUYER_ID IN (SELECT S.BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT EMPLOYEE.NAME AS NAME , BONUS.BONUS AS BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS.BONUS < 1000 OR BONUS.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH COMBINED AS ( SELECT C1.CUSTOMER_ID , C1.CUSTOMER_NAME , COUNT(C2.CONTACT_NAME) AS CONTACTS_CNT , SUM(CASE WHEN C2.CONTACT_EMAIL IN (SELECT DISTINCT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS AS C1 LEFT JOIN CONTACTS AS C2 ON C1.CUSTOMER_ID = C2.USER_ID GROUP BY C1.CUSTOMER_ID , C1.CUSTOMER_NAME ) SELECT I.INVOICE_ID , C1.CUSTOMER_NAME , I.PRICE , COUNT(C2.CONTACT_NAME) AS CONTACTS_CNT , SUM(CASE WHEN C2.CONTACT_EMAIL IN (SELECT DISTINCT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM INVOICES AS I INNER JOIN CUSTOMERS AS C1 ON I.USER_ID = C1.CUSTOMER_ID LEFT JOIN CONTACTS AS C2 ON C1.CUSTOMER_ID = C2.USER_ID GROUP BY I.INVOICE_ID , C1.CUSTOMER_NAME , I.PRICE ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE PRODUCT_NAME='IPHONE') AND BUYER_ID IN (SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE PRODUCT_NAME='S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT U.UNIQUE_ID, E.NAME FROM EMPLOYEES AS E LEFT OUTER JOIN EMPLOYEEUNI AS U ON U.ID = E.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH CTE AS ( SELECT CUSTOMER_ID, CASE WHEN AMOUNT IS NULL THEN 1 ELSE 0 END AS TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID) SELECT CUSTOMER_ID, SUM(TRANS) AS COUNT_NO_TRANS FROM CTE GROUP BY CUSTOMER_ID HAVING SUM(TRANS) >= 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O1 ON C.CUSTOMER_ID = O1.CUSTOMER_ID AND O1.PRODUCT_NAME = 'A' JOIN ORDERS O2 ON C.CUSTOMER_ID = O2.CUSTOMER_ID AND O2.PRODUCT_NAME = 'B' WHERE C.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS <> L2.IP_ADDRESS AND L1.LOGOUT BETWEEN L2.LOGIN AND L2.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT CUSTOMERS.NAME AS CUSTOMERS FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMERID WHERE ORDERS.CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME, B.BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE B.BONUS IS NULL OR B.BONUS < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH TEMP AS( SELECT C.CUSTOMER_ID , C.CUSTOMER_NAME , COUNT(CONTACT_EMAIL) AS CONTACTS_CNT , SUM(CASE WHEN CONTACT_EMAIL IN (SELECT DISTINCT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS AS C LEFT JOIN CONTACTS AS CONT ON C.CUSTOMER_ID = CONT.USER_ID GROUP BY C.CUSTOMER_ID, C.CUSTOMER_NAME ) SELECT I.INVOICE_ID , T.CUSTOMER_NAME , I.PRICE , T.CONTACTS_CNT , T.TRUSTED_CONTACTS_CNT FROM INVOICES AS I LEFT JOIN TEMP AS T ON T.CUSTOMER_ID = I.USER_ID ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH FINAL AS ( SELECT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEWER_ID,VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY VIEWER_ID ASC ) SELECT ID FROM FINAL GROUP BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH ELIGIBLE AS ( SELECT DISTINCT I1.PID FROM INSURANCE I1 JOIN INSURANCE I2 ON (I1.PID != I2.PID AND I1.TIV_2015 = I2.TIV_2015) ORDER BY 1 ASC ), NOT_ELIGIBLE AS ( SELECT DISTINCT E1.PID FROM INSURANCE E1 JOIN INSURANCE E2 ON (E1.PID != E2.PID AND (E1.LAT,E1.LON) = (E2.LAT,E2.LON)) ORDER BY 1 ) SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE PID IN (SELECT * FROM ELIGIBLE) AND PID NOT IN (SELECT * FROM NOT_ELIGIBLE );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT VIEWER_ID AS ID FROM (SELECT DISTINCT VIEWER_ID, COUNT(DISTINCT ARTICLE_ID) AS CNT FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE) A WHERE CNT >= 2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE,COUNT(CT.USER_ID) AS CONTACTS_CNT, SUM(CASE WHEN CT.CONTACT_NAME IN (SELECT DISTINCT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON C.CUSTOMER_ID = I.USER_ID LEFT JOIN CONTACTS CT ON I.USER_ID = CT.USER_ID GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT L.PRODUCT_ID,R.PRODUCT_NAME FROM SALES L INNER JOIN PRODUCT R ON L.PRODUCT_ID=R.PRODUCT_ID WHERE L.PRODUCT_ID NOT IN (SELECT S.PRODUCT_ID FROM SALES S WHERE S.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH A AS (SELECT DISTINCT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE') SELECT DISTINCT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT * FROM A);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(*) AS REPORT_COUNT FROM (SELECT DISTINCT POST_ID,ACTION_DATE,ACTION,EXTRA FROM ACTIONS) A WHERE ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA>3000000 OR POPULATION > 25000000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM SALES) AND PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) P;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A LEFT JOIN LOGINFO B ON A.ACCOUNT_ID = B.ACCOUNT_ID WHERE B.LOGIN > A.LOGIN AND B.LOGIN <= A.LOGOUT AND A.IP_ADDRESS <> B.IP_ADDRESS;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(ACTOR_ID) >2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT DISTINCT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT DISTINCT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION SELECT DISTINCT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH SALES_CTE AS( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' GROUP BY SELLER_ID,PRODUCT_ID,BUYER_ID,SALE_DATE,QUANTITY ) SELECT PRODUCT_ID,PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT * FROM SALES_CTE );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT S1.PRODUCT_ID, P.PRODUCT_NAME FROM (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE >'2019-03-31') ) S1 LEFT JOIN PRODUCT P ON S1.PRODUCT_ID = P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT B.* FROM ( SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') AND CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') ) A LEFT JOIN CUSTOMERS B ON A.CUSTOMER_ID = B.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID ,COUNT(V1.VISIT_ID) COUNT_NO_TRANS FROM VISITS V1 LEFT JOIN TRANSACTIONS ON V1.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT PRODUCT_ID,PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH T1 AS ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31') SELECT DISTINCT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM T1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEES LEFT JOIN EMPLOYEEUNI ON EMPLOYEEUNI.ID = EMPLOYEES.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT C.BUYER_ID FROM SALES C LEFT JOIN PRODUCT G ON C.PRODUCT_ID = G.PRODUCT_ID LEFT JOIN (SELECT BUYER_ID FROM SALES A LEFT JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE')D ON C.BUYER_ID = D.BUYER_ID WHERE D.BUYER_ID IS NULL AND G.PRODUCT_NAME = 'S8';\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT VIEW.PRODUCT_ID, VIEW.STORE, VIEW.PRICE FROM ( SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS ) AS VIEW WHERE VIEW.PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN ( SELECT A.PRODUCT_ID FROM SALES A LEFT JOIN PRODUCT B ON A.PRODUCT_ID=B.PRODUCT_ID WHERE A.SALE_DATE<'2019-01-01' OR A.SALE_DATE>'2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEES EMP LEFT JOIN EMPLOYEEUNI EMPUNI ON EMP.ID = EMPUNI.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT FIRSTNAME, LASTNAME, ADDRESS.CITY, ADDRESS.STATE FROM PERSON LEFT JOIN ADDRESS ON ADDRESS.PERSONID=PERSON.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM SALES WHERE BUYER_ID IN ( SELECT BUYER_ID FROM SALES JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'S8' ) AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM ( SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS ) AS NEWTABLE WHERE PRICE IS NOT NULL ORDER BY PRODUCT_ID, STORE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT STUDENTS.ID, STUDENTS.NAME FROM STUDENTS LEFT JOIN DEPARTMENTS ON STUDENTS.DEPARTMENT_ID = DEPARTMENTS.ID WHERE DEPARTMENTS.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT AUTHOR_ID AS ID FROM ( SELECT * FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ) AS SUBTABLE1 ORDER BY ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT(CUSTOMER_ID) FROM ORDERS WHERE PRODUCT_NAME = 'A' ) AND CUSTOMER_ID IN (SELECT DISTINCT(CUSTOMER_ID) FROM ORDERS WHERE PRODUCT_NAME = 'B' ) AND CUSTOMER_ID NOT IN (SELECT DISTINCT(CUSTOMER_ID) FROM ORDERS WHERE PRODUCT_NAME = 'C' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE (POPULATION > 25000000) OR (AREA > 3000000);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM STUDENTS WHERE STUDENTS.DEPARTMENT_ID NOT IN ( SELECT DEPARTMENTS.ID FROM STUDENTS JOIN DEPARTMENTS ON STUDENTS.DEPARTMENT_ID = DEPARTMENTS.ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH TB AS ( SELECT S.*, P.PRODUCT_NAME, P.UNIT_PRICE FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID) SELECT DISTINCT PRODUCT_ID, PRODUCT_NAME FROM TB WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM TB WHERE SALE_DATE < '2019-01-01' OR SALE_DATE >'2019-03-31' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM (SELECT CUSTOMER_ID FROM TRANSACTIONS RIGHT JOIN VISITS ON TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID WHERE TRANSACTION_ID IS NULL) AS TEMP GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT TMP.PRODUCT_ID, ROUND(SUM(TMP.TOTAL) / SUM(TMP.UNITS), 2) AS AVERAGE_PRICE FROM ( SELECT P.PRODUCT_ID, U.UNITS, U.UNITS * P.PRICE AS TOTAL FROM PRICES AS P LEFT JOIN UNITSSOLD AS U ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ) AS TMP GROUP BY TMP.PRODUCT_ID ORDER BY TMP.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT AS P LEFT JOIN SALES AS S ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY P.PRODUCT_ID, P.PRODUCT_NAME HAVING MIN(S.SALE_DATE) >='2019-01-01' AND MAX(S.SALE_DATE) <= '2019-03-31';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 LEFT JOIN LOGINFO L2 ON L1.ACCOUNT_ID=L2.ACCOUNT_ID WHERE L1.LOGIN!=L2.LOGIN AND L1.LOGOUT>=L2.LOGIN AND L1.LOGOUT<=L2.LOGOUT AND L1.IP_ADDRESS!=L2.IP_ADDRESS;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT T.ID AS PRODUCT_ID, ROUND(SUM(T.UNIT*T.PRICE)/SUM(T.UNIT), 2) AS AVERAGE_PRICE FROM (SELECT U.PRODUCT_ID AS ID, U.UNITS AS UNIT, P.PRICE AS PRICE FROM PRICES AS P, UNITSSOLD AS U WHERE (U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) AND P.PRODUCT_ID = U.PRODUCT_ID ) AS T GROUP BY T.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT T1.BUYER_ID FROM (SELECT X.BUYER_ID FROM SALES AS X WHERE X.BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES AS S WHERE S.PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'IPHONE'))) AS T1 WHERE T1.BUYER_ID IN (SELECT Y.BUYER_ID FROM SALES AS Y WHERE Y.PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'S8'));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS USING(VISIT_ID) WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH USERS AS ( SELECT DISTINCT USERS FROM ((SELECT USER2_ID USERS FROM FRIENDSHIP WHERE USER1_ID='1') UNION (SELECT USER1_ID USERS FROM FRIENDSHIP WHERE USER2_ID='1') UNION SELECT 1 FROM FRIENDSHIP)T1) SELECT DISTINCT PAGE_ID RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT USERS FROM USERS) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM (SELECT DISTINCT * FROM VIEWS) V GROUP BY VIEW_DATE,VIEWER_ID HAVING COUNT(ARTICLE_ID)>1 ORDER BY VIEWER_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] WITH ABC AS (SELECT STUDENTS.ID AS ID, STUDENTS.NAME AS NAME,STUDENTS.DEPARTMENT_ID AS ID2,DEPARTMENTS.NAME AS DP FROM STUDENTS LEFT JOIN DEPARTMENTS ON STUDENTS.DEPARTMENT_ID = DEPARTMENTS.ID) SELECT ID, NAME FROM ABC WHERE DP IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT CUSTOMERS.CUSTOMER_ID, CUSTOMERS.CUSTOMER_NAME FROM ORDERS JOIN CUSTOMERS ON ORDERS.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID WHERE CUSTOMERS.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMERS.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMERS.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS( SELECT BUYER_ID, SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS S8 , SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS IPHONE FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID GROUP BY BUYER_ID ) SELECT BUYER_ID FROM CTE WHERE S8 > 0 AND IPHONE = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE2 AS ( SELECT USER_ID ,COUNT(USER_ID) AS CONTACTS_CNT ,COUNT(EMAIL) AS TRUSTED_CONTACTS_CNT FROM CONTACTS LEFT JOIN CUSTOMERS ON CONTACTS.CONTACT_EMAIL = CUSTOMERS.EMAIL GROUP BY CONTACTS.USER_ID ) SELECT INVOICE_ID ,CUSTOMER_NAME ,PRICE ,COALESCE(CTE2.CONTACTS_CNT,0) AS CONTACTS_CNT ,COALESCE(CTE2.TRUSTED_CONTACTS_CNT,0) AS TRUSTED_CONTACTS_CNT FROM ( SELECT I.INVOICE_ID ,C.CUSTOMER_NAME ,I.PRICE ,C.CUSTOMER_ID AS USER_ID FROM INVOICES I JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID ) AS CTE LEFT JOIN CTE2 ON CTE.USER_ID = CTE2.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM DEPARTMENTS D RIGHT JOIN STUDENTS S ON D.ID = S.DEPARTMENT_ID WHERE D.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH CTE AS(SELECT VIEW_DATE, VIEWER_ID, COUNT(DISTINCT ARTICLE_ID) AS CNT FROM VIEWS GROUP BY VIEW_DATE,VIEWER_ID) SELECT DISTINCT VIEWER_ID AS ID FROM CTE WHERE CNT>1 ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS AS V1 GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, AREA, POPULATION FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] WITH A AS (SELECT PLAYER_ID,MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) SELECT A.EVENT_DATE AS INSTALL_DT, COUNT(DISTINCT A.PLAYER_ID) AS INSTALLS, ROUND(COUNT(DISTINCT A1.PLAYER_ID)/COUNT(DISTINCT A.PLAYER_ID),2) AS DAY1_RETENTION FROM A LEFT JOIN ACTIVITY A1 ON A.EVENT_DATE+1=A1.EVENT_DATE AND A.PLAYER_ID=A1.PLAYER_ID GROUP BY A.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, CASE WHEN T.MSALARY<1000 THEN S.SALARY WHEN T.MSALARY >= 1000 AND T.MSALARY <= 10000 THEN ROUND(S.SALARY *(1-.24),0) WHEN T.MSALARY > 10000 THEN ROUND(S.SALARY *(1-.49),0) END AS SALARY FROM SALARIES AS S LEFT JOIN (SELECT COMPANY_ID, MAX(SALARY) AS MSALARY FROM SALARIES GROUP BY COMPANY_ID) AS T ON S.COMPANY_ID = T.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, CUS0.CUSTOMER_NAME, I.PRICE, COUNT(C.CONTACT_NAME) AS CONTACTS_CNT, COUNT(CUS.CUSTOMER_NAME) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS CUS0 ON I.USER_ID = CUS0.CUSTOMER_ID LEFT JOIN CONTACTS C ON I.USER_ID = C.USER_ID LEFT JOIN CUSTOMERS CUS ON C.CONTACT_EMAIL = CUS.EMAIL GROUP BY I.INVOICE_ID, CUS0.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TABLE1 AS (SELECT S.BUYER_ID, SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS S8, SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS IPHONE FROM PRODUCT P JOIN SALES S USING (PRODUCT_ID) GROUP BY S.BUYER_ID ) SELECT BUYER_ID FROM TABLE1 WHERE S8 >0 AND IPHONE = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT (CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE 0 END) AS USER_ID FROM FRIENDSHIP) A JOIN LIKES L ON A.USER_ID=L.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES AS L WHERE USER_ID IN (SELECT CASE WHEN USER1_ID = 1 THEN USER2_ID WHEN USER2_ID = 1 THEN USER1_ID END FROM FRIENDSHIP WHERE USER1_ID = 1 OR USER2_ID = 1 ) AND PAGE_ID NOT IN (SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID,MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID;\n[SQL_2] SELECT MIN(EVENT_DATE) AS FIRST_LOGIN, PLAYER_ID FROM ACTIVITY GROUP BY PLAYER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(UNITS*PRICE)/SUM(UNITS),2) AS AVERAGE_PRICE FROM PRICES P INNER JOIN UNITSSOLD U ON P.PRODUCT_ID=U.PRODUCT_ID AND PURCHASE_DATE<=END_DATE AND PURCHASE_DATE>=START_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT A.BUYER_ID FROM (SELECT DISTINCT BUYER_ID FROM SALES WHERE PRODUCT_ID=(SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME='S8'))A LEFT JOIN (SELECT DISTINCT BUYER_ID FROM SALES WHERE PRODUCT_ID=(SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME='IPHONE')) B ON A.BUYER_ID=B.BUYER_ID WHERE B.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT R.ID, R.NAME FROM (SELECT S.ID,S.NAME,D.ID AS DEPT FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID) R WHERE DEPT IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME IN (SELECT PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_NAME = 'S8') AND S.BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'IPHONE'));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID ,COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT TRANSACTIONS.VISIT_ID FROM TRANSACTIONS LEFT JOIN VISITS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID ) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM ( SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS ) AS A WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH V2015 AS ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>=2), GEO AS ( SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)>=2) SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM V2015) AND (LAT,LON) NOT IN (SELECT LAT,LON FROM GEO);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO AS L1, LOGINFO AS L2 WHERE L1.ACCOUNT_ID = L2.ACCOUNT_ID AND (L1.LOGIN <= L2.LOGIN AND L1.LOGOUT >= L2.LOGIN) AND L1.IP_ADDRESS != L2.IP_ADDRESS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE >= '2019-04-01' OR SALE_DATE < '2019-01-01');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INV.INVOICE_ID, MAX(CU.CUSTOMER_NAME) AS CUSTOMER_NAME, MAX(INV.PRICE) AS PRICE, COUNT(CO.CONTACT_EMAIL) AS CONTACTS_CNT, COUNT(CTS.CUSTOMER_ID) AS TRUSTED_CONTACTS_CNT FROM INVOICES INV JOIN CUSTOMERS CU ON INV.USER_ID = CU.CUSTOMER_ID LEFT JOIN CONTACTS CO ON CU.CUSTOMER_ID = CO.USER_ID LEFT JOIN CUSTOMERS CTS ON CO.CONTACT_EMAIL = CTS.EMAIL GROUP BY INV.INVOICE_ID ORDER BY INV.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT DISTINCT S.ID ,S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID =D.ID WHERE D.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT T.CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS T LEFT JOIN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') A ON T.CUSTOMER_ID = A.CUSTOMER_ID LEFT JOIN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') B ON T.CUSTOMER_ID = B.CUSTOMER_ID LEFT JOIN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') C ON T.CUSTOMER_ID = C.CUSTOMER_ID WHERE A.CUSTOMER_ID IS NOT NULL AND B.CUSTOMER_ID IS NOT NULL AND C.CUSTOMER_ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND((CASE WHEN A.MAXSALARY < 1000 THEN S.SALARY WHEN A.MAXSALARY BETWEEN 1000 AND 10000 THEN S.SALARY - (24/100)*S.SALARY WHEN A.MAXSALARY > 10000 THEN S.SALARY-(49/100)*S.SALARY END),0) AS SALARY FROM SALARIES S LEFT JOIN (SELECT COMPANY_ID, MAX(SALARY) AS MAXSALARY FROM SALARIES GROUP BY COMPANY_ID) AS A ON A.COMPANY_ID = S.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE (BONUS < 1000) OR (BONUS IS NULL);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT(VIEWER_ID) AS ID FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT(ARTICLE_ID)) > 1 ORDER BY VIEWER_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION / 60 < 5 UNION SELECT '[5-10>' AS BIN, COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION / 60 >= 5 AND DURATION / 60 < 10 UNION SELECT '[10-15>' AS BIN, COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION / 60 >= 10 AND DURATION / 60 < 15 UNION SELECT '15 OR MORE' AS BIN, COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION / 60 >= 15;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND(SUM(E.EXPERIENCE_YEARS)/COUNT(P.PROJECT_ID),2) AS AVERAGE_YEARS FROM PROJECT P LEFT JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(U.UNITS*P.PRICE) / SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM PRICES P INNER JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID ORDER BY P.PRODUCT_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P1.PRODUCT_ID, ROUND(SUM(P1.PRICE*S1.UNITS)/(SUM(S1.UNITS)),2) AS AVERAGE_PRICE FROM PRICES P1 LEFT JOIN UNITSSOLD S1 ON P1.PRODUCT_ID=S1.PRODUCT_ID AND S1.PURCHASE_DATE BETWEEN P1.START_DATE AND P1.END_DATE GROUP BY P1.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRODUCT_ID, ROUND(SUM(PRICE * UNITS) / SUM(UNITS), 2) AS AVERAGE_PRICE FROM ( SELECT U.PRODUCT_ID, U.PURCHASE_DATE, U.UNITS, PRICES.PRICE FROM UNITSSOLD U LEFT JOIN PRICES ON U.PRODUCT_ID = PRICES.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN PRICES.START_DATE AND PRICES.END_DATE ) AS T GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S1 JOIN PRODUCT P1 ON S1.PRODUCT_ID = P1.PRODUCT_ID WHERE P1.PRODUCT_NAME='S8' AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS A ON A.CUSTOMER_ID = C.CUSTOMER_ID AND A.PRODUCT_NAME = 'A' JOIN ORDERS B ON B.CUSTOMER_ID = C.CUSTOMER_ID AND B.PRODUCT_NAME = 'B' LEFT OUTER JOIN ORDERS O ON O.CUSTOMER_ID = C.CUSTOMER_ID AND O.PRODUCT_NAME = 'C' WHERE O.ORDER_ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(UNITS*PRICE)/SUM(UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD U JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE >= P.START_DATE AND U.PURCHASE_DATE <= P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM,COUNT(*) FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*)=1) AS NN;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(DISTINCT ID) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A RIGHT JOIN (SELECT PLAYER_ID,MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) B ON A.PLAYER_ID = B.PLAYER_ID AND A.EVENT_DATE = B.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID AS CUSTOMER_ID ,CUSTOMER_NAME FROM( SELECT CUSTOMER_ID ,SUM(CASE WHEN PRODUCT_NAME = 'A' OR PRODUCT_NAME = 'B' THEN 1 ELSE 0 END) ABCNT ,COALESCE(SUM(CASE WHEN PRODUCT_NAME = 'C' THEN 1 END),0) AS CCNT FROM ORDERS ORDERS GROUP BY CUSTOMER_ID ) A JOIN CUSTOMERS CUSTOMERS ON A.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID WHERE ABCNT = 2 AND CCNT = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT A.PRODUCT_ID, B.PRODUCT_NAME FROM SALES AS A JOIN PRODUCT AS B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE A.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01') AND A.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT(P1.EMAIL) AS EMAIL FROM PERSON P1 INNER JOIN PERSON P2 ON P1.EMAIL = P2.EMAIL AND P1.ID <> P2.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME AS CUSTOMERS FROM CUSTOMERS AS C LEFT JOIN ORDERS AS O USING(ID) WHERE C.ID NOT IN ( SELECT DISTINCT CUSTOMERID FROM ORDERS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM ( SELECT VIEWER_ID, VIEW_DATE, COUNT(DISTINCT ARTICLE_ID) AS VIEWS FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE ) T WHERE VIEWS > 1 ORDER BY VIEWER_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM (SELECT DISTINCT * FROM COURSES) C GROUP BY CLASS HAVING COUNT(CLASS) >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME ='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN ( SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT AD.ACTOR_ID,AD.DIRECTOR_ID FROM ACTORDIRECTOR AD GROUP BY AD.DIRECTOR_ID,ACTOR_ID HAVING COUNT(AD.ACTOR_ID)>=3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CUST_CNT AS( SELECT USER_ID, COUNT(DISTINCT CONTACT_NAME) AS CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID ), TRUSTED AS ( SELECT CO.USER_ID, COUNT(CO.CONTACT_EMAIL) AS TRUSTED_CONTACTS_CNT FROM CONTACTS CO JOIN CUSTOMERS CU ON CO.CONTACT_EMAIL = CU.EMAIL GROUP BY CO.USER_ID ) SELECT I.INVOICE_ID, CU.CUSTOMER_NAME, PRICE, COALESCE(CONTACTS_CNT,0) CONTACTS_CNT, COALESCE (TRUSTED_CONTACTS_CNT, 0) TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS CU ON I.USER_ID = CU.CUSTOMER_ID LEFT JOIN CUST_CNT CC ON I.USER_ID = CC.USER_ID LEFT JOIN TRUSTED T ON I.USER_ID = T.USER_ID ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT A.COMPANY_ID, A.EMPLOYEE_ID, A.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN A.SALARY*0.76 WHEN X.MAX_SAL > 10000 THEN A.SALARY*0.51 ELSE A.SALARY END) AS SALARY FROM SALARIES AS A JOIN (SELECT COMPANY_ID, MAX(SALARY) AS MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) AS X ON A.COMPANY_ID=X.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT T.ACTOR_ID, T.DIRECTOR_ID FROM ACTORDIRECTOR T GROUP BY T.ACTOR_ID, T.DIRECTOR_ID HAVING COUNT(1)>=3;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V2.VIEWER_ID AS ID FROM VIEWS V1,VIEWS V2 WHERE V1.AUTHOR_ID=V2.VIEWER_ID AND V1.AUTHOR_ID=V2.AUTHOR_ID ORDER BY ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COUNT(U.USER_ID) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS U ON C.CUSTOMER_ID = U.USER_ID GROUP BY INVOICE_ID, CUSTOMER_NAME, PRICE ORDER BY 1 ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CONTS AS ( SELECT USER_ID, COUNT(1) CONTACTS_CNT, SUM( CASE WHEN CUSTOMER_NAME IS NULL THEN 0 ELSE 1 END ) TRUSTED_CONTACTS_CNT FROM CONTACTS CON LEFT JOIN CUSTOMERS CUS ON CON.CONTACT_EMAIL = CUS.EMAIL GROUP BY USER_ID ) SELECT INVOICE_ID, CUSTOMER_NAME, I.PRICE, CASE WHEN CONTACTS_CNT IS NULL THEN 0 ELSE CONTACTS_CNT END CONTACTS_CNT, CASE WHEN TRUSTED_CONTACTS_CNT IS NULL THEN 0 ELSE TRUSTED_CONTACTS_CNT END TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CONTS C ON I.USER_ID = C.USER_ID INNER JOIN CUSTOMERS CU ON I.USER_ID = CU.CUSTOMER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(PT1.X - PT2.X) AS SHORTEST FROM POINT PT1 JOIN POINT PT2 ON PT1.X != PT2.X ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM (SELECT CLASS, COUNT(STUDENT) AS NUM FROM COURSES GROUP BY CLASS) AS TEMP_TABLE WHERE NUM > 4;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*S.UNITS)/ SUM(S.UNITS) ,2) AS AVERAGE_PRICE FROM PRICES P INNER JOIN UNITSSOLD S ON S.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE AND S.PRODUCT_ID = P.PRODUCT_ID GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM INSURANCE WHERE (TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(PID)>1)) AND ((LAT, LON) NOT IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(PID)>1 ) );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, CASE WHEN MX < 1000 THEN S.SALARY WHEN MX <= 10000 THEN ROUND(S.SALARY*0.76) ELSE ROUND(S.SALARY*0.51) END AS SALARY FROM SALARIES S LEFT JOIN (SELECT COMPANY_ID, MAX(SALARY) AS MX FROM SALARIES GROUP BY COMPANY_ID) T ON S.COMPANY_ID = T.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT AUTHOR_ID ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID GROUP BY AUTHOR_ID HAVING COUNT(ARTICLE_ID)>=1 ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*S.UNITS) / SUM(S.UNITS),2) AS AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.PURCHASE_DATE >= P.START_DATE AND S.PURCHASE_DATE <= P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH SOLD_OTHER AS (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' ) SELECT DISTINCT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SOLD_OTHER);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND EXTRA IS NOT NULL AND ACTION_DATE = (SELECT MAX(ACTION_DATE) FROM ACTIONS) GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A, (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) FIRST_LOGIN WHERE A.PLAYER_ID = FIRST_LOGIN.PLAYER_ID AND A.EVENT_DATE = FIRST_LOGIN.FIRST_LOGIN;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE_B AS ( SELECT S.BUYER_ID,P.PRODUCT_ID,P.PRODUCT_NAME FROM PRODUCT P LEFT JOIN SALES S ON S.PRODUCT_ID=P.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM CTE_B WHERE PRODUCT_NAME='S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE_B WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM ( SELECT DISTINCT ARTICLE_ID, VIEWER_ID, VIEW_DATE FROM VIEWS ) T GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(*) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] WITH DUPLICATES AS ( SELECT EMAIL, COUNT(*) FROM PERSON GROUP BY EMAIL HAVING COUNT(*) > 1 ) SELECT EMAIL FROM DUPLICATES;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY 1 ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH T1 AS ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B' AND CUSTOMER_ID IN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') ), T2 AS ( SELECT DISTINCT T1.CUSTOMER_ID, PRODUCT_NAME FROM T1 JOIN ORDERS ON ORDERS.CUSTOMER_ID = T1.CUSTOMER_ID AND PRODUCT_NAME = 'C' ) SELECT T1.CUSTOMER_ID , CUSTOMER_NAME FROM T1 JOIN CUSTOMERS ON T1.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID WHERE T1.CUSTOMER_ID NOT IN ( SELECT CUSTOMER_ID FROM T2) ORDER BY T1.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] SELECT C1.NAME FROM CUSTOMER AS C1 WHERE C1.REFEREE_ID <> 2 OR C1.REFEREE_ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] WITH CTE1 AS ( SELECT COUNT(EMAIL) AS COUNT_1 , EMAIL FROM PERSON GROUP BY EMAIL) SELECT EMAIL FROM CTE1 WHERE COUNT_1 != 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CT_TAX AS (SELECT CASE WHEN MAX(SALARY) < 1000 THEN 0 WHEN MAX(SALARY)<10000 THEN 24 ELSE 49 END AS TAX_RATE, COMPANY_ID FROM SALARIES GROUP BY COMPANY_ID) SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND((S.SALARY- (S.SALARY*C.TAX_RATE/100))) AS SALARY FROM SALARIES S, CT_TAX C WHERE S.COMPANY_ID = C.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT P.EMAIL AS EMAIL FROM PERSON P JOIN PERSON Q ON P.EMAIL = Q.EMAIL WHERE P.ID != Q.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE AS(SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID=1 UNION SELECT USER1_ID AS USER2_ID FROM FRIENDSHIP WHERE USER2_ID=1) SELECT DISTINCT LIKES.PAGE_ID AS RECOMMENDED_PAGE FROM CTE JOIN LIKES ON USER_ID=USER2_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(ID) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(CASE WHEN DURATION/60 < 5 THEN SESSION_ID END ) AS TOTAL FROM SESSIONS UNION SELECT '[5-10>' AS BIN, COUNT(CASE WHEN DURATION/60>=5 AND DURATION/60<10 THEN SESSION_ID END ) AS TOTAL FROM SESSIONS UNION SELECT '[10-15>' AS BIN, COUNT(CASE WHEN DURATION/60>=10 AND DURATION/60<15 THEN SESSION_ID END ) AS TOTAL FROM SESSIONS UNION SELECT '15 OR MORE' AS BIN, COUNT(CASE WHEN DURATION/60>=15 THEN SESSION_ID END ) AS TOTAL FROM SESSIONS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] WITH WLS AS( SELECT S.ID,S.NAME,D.NAME AS DPT_NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID ) SELECT ID,NAME FROM WLS WHERE DPT_NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] WITH DT AS ( SELECT A.NAME, B.BONUS FROM EMPLOYEE AS A LEFT JOIN BONUS AS B ON A.EMPID = B.EMPID ) SELECT * FROM DT WHERE BONUS IS NULL OR BONUS < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM ((SELECT PRODUCT_ID, CASE WHEN STORE1 IS NOT NULL THEN STORE1 END AS STORE, CASE WHEN STORE1 IS NOT NULL THEN STORE1 END AS PRICE FROM PRODUCTS P1) UNION ALL (SELECT PRODUCT_ID, CASE WHEN STORE2 IS NOT NULL THEN STORE2 END AS STORE, CASE WHEN STORE2 IS NOT NULL THEN STORE2 END AS PRICE FROM PRODUCTS) UNION ALL (SELECT PRODUCT_ID, CASE WHEN STORE3 IS NOT NULL THEN STORE3 END AS STORE, CASE WHEN STORE3 IS NOT NULL THEN STORE3 END AS PRICE FROM PRODUCTS) ) A WHERE A.PRICE IS NOT NULL ORDER BY A.PRODUCT_ID, A.STORE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT T.ID, T.NAME FROM STUDENTS T WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS AS TSTORE_1 WHERE STORE1 IS NOT NULL UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS AS TSTORE_2 WHERE STORE2 IS NOT NULL UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS AS TSTORE_3 WHERE STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND(AVG(E.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM EMPLOYEE E JOIN PROJECT P ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH TEMP AS (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' )) SELECT DISTINCT TEMP.PRODUCT_ID, PRODUCT_NAME FROM TEMP JOIN PRODUCT PRO ON PRO.PRODUCT_ID=TEMP.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID , ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD U JOIN PRICES P ON U.PRODUCT_ID=P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT CASE WHEN A.OCCUR = 1 THEN A.NUM ELSE NULL END AS NUM FROM ( SELECT NUM, COUNT(NUM) AS OCCUR FROM MYNUMBERS GROUP BY NUM ORDER BY OCCUR ASC, NUM DESC LIMIT 1 ) A;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT P.PRODUCT_ID FROM PRODUCT P LEFT JOIN SALES S ON S.PRODUCT_ID=P.PRODUCT_ID WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID,MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID;\n[SQL_2] SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID HAVING COUNT(*) > 0;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS ( SELECT * FROM PRODUCT NATURAL JOIN SALES) SELECT DISTINCT BUYER_ID FROM TEMP WHERE PRODUCT_NAME='S8' AND BUYER_ID NOT IN( SELECT DISTINCT BUYER_ID FROM TEMP WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID, CU.CUSTOMER_NAME FROM (SELECT O1.CUSTOMER_ID, O3.PRODUCT_NAME FROM ORDERS O1 LEFT JOIN ORDERS O2 ON O1.CUSTOMER_ID = O2.CUSTOMER_ID LEFT JOIN (SELECT CUSTOMER_ID, PRODUCT_NAME FROM ORDERS WHERE PRODUCT_NAME = 'C') O3 ON O3.CUSTOMER_ID = O1.CUSTOMER_ID WHERE O1.PRODUCT_NAME = 'A' AND O2.PRODUCT_NAME = 'B' ) C LEFT JOIN CUSTOMERS CU ON CU.CUSTOMER_ID = C.CUSTOMER_ID WHERE C.PRODUCT_NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT A.PRODUCT_ID, ROUND(SUM(A.PRICE*B.UNITS)/ SUM(B.UNITS),2) AS AVERAGE_PRICE FROM PRICES A LEFT JOIN UNITSSOLD B ON A.PRODUCT_ID = B.PRODUCT_ID AND (B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH TEMP AS (SELECT VISITS.VISIT_ID, TRANSACTIONS.TRANSACTION_ID FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID), NULLEDTEMP AS (SELECT * FROM TEMP WHERE TEMP.TRANSACTION_ID IS NULL) SELECT CUSTOMER_ID,COUNT(*) AS COUNT_NO_TRANS FROM VISITS INNER JOIN NULLEDTEMP ON NULLEDTEMP.VISIT_ID=VISITS.VISIT_ID GROUP BY CUSTOMER_ID ORDER BY COUNT(*) DESC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT CASE WHEN SUM(NUM_COUNT) = 0 THEN NULL ELSE MAX(NUM_COUNT) END AS NUM FROM (SELECT CASE WHEN COUNT(NUM) = 1 THEN NUM ELSE 0 END AS NUM_COUNT FROM MYNUMBERS GROUP BY NUM) AS SUBQ;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM ( SELECT BUYER_ID, SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS S8, SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS IPHONE FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY BUYER_ID ) X WHERE S8 > 0 AND IPHONE = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A JOIN LOGINFO B ON A. ACCOUNT_ID = B. ACCOUNT_ID AND A.IP_ADDRESS != B.IP_ADDRESS WHERE NOT(A.LOGOUT < B.LOGIN OR A.LOGIN > B.LOGOUT);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT NAME, UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EU ON EU.ID = E.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH TEMP AS( SELECT U.PRODUCT_ID PRODUCT_ID, UNITS, PRICE, UNITS * PRICE TOTAL FROM UNITSSOLD U LEFT JOIN PRICES P ON P.PRODUCT_ID = U.PRODUCT_ID AND PURCHASE_DATE >= START_DATE AND PURCHASE_DATE <= END_DATE ) SELECT PRODUCT_ID, ROUND(SUM(TOTAL)/SUM(UNITS), 2) AVERAGE_PRICE FROM TEMP GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID AS CUSTOMER_ID, CUSTOMER_NAME CUSTOMER_NAME FROM (SELECT A.CUSTOMER_ID FROM (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='A' GROUP BY CUSTOMER_ID ) A INNER JOIN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='B' GROUP BY CUSTOMER_ID ) B ON A.CUSTOMER_ID=B.CUSTOMER_ID INNER JOIN (SELECT CC.CUSTOMER_ID FROM (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='C' GROUP BY CUSTOMER_ID) C RIGHT JOIN CUSTOMERS CC ON C.CUSTOMER_ID= CC.CUSTOMER_ID WHERE C.CUSTOMER_ID IS NULL) X ON B.CUSTOMER_ID=X.CUSTOMER_ID) X INNER JOIN CUSTOMERS C ON X.CUSTOMER_ID=C.CUSTOMER_ID ORDER BY C.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT A.PRODUCT_ID, ROUND(SUM(UNITS*PRICE)/SUM(UNITS),2) AVERAGE_PRICE FROM UNITSSOLD A LEFT JOIN PRICES B ON A.PRODUCT_ID=B.PRODUCT_ID WHERE PURCHASE_DATE >= START_DATE AND PURCHASE_DATE <= END_DATE GROUP BY A.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(VISIT_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT T.VISIT_ID FROM TRANSACTIONS T) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT DISTINCT P.PRODUCT_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH T1 AS( SELECT COMPANY_ID, CASE WHEN MAX(SALARY) < 1000 THEN 0 WHEN MAX(SALARY) >= 1000 AND MAX(SALARY) <= 10000 THEN 0.24 ELSE 0.49 END AS RATE FROM SALARIES GROUP BY COMPANY_ID ) SELECT T2.COMPANY_ID, T2.EMPLOYEE_ID, T2.EMPLOYEE_NAME, ROUND(T2.SALARY-T1.RATE*T2.SALARY,0) AS SALARY FROM SALARIES T2 LEFT JOIN T1 ON T2.COMPANY_ID = T1.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS LEFT JOIN ORDERS ON (CUSTOMERS.ID = ORDERS.CUSTOMERID) WHERE CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM (SELECT S.ID AS ID, S.NAME AS NAME, D.NAME AS DEPARTMENT FROM STUDENTS AS S LEFT JOIN DEPARTMENTS AS D ON S.DEPARTMENT_ID = D.ID) AS T WHERE T.DEPARTMENT IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH A AS( SELECT S.BUYER_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID) SELECT BUYER_ID FROM A GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME='S8' THEN 1 ELSE 0 END)>=1 AND SUM(CASE WHEN PRODUCT_NAME='IPHONE' THEN 1 ELSE 0 END)=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE * U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD AS U LEFT JOIN PRICES AS P ON U.PRODUCT_ID = P.PRODUCT_ID AND P.START_DATE <= U.PURCHASE_DATE AND P.END_DATE >= U.PURCHASE_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID,ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD U JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 CROSS JOIN LOGINFO L2 WHERE L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS <> L2.IP_ADDRESS AND L2.LOGIN <= L1.LOGOUT AND L2.LOGOUT >= L1.LOGIN;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT USER2_ID FROM (SELECT USER1_ID, USER2_ID FROM FRIENDSHIP UNION SELECT USER2_ID, USER1_ID FROM FRIENDSHIP ) AS T1 WHERE USER1_ID = 1) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT P.FIRSTNAME , P.LASTNAME , CITY , STATE FROM PERSON P LEFT JOIN ADDRESS A ON P.PERSONID = A.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME, B.BONUS FROM EMPLOYEE AS E LEFT JOIN BONUS AS B ON E.EMPID = B.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID,A.DEVICE_ID FROM ACTIVITY A JOIN ( SELECT PLAYER_ID,MIN(EVENT_DATE) AS M_DATE FROM ACTIVITY GROUP BY PLAYER_ID) B ON A.PLAYER_ID=B.PLAYER_ID AND A.EVENT_DATE=B.M_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT DISTINCT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT A.EMAIL AS EMAIL FROM (SELECT EMAIL, COUNT(ID) AS COUNTT FROM PERSON GROUP BY EMAIL) AS A WHERE A.COUNTT > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT T1.PRODUCT_ID,T2.PRODUCT_NAME FROM SALES T1 JOIN PRODUCT T2 ON T1.PRODUCT_ID=T2.PRODUCT_ID WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND T1.PRODUCT_ID NOT IN ( SELECT DISTINCT T1.PRODUCT_ID FROM SALES T1 JOIN PRODUCT T2 ON T1.PRODUCT_ID=T2.PRODUCT_ID WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(A.X - B.X)) AS SHORTEST FROM (SELECT DISTINCT X FROM POINT) A JOIN (SELECT DISTINCT X FROM POINT) B ON A.X != B.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT DISTINCT P.PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2)AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT WHERE L1.IP_ADDRESS != L2.IP_ADDRESS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT AS P LEFT JOIN EMPLOYEE AS E ON P.EMPLOYEE_ID= E.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID, CUSTOMER_NAME FROM ORDERS O LEFT JOIN CUSTOMERS C ON O.CUSTOMER_ID = C.CUSTOMER_ID WHERE PRODUCT_NAME = 'A' AND C.CUSTOMER_ID IN ( SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B' ) AND C.CUSTOMER_ID NOT IN ( SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT A.AUTHOR_ID AS ID FROM VIEWS AS A INNER JOIN VIEWS AS B ON A.ARTICLE_ID=B.ARTICLE_ID AND A.AUTHOR_ID=B.VIEWER_ID ORDER BY A.AUTHOR_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS (SELECT S.*, PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM TEMP WHERE BUYER_ID IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT USER2_ID AS OU FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER1_ID AS OU FROM FRIENDSHIP WHERE USER2_ID = 1) F JOIN LIKES ON USER_ID = F.OU WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING (COUNT(STUDENT)>=5);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH MX AS( SELECT DISTINCT COMPANY_ID, MAX(SALARY) AS MX FROM SALARIES GROUP BY COMPANY_ID), TAX AS( SELECT COMPANY_ID, (CASE WHEN MX < 1000 THEN 1 WHEN MX >= 1000 AND MX<= 10000 THEN 0.76 WHEN MX >10000 THEN 0.51 END )AS TAX FROM MX ) SELECT S.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(TAX * S.SALARY,0) AS SALARY FROM SALARIES S JOIN TAX T ON S.COMPANY_ID = T.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(PRICE * UNITS) / SUM(UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND (PURCHASE_DATE BETWEEN START_DATE AND END_DATE) GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT T.CUSTOMER_ID, COUNT(T.VISIT_ID) AS COUNT_NO_TRANS FROM (SELECT * FROM VISITS LEFT JOIN TRANSACTIONS USING(VISIT_ID))AS T WHERE T.AMOUNT IS NULL GROUP BY T.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME, B.BONUS FROM BONUS B RIGHT JOIN EMPLOYEE E ON E.EMPID=B.EMPID WHERE B.BONUS < 1000 OR B.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT DISTINCT P.PRODUCT_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID=S.PRODUCT_ID WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE EMPLOYEE.EMPID NOT IN (SELECT EMPID FROM BONUS) OR BONUS.BONUS < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID,PRODUCT_NAME FROM PRODUCT P WHERE PRODUCT_ID NOT IN (SELECT P.PRODUCT_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE SALE_DATE>'2019-03-31' OR SALE_DATE<'2019-01-01' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' GROUP BY PRODUCT_ID);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT A.ID,A.NAME FROM STUDENTS AS A LEFT JOIN DEPARTMENTS AS B ON A.DEPARTMENT_ID = B.ID WHERE B.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS STORE FROM PRODUCTS WHERE STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID , ROUND(SUM(U.UNITS*P.PRICE)/SUM(U.UNITS),2) AVERAGE_PRICE FROM UNITSSOLD U JOIN PRICES P ON U.PRODUCT_ID=P.PRODUCT_ID WHERE P.START_DATE <= U.PURCHASE_DATE AND P.END_DATE >= U.PURCHASE_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE AS (SELECT COMPANY_ID, CASE WHEN MAX(SALARY) < 1000 THEN 0 WHEN MAX(SALARY) BETWEEN 1000 AND 10000 THEN 24 ELSE 49 END AS TAX_PERC FROM SALARIES GROUP BY COMPANY_ID) SELECT S.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND((S.SALARY - (C.TAX_PERC/100)*(S.SALARY)),0) AS SALARY FROM SALARIES S INNER JOIN CTE C ON S.COMPANY_ID = C.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND S.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID, COUNT(VISITS.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISITS.VISIT_ID NOT IN ( SELECT VISIT_ID FROM TRANSACTIONS ) GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT T.INVOICE_ID, T.CUSTOMER_NAME, T.PRICE, COUNT(CO.CONTACT_EMAIL) CONTACTS_CNT, COUNT(C2.CUSTOMER_ID) TRUSTED_CONTACTS_CNT FROM (SELECT I.INVOICE_ID, C.CUSTOMER_NAME, C.CUSTOMER_ID, I.PRICE FROM INVOICES I, CUSTOMERS C WHERE I.USER_ID = C.CUSTOMER_ID) T LEFT OUTER JOIN CONTACTS CO ON T.CUSTOMER_ID = CO.USER_ID LEFT OUTER JOIN CUSTOMERS C2 ON CO.CONTACT_EMAIL = C2.EMAIL GROUP BY T.INVOICE_ID, T.CUSTOMER_NAME, T.PRICE ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, CAST(SUM(UNITS*PRICE)/SUM(UNITS) AS DECIMAL(36,2)) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T USING (VISIT_ID) WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, SUM(CASE WHEN DURATION/60 >= 0 AND DURATION/60 < 5 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS UNION SELECT '[5-10>' AS BIN, SUM(CASE WHEN DURATION/60 >= 5 AND DURATION/60 < 10 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS UNION SELECT '[10-15>' AS BIN, SUM(CASE WHEN DURATION/60 >= 10 AND DURATION/60 < 15 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS UNION SELECT '15 OR MORE' AS BIN, SUM(CASE WHEN DURATION/60 >= 15 THEN 1 ELSE 0 END) TOTAL FROM SESSIONS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(P1.X-P2.X) AS SHORTEST FROM POINT P1,POINT P2 WHERE P1.X!=P2.X ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT SALES.BUYER_ID FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT.PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT DISTINCT SALES.BUYER_ID FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] WITH TEMP AS ( SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1 ) SELECT MAX(NUM) AS NUM FROM TEMP;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] (SELECT '[0-5>' AS BIN , SUM(CASE WHEN DURATION/60<5 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION (SELECT '[5-10>' AS BIN , SUM(CASE WHEN DURATION/60>=5 AND DURATION/60<10 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION (SELECT '[10-15>' AS BIN , SUM(CASE WHEN DURATION/60>=10 AND DURATION/60<15 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION (SELECT '15 OR MORE AS BIN', SUM(CASE WHEN DURATION/60>=15 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID RECOMMENDED_PAGE FROM LIKES WHERE PAGE_ID NOT IN ( SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID = 1 ) AND PAGE_ID IN ( SELECT PAGE_ID FROM LIKES JOIN FRIENDSHIP ON (USER1_ID = 1 AND USER2_ID = USER_ID) OR (USER2_ID = 1 AND USER1_ID = USER_ID) );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID , COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN ( SELECT T.VISIT_ID FROM TRANSACTIONS T ) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT DISTINCT F.USER1_ID FROM FRIENDSHIP F WHERE F.USER2_ID=1 UNION SELECT DISTINCT F1.USER2_ID FROM FRIENDSHIP F1 WHERE F1.USER1_ID=1) AS A JOIN LIKES L ON A.USER1_ID=L.USER_ID AND L.PAGE_ID NOT IN (SELECT L1.PAGE_ID FROM LIKES L1 WHERE L1.USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.BUYER_ID IN (SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8') AND S.BUYER_ID NOT IN(SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S1.COMPANY_ID, S1.EMPLOYEE_ID, S1.EMPLOYEE_NAME, CASE WHEN S2.MAX_SALARY < 1000 THEN ROUND(S1.SALARY) WHEN S2.MAX_SALARY > 10000 THEN ROUND(S1.SALARY * 0.51) ELSE ROUND(S1.SALARY * 0.76) END AS SALARY FROM SALARIES S1 LEFT JOIN (SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID) S2 ON S1.COMPANY_ID = S2.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID=T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT ORDERS.CUSTOMER_ID, CUSTOMER_NAME FROM ORDERS LEFT JOIN CUSTOMERS ON CUSTOMERS.CUSTOMER_ID = ORDERS.CUSTOMER_ID WHERE PRODUCT_NAME = 'A' AND ORDERS.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND ORDERS.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM)AS NUM FROM (SELECT * FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM)=1) AS M;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE (P.PRODUCT_ID, P.PRODUCT_NAME) NOT IN ( SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I1.INVOICE_ID, C1.CUSTOMER_NAME AS CUSTOMER_NAME, I1.PRICE, CASE WHEN B.CONTACTS_CNT IS NULL THEN 0 ELSE B.CONTACTS_CNT END AS CONTACTS_CNT, CASE WHEN B.TRUSTED_CONTACTS_CNT IS NULL THEN 0 ELSE B.TRUSTED_CONTACTS_CNT END AS TRUSTED_CONTACTS_CNT FROM INVOICES I1 LEFT JOIN CUSTOMERS C1 ON I1.USER_ID = C1.CUSTOMER_ID LEFT JOIN( SELECT USER_ID, COUNT(1) AS CONTACTS_CNT, SUM(CASE WHEN CUSTOMER_ID IS NOT NULL THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM( SELECT C2.USER_ID, C3.CUSTOMER_ID FROM CONTACTS C2 LEFT JOIN CUSTOMERS C3 ON C2.CONTACT_NAME = C3.CUSTOMER_NAME AND C2.CONTACT_EMAIL = C3.EMAIL ) A GROUP BY USER_ID ) B ON I1.USER_ID = B.USER_ID ORDER BY I1.INVOICE_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_ID NOT IN (SELECT P.PRODUCT_ID FROM PRODUCT P JOIN SALES S ON S.PRODUCT_ID = P.PRODUCT_ID WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31') ORDER BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EMP.NAME,EMPUNI.UNIQUE_ID FROM EMPLOYEES EMP LEFT JOIN EMPLOYEEUNI EMPUNI ON EMPUNI.ID = EMP.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT L.UNIQUE_ID,R.NAME FROM EMPLOYEEUNI L RIGHT JOIN EMPLOYEES R ON L.ID = R.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.AUTHOR_ID AS ID FROM VIEWS AS V1, VIEWS AS V2 WHERE V1.AUTHOR_ID = V2.VIEWER_ID AND V1.ARTICLE_ID = V2.ARTICLE_ID ORDER BY V1.AUTHOR_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE * U.UNITS)/SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE>= P.START_DATE AND U.PURCHASE_DATE<= P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH PRICED_UNITS AS ( SELECT U.PRODUCT_ID, U.UNITS, 1.0*P.PRICE*U.UNITS AS TOTAL_PRICE FROM UNITSSOLD U INNER JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ) SELECT PRODUCT_ID, ROUND(SUM(TOTAL_PRICE)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM PRICED_UNITS GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY BUYER_ID HAVING MAX(PRODUCT_NAME = 'S8') AND MAX(PRODUCT_NAME = 'IPHONE') = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM PRODUCT P, SALES S WHERE P.PRODUCT_NAME = 'S8' AND P.PRODUCT_ID = S.PRODUCT_ID AND S.BUYER_ID NOT IN (SELECT DISTINCT S1.BUYER_ID FROM PRODUCT P1, SALES S1 WHERE P1.PRODUCT_ID = S1.PRODUCT_ID AND P1.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM FRIENDSHIP F JOIN LIKES L ON (L.USER_ID=F.USER2_ID AND F.USER1_ID=1) OR (L.USER_ID=F.USER1_ID AND F.USER2_ID=1) WHERE L.PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH PPUS AS ( SELECT PRICES.PRODUCT_ID, START_DATE, END_DATE, PRICE, PURCHASE_DATE, UNITS FROM PRICES INNER JOIN UNITSSOLD ON PRICES.PRODUCT_ID = UNITSSOLD.PRODUCT_ID WHERE PURCHASE_DATE BETWEEN START_DATE AND END_DATE) SELECT PRODUCT_ID, ROUND(SUM(UNITS*PRICE)/SUM(UNITS),2) AS AVERAGE_PRICE FROM PPUS GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A JOIN LOGINFO B ON A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS != B.IP_ADDRESS AND A.LOGIN < B.LOGIN WHERE (A.LOGOUT- B.LOGIN) >=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID) > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] WITH CTE AS (SELECT DISTINCT DEPARTMENT_ID FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID= D.ID WHERE D.ID IS NULL) SELECT DISTINCT ID,NAME FROM STUDENTS WHERE DEPARTMENT_ID IN (SELECT DISTINCT DEPARTMENT_ID FROM CTE);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT T1.CUSTOMER_ID, COUNT(T1.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS T1 LEFT JOIN TRANSACTIONS AS T2 ON T1.VISIT_ID=T2.VISIT_ID WHERE T2.VISIT_ID IS NULL GROUP BY T1.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH IPHONE AS ( SELECT DISTINCT S.BUYER_ID FROM SALES S JOIN PRODUCT P USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'IPHONE' ), S8 AS ( SELECT DISTINCT S.BUYER_ID FROM SALES S JOIN PRODUCT P USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'S8' ) SELECT DISTINCT S.BUYER_ID FROM SALES S JOIN S8 SO USING(BUYER_ID) LEFT JOIN IPHONE I ON S.BUYER_ID = I.BUYER_ID WHERE I.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH FIRST_LOGIN AS (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) SELECT A.PLAYER_ID,B.DEVICE_ID FROM FIRST_LOGIN A LEFT JOIN ACTIVITY B ON A.PLAYER_ID=B.PLAYER_ID AND A.FIRST_LOGIN=B.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND (AVG(EXPERIENCE_YEARS),2)AS AVERAGE_YEARS FROM ( SELECT A.PROJECT_ID, A.EMPLOYEE_ID, B.EXPERIENCE_YEARS FROM PROJECT A JOIN EMPLOYEE B ON A.EMPLOYEE_ID=B.EMPLOYEE_ID)A GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT S.BUYER_ID,P.PRODUCT_NAME FROM SALES S LEFT OUTER JOIN PRODUCT P ON (S.PRODUCT_ID=P.PRODUCT_ID) ) SELECT DISTINCT BUYER_ID FROM CTE WHERE BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] SELECT NAME FROM CUSTOMER C WHERE C.REFEREE_ID <> 2 OR C.REFEREE_ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT TB1.CLASS AS CLASS FROM(SELECT CLASS, COUNT(CLASS) AS CNT FROM COURSES GROUP BY CLASS) AS TB1 WHERE CNT >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS ( SELECT * FROM SALES JOIN PRODUCT USING(PRODUCT_ID) ) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME='S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS((P1.X - P2.X))) AS SHORTEST FROM POINT P1, POINT P2 WHERE P1.X != P2.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND S.BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(PID) > 1) AND (LAT, LON) NOT IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(PID) > 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM (SELECT CUSTOMER_ID FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T USING(VISIT_ID) WHERE AMOUNT IS NULL) AS TEMP GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM PERSON WHERE ID IN (SELECT MIN(ID) FROM PERSON GROUP BY EMAIL HAVING COUNT(ID) > 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-3-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] WITH CTE AS (SELECT LOG1.ACCOUNT_ID AS LOG1ID, LOG2.ACCOUNT_ID AS LOG2ID, LOG1.IP_ADDRESS AS LOG1ADD, LOG2.IP_ADDRESS AS LOG2ADD, LOG1.LOGIN AS LOG1LOGIN, LOG2.LOGIN AS LOG2LOGIN, LOG1.LOGOUT AS LOG1LOGOUT,LOG2.LOGOUT AS LOG2LOGOUT FROM LOGINFO LOG1, LOGINFO LOG2 WHERE LOG1.ACCOUNT_ID = LOG2.ACCOUNT_ID AND LOG1.IP_ADDRESS != LOG2.IP_ADDRESS ) SELECT DISTINCT CTE.LOG1ID AS ACCOUNT_ID FROM CTE WHERE CTE.LOG2LOGIN <= CTE.LOG1LOGOUT AND CTE.LOG1LOGIN < CTE.LOG2LOGIN;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME AS CUSTOMERS FROM CUSTOMERS C WHERE ID NOT IN (SELECT DISTINCT(CUSTOMERID) FROM ORDERS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS AS TB1 LEFT JOIN ORDERS AS TB2 ON TB1.ID=TB2.CUSTOMERID WHERE TB2.CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31') AND PRODUCT_ID IN (SELECT DISTINCT PRODUCT_ID FROM SALES);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT DISTINCT A.ID, A.NAME FROM STUDENTS A LEFT JOIN DEPARTMENTS B ON A.DEPARTMENT_ID = B.ID WHERE B.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM PRICES P INNER JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME CUSTOMERS FROM CUSTOMERS C LEFT JOIN ORDERS O ON C.ID=O.CUSTOMERID WHERE O.CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 INNER JOIN LOGINFO L2 ON L2.ACCOUNT_ID = L1.ACCOUNT_ID AND L1.IP_ADDRESS <> L2.IP_ADDRESS WHERE L1.LOGIN <= L2.LOGIN AND L2.LOGIN <= L1.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID ,ROUND(AVG(E.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT P INNER JOIN EMPLOYEE E ON E.EMPLOYEE_ID = P.EMPLOYEE_ID GROUP BY P.PROJECT_ID ORDER BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID,MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID;\n[SQL_2] SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID ORDER BY PLAYER_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S1.BUYER_ID FROM SALES S1 JOIN PRODUCT P1 ON S1.PRODUCT_ID = P1.PRODUCT_ID WHERE P1.PRODUCT_NAME = 'S8' AND S1.BUYER_ID NOT IN ( SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN ( SELECT CASE WHEN USER1_ID = 1 THEN USER2_ID WHEN USER2_ID = 1 THEN USER1_ID ELSE NULL END FRIEND_IDS FROM FRIENDSHIP) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT COUNT(VISITS.VISIT_ID) AS COUNT_NO_TRANS, CUSTOMER_ID FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS AS S LEFT JOIN DEPARTMENTS AS D ON S.DEPARTMENT_ID = D.ID WHERE D.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS AS S LEFT JOIN DEPARTMENTS AS D ON S.DEPARTMENT_ID = D.ID WHERE D.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH CTE AS (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_DATE FROM ACTIVITY GROUP BY PLAYER_ID) SELECT CTE.PLAYER_ID, DEVICE_ID FROM CTE JOIN ACTIVITY A ON CTE.PLAYER_ID=A.PLAYER_ID AND CTE.FIRST_DATE=A.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, SNAME AS NAME FROM (SELECT S.ID, S.NAME AS SNAME, D.NAME AS DNAME FROM STUDENTS AS S LEFT JOIN DEPARTMENTS AS D ON S.DEPARTMENT_ID = D.ID) AS N WHERE N.DNAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH DATA1 AS (SELECT C.CUSTOMER_ID AS CUSTOMER_ID,CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O USING (CUSTOMER_ID) WHERE PRODUCT_NAME IN ('A') ), DATA2 AS (SELECT C.CUSTOMER_ID AS CUSTOMER_ID,CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O USING (CUSTOMER_ID) WHERE PRODUCT_NAME IN ('B') ) SELECT DISTINCT DATA1.CUSTOMER_ID,DATA1.CUSTOMER_NAME FROM DATA1 JOIN DATA2 USING (CUSTOMER_ID) WHERE DATA1.CUSTOMER_NAME NOT IN ( SELECT CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O USING (CUSTOMER_ID) WHERE PRODUCT_NAME IN ('C') ) ORDER BY DATA1.CUSTOMER_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) TIV_2016 FROM INSURANCE WHERE (LAT,LON) IN ( SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(PID)=1) AND TIV_2015 NOT IN ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(PID)=1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT A.PRODUCT_ID, ROUND(SUM(A.PRICE*B.UNITS)/SUM(B.UNITS),2) AS AVERAGE_PRICE FROM PRICES A JOIN UNITSSOLD B ON A.PRODUCT_ID=B.PRODUCT_ID AND PURCHASE_DATE>=START_DATE AND PURCHASE_DATE<=END_DATE GROUP BY A.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT A.VIEWER_ID AS ID FROM VIEWS A JOIN VIEWS B ON A.VIEW_DATE = B.VIEW_DATE AND A.ARTICLE_ID != B.ARTICLE_ID AND A.VIEWER_ID = B.VIEWER_ID ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE VIEWS.AUTHOR_ID=VIEWS.VIEWER_ID ORDER BY AUTHOR_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM(SELECT CUSTOMER_ID FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS)) AS T GROUP BY CUSTOMER_ID ORDER BY CUSTOMER_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID AS ID, S.NAME AS NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID WHERE D.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT COALESCE(UNIQUE_ID) AS UNIQUE_ID, NAME FROM EMPLOYEES LEFT JOIN EMPLOYEEUNI USING(ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT A.VIEWER_ID AS ID FROM (SELECT VIEWER_ID, VIEW_DATE FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1) AS A ORDER BY 1 ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME ='S8' AND BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH MAX_SALARY AS (SELECT COMPANY_ID, MAX(SALARY) AS MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) SELECT S.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(CASE WHEN MAX_SAL < 1000 THEN SALARY WHEN MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY - ((SALARY * 24) / 100) WHEN MAX_SAL > 10000 THEN SALARY - ((SALARY*49)/100) END,0) AS SALARY FROM SALARIES S JOIN MAX_SALARY M ON S.COMPANY_ID = M.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT DISTINCT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE='2019-07-04' AND EXTRA IS NOT NULL AND ACTION='REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, 'STORE1' AS STORE, SUM(STORE1) AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL GROUP BY PRODUCT_ID UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, SUM(STORE2) AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL GROUP BY PRODUCT_ID UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, SUM(STORE3) AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT P.PRODUCT_ID FROM PRODUCT AS P JOIN SALES AS S ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.SALE_DATE < '2019-01-01' OR S.SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE (POPULATION > 25000000 OR AREA > 3000000);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM (SELECT EMAIL , COUNT(EMAIL) AS C FROM PERSON GROUP BY EMAIL)AS EMAIL WHERE C>1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID IN (SELECT AUTHOR_ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID) ORDER BY AUTHOR_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT P.FIRSTNAME, P.LASTNAME, A.CITY, A.STATE FROM PERSON P LEFT JOIN ADDRESS AS A ON A.PERSONID = P.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE AS (SELECT COMPANY_ID, MAX(SALARY) AS NUM FROM SALARIES GROUP BY COMPANY_ID) SELECT A.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(CASE WHEN NUM < 1000 THEN SALARY WHEN NUM > 1000 AND NUM < 10000 THEN SALARY * (1-0.24) WHEN NUM > 10000 THEN SALARY * (1-0.49) END,0) AS SALARY FROM SALARIES A JOIN CTE B ON A.COMPANY_ID = B.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH TEMP AS ( SELECT V.*,T.TRANSACTION_ID FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID), TEMP1 AS ( SELECT CUSTOMER_ID,TEMP.TRANSACTION_ID FROM TEMP WHERE TRANSACTION_ID IS NULL) SELECT CUSTOMER_ID,COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM TEMP1 GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID, DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID HAVING COUNT(DIRECTOR_ID) >= 3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.VIEWER_ID AS ID FROM VIEWS V1 JOIN VIEWS V2 ON V1.VIEWER_ID = V2.VIEWER_ID AND V1.VIEW_DATE = V2.VIEW_DATE AND V1.ARTICLE_ID <> V2.ARTICLE_ID ORDER BY ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT.PRODUCT_NAME ='S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE (PRODUCT_ID, PRODUCT_NAME) NOT IN (SELECT A.PRODUCT_ID, A.PRODUCT_NAME FROM PRODUCT A JOIN SALES B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM ( SELECT BUYER_ID, SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) S8, SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) IPHONE FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY BUYER_ID ) V WHERE V.S8 > 0 AND V.IPHONE = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH CTE AS (SELECT VIEW_DATE, VIEWER_ID, COUNT(*) FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(*) > 1 AND COUNT(DISTINCT ARTICLE_ID) > 1) SELECT DISTINCT(VIEWER_ID) AS ID FROM CTE ORDER BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS != L2.IP_ADDRESS AND L1.LOGIN <= L2.LOGIN AND L1.LOGOUT >= L2.LOGIN;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE AS ( SELECT COMPANY_ID AS CI,MAX(SALARY) AS SAL FROM SALARIES GROUP BY COMPANY_ID) SELECT COMPANY_ID,EMPLOYEE_ID,EMPLOYEE_NAME, (CASE WHEN C.SAL<1000 THEN SALARY WHEN C.SAL>=1000 AND C.SAL<=10000 THEN ROUND((SALARY-(SALARY*0.24)),0) ELSE ROUND((SALARY-(SALARY*0.49)),0) END) AS SALARY FROM SALARIES S JOIN CTE C ON S.COMPANY_ID=C.CI;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' ) AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-3-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH C1 AS ( SELECT P.PRODUCT_ID AS C1_P, PRODUCT_NAME,BUYER_ID FROM PRODUCT P LEFT JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' ), C2 AS ( SELECT P.PRODUCT_ID AS C3_P, PRODUCT_NAME,BUYER_ID FROM PRODUCT P LEFT JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE' ) SELECT DISTINCT C1.BUYER_ID FROM C1,C2 WHERE C1.BUYER_ID NOT IN (SELECT C2.BUYER_ID FROM C2);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS ( SELECT BUYER_ID AS BUYER_ID , PRODUCT_NAME FROM SALES AS A JOIN (SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT) AS B ON A.PRODUCT_ID = B.PRODUCT_ID GROUP BY BUYER_ID , PRODUCT_NAME ) SELECT DISTINCT(BUYER_ID) FROM TEMP WHERE BUYER_ID IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME='S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S JOIN PRODUCT P USING(PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) >= 1 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID, DIRECTOR_ID FROM ( SELECT ACTOR_ID, DIRECTOR_ID, COUNT(*) AS NUM_COOP FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID ) ANR_COUNTER WHERE NUM_COOP>=3;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] WITH CTE AS(SELECT S.DEPARTMENT_ID FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID=D.ID WHERE D.NAME IS NULL) SELECT DISTINCT S.ID,S.NAME FROM STUDENTS S JOIN CTE ON S.DEPARTMENT_ID=CTE.DEPARTMENT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS.EMPID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE AS ( SELECT USER2_ID AS ID FROM FRIENDSHIP WHERE USER1_ID=1 UNION SELECT USER1_ID AS ID FROM FRIENDSHIP WHERE USER2_ID=1 ) SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM LIKES L JOIN CTE ON CTE.ID = L.USER_ID WHERE L.PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT(O.CUSTOMER_ID),C.CUSTOMER_NAME FROM ORDERS O JOIN CUSTOMERS C ON O.CUSTOMER_ID = C.CUSTOMER_ID WHERE O.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='A') AND O.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='B') AND O.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT(VISIT_ID) FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(DISTINCT CT.CONTACT_NAME) AS CONTACTS_CNT, COUNT(DISTINCT CC.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES I INNER JOIN CUSTOMERS C ON C.CUSTOMER_ID = I.USER_ID LEFT JOIN CONTACTS CT ON CT.USER_ID = C.CUSTOMER_ID LEFT JOIN CUSTOMERS CC ON CC.EMAIL = CT.CONTACT_EMAIL GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A, LOGINFO B WHERE A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS <> B.IP_ADDRESS AND (A.LOGOUT >= B.LOGIN AND A.LOGOUT <= B.LOGOUT OR A.LOGIN >= B.LOGIN AND A.LOGIN <= B.LOGOUT);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY * RATIO, 0) AS SALARY FROM (SELECT *, CASE WHEN MAX_SALARY < 1000 THEN 1 WHEN MAX_SALARY > 10000 THEN 0.51 ELSE 0.76 END AS RATIO FROM SALARIES AS S JOIN (SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID) AS SUB USING(COMPANY_ID)) AS SUB2;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID, DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID HAVING COUNT(ACTOR_ID = DIRECTOR_ID) >= 3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH PRO AS (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE<'2019-01-01' OR SALE_DATE>'2019-03-31') SELECT PRODUCT_ID,PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM PRO);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T1 AS ( SELECT DISTINCT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE' ) SELECT DISTINCT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P USING(PRODUCT_ID) WHERE P.PRODUCT_NAME='S8' AND BUYER_ID NOT IN (SELECT * FROM T1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID IN( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING COUNT(CASE WHEN SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' THEN PRODUCT_ID END) = COUNT(1) );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME, B.BONUS FROM EMPLOYEE E LEFT JOIN BONUS B USING(EMPID) WHERE B.BONUS IS NULL OR B.BONUS < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT(CUSTOMER_ID) AS CUSTOMER_ID, COUNT(VISITS.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID =TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.AMOUNT IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN( SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID AS UNIQUE_ID, NAME FROM EMPLOYEES LEFT JOIN EMPLOYEEUNI ON EMPLOYEES.ID = EMPLOYEEUNI.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] WITH T1 AS (SELECT P.PROJECT_ID , E.EXPERIENCE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID) SELECT PROJECT_ID,ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM T1 GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD U ON U.PRODUCT_ID=P.PRODUCT_ID AND PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A2.PLAYER_ID, A1.DEVICE_ID FROM ACTIVITY AS A1 JOIN ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID WHERE A1.EVENT_DATE = A2.MIN_EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH CTE AS ( SELECT CUSTOMER_ID FROM ORDERS GROUP BY CUSTOMER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'C' THEN 1 ELSE 0 END) = 0 AND SUM(CASE WHEN PRODUCT_NAME ='B' THEN 1 ELSE 0 END) >= 1 AND SUM(CASE WHEN PRODUCT_NAME ='A' THEN 1 ELSE 0 END) >= 1 ) SELECT CU.CUSTOMER_ID, CUSTOMER_NAME FROM CTE C JOIN CUSTOMERS CU ON C.CUSTOMER_ID = CU.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT.PROJECT_ID,ROUND(AVG(EXPERIENCE_YEARS),2)AS AVERAGE_YEARS FROM PROJECT JOIN EMPLOYEE ON PROJECT.EMPLOYEE_ID=EMPLOYEE.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT A.INVOICE_ID, CUSTOMER_NAME, PRICE, CONTACTS_CNT, COALESCE(TRUSTED_CONTACTS_CNT,0) AS TRUSTED_CONTACTS_CNT FROM (SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COUNT(DISTINCT(CO.CONTACT_NAME)) AS CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS CO ON CO.USER_ID = C.CUSTOMER_ID GROUP BY INVOICE_ID, CUSTOMER_NAME, PRICE ORDER BY INVOICE_ID) A LEFT JOIN (SELECT INVOICE_ID, COUNT(DISTINCT(C.CONTACT_NAME)) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CONTACTS C ON C.USER_ID = I.USER_ID WHERE C.CONTACT_NAME IN ( SELECT DISTINCT(CUSTOMER_NAME) FROM CUSTOMERS) GROUP BY INVOICE_ID) B ON A.INVOICE_ID = B.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A INNER JOIN ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID ) B ON A.PLAYER_ID = B.PLAYER_ID AND A.EVENT_DATE = B.MIN_EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM (SELECT EMAIL, COUNT(*) CC FROM PERSON GROUP BY EMAIL )DUP WHERE CC>1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH SAMEDAYVIEWS(VIEWER_ID, VIEW_DATE) AS (SELECT V1.VIEWER_ID, V1.VIEW_DATE FROM VIEWS AS V1, VIEWS AS V2 WHERE V1.ARTICLE_ID != V2.ARTICLE_ID AND V1.VIEWER_ID = V2.VIEWER_ID AND V1.VIEW_DATE = V2.VIEW_DATE) SELECT DISTINCT VIEWER_ID AS ID FROM SAMEDAYVIEWS ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) COUNT_NO_TRANS FROM (SELECT V.VISIT_ID,CUSTOMER_ID, TRANSACTION_ID FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID=T.VISIT_ID) S WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT DISTINCT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE='2019-07-04' AND EXTRA!='NULL' AND ACTION='REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.PRODUCT_ID, P.PRODUCT_NAME HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(A.X - B.X) AS SHORTEST FROM POINT A LEFT JOIN POINT B ON A.X > B.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A JOIN ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID ) P ON A.PLAYER_ID = P.PLAYER_ID AND A.EVENT_DATE = P.MIN_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CON AS ( SELECT C.*, CASE WHEN CUU.CUSTOMER_ID IS NULL THEN 0 ELSE 1 END AS TRUSTED FROM CONTACTS C LEFT JOIN CUSTOMERS CUU ON CUU.EMAIL=C.CONTACT_EMAIL ) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COUNT(CONTACT_NAME) AS CONTACTS_CNT, COALESCE(SUM(TRUSTED),0) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS CU ON I.USER_ID=CU.CUSTOMER_ID LEFT JOIN CON ON CU.CUSTOMER_ID=CON.USER_ID GROUP BY INVOICE_ID,CUSTOMER_NAME,PRICE ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID AS PRODUCT_ID, ROUND(SUM(P.PRICE * U.UNITS)/SUM( U.UNITS), 2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S JOIN PRODUCT P USING(PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.SALE_DATE >= '2019-01-01' AND S.SALE_DATE <= '2019-03-31' AND S.PRODUCT_ID NOT IN ( SELECT DISTINCT S.PRODUCT_ID FROM PRODUCT P JOIN SALES S ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.SALE_DATE < '2019-01-01' OR S.SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID,PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID IN (SELECT DISTINCT(PRODUCT_ID) FROM SALES WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE<'2019-01-01' OR SALE_DATE>'2019-03-31'));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS USING (VISIT_ID) WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID ORDER BY 2,1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEEUNI A RIGHT JOIN EMPLOYEES B ON A.ID = B.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EU.UNIQUE_ID AS UNIQUE_ID, E.NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EU ON E.ID = EU.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH SAME_TIV_2015 AS ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(1) > 1 ), DIFF_LAT_LONG AS ( SELECT LAT, LON, COUNT(1) FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(1) = 1 ) SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE I1 INNER JOIN SAME_TIV_2015 R1 ON I1.TIV_2015 = R1.TIV_2015 INNER JOIN DIFF_LAT_LONG R2 ON I1.LAT = R2.LAT AND I1.LON = R2.LON;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT C.CUSTOMER_ID FROM CUSTOMERS C, ORDERS O WHERE C.CUSTOMER_ID = O.CUSTOMER_ID AND O.PRODUCT_NAME ='A' ) AND CUSTOMER_ID IN (SELECT C.CUSTOMER_ID FROM CUSTOMERS C, ORDERS O WHERE C.CUSTOMER_ID = O.CUSTOMER_ID AND O.PRODUCT_NAME ='B' ) AND CUSTOMER_ID NOT IN (SELECT C.CUSTOMER_ID FROM CUSTOMERS C, ORDERS O WHERE C.CUSTOMER_ID = O.CUSTOMER_ID AND O.PRODUCT_NAME ='C' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(INSURANCE.TIV_2016) AS TIV_2016 FROM INSURANCE WHERE INSURANCE.TIV_2015 IN ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) > 1 ) AND (LAT, LON) IN ( SELECT LAT, LON FROM INSURANCE GROUP BY LAT , LON HAVING COUNT(*) = 1 );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT S.BUYER_ID, P.PRODUCT_NAME FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM CTE WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME ='IPHONE') AND BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME='S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH A AS ( SELECT U.PRODUCT_ID, U.UNITS, P.PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PURCHASE_DATE >= P.START_DATE AND U.PURCHASE_DATE <= P.END_DATE AND U.PRODUCT_ID = P.PRODUCT_ID ) SELECT PRODUCT_ID, ROUND(TOTAL_SALE/TOTAL_UNIT, 2) AS AVERAGE_PRICE FROM ( SELECT PRODUCT_ID, SUM(UNITS*PRICE) AS TOTAL_SALE, SUM(UNITS) AS TOTAL_UNIT FROM A GROUP BY PRODUCT_ID) AS B;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT WORLD.NAME, WORLD.AREA, WORLD.POPULATION FROM WORLD WHERE AREA > 3000000 OR POPULATION > 25000000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT A.AUTHOR_ID AS ID FROM VIEWS A, VIEWS B WHERE A.AUTHOR_ID = B.VIEWER_ID AND A.ARTICLE_ID = B.ARTICLE_ID ORDER BY A.AUTHOR_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID,P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH TOTAL_UNITS AS ( SELECT U1.PRODUCT_ID, SUM(UNITS) AS TU FROM UNITSSOLD U1 GROUP BY U1.PRODUCT_ID ),TOTAL_PRICE_BY_DATE AS ( SELECT P.PRODUCT_ID, CASE WHEN PURCHASE_DATE BETWEEN START_DATE AND END_DATE THEN UNITS * PRICE ELSE 0 END AS TOTAL_COST FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID ), TOTAL_PRICE AS ( SELECT PRODUCT_ID, SUM(TOTAL_COST) AS TOTAL_COST FROM TOTAL_PRICE_BY_DATE GROUP BY PRODUCT_ID ) SELECT U.PRODUCT_ID, ROUND(TOTAL_COST/TU, 2) AS AVERAGE_PRICE FROM TOTAL_PRICE P JOIN TOTAL_UNITS U ON P.PRODUCT_ID = U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN MSAL<1000 THEN SALARY WHEN MSAL BETWEEN 1000 AND 10001 THEN SALARY*(1-0.24) WHEN MSAL>10000 THEN SALARY*(1-0.49) END,0) AS SALARY FROM SALARIES S JOIN (SELECT COMPANY_ID, MAX(SALARY) AS MSAL FROM SALARIES GROUP BY COMPANY_ID) A ON S.COMPANY_ID = A.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME AS CUSTOMERS FROM CUSTOMERS C LEFT JOIN ORDERS O ON (C.ID = O.CUSTOMERID) WHERE O.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CONTACTS_CNT AS ( SELECT USER_ID, COUNT(*) AS CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID ), TRUSTED_CONTACTS_CNT AS ( SELECT USER_ID, COUNT(*) AS TRUSTED_CONTACTS_CNT FROM CONTACTS WHERE CONTACT_EMAIL IN ( SELECT EMAIL FROM CUSTOMERS ) GROUP BY USER_ID ) SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COALESCE(CC.CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(TCC.TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM INVOICES I INNER JOIN CUSTOMERS C ON C.CUSTOMER_ID = I.USER_ID LEFT JOIN CONTACTS_CNT CC ON CC.USER_ID = I.USER_ID LEFT JOIN TRUSTED_CONTACTS_CNT TCC ON TCC.USER_ID = I.USER_ID ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS A ON A.CUSTOMER_ID = C.CUSTOMER_ID AND A.PRODUCT_NAME = 'A' JOIN ORDERS B ON B.CUSTOMER_ID = C.CUSTOMER_ID AND B.PRODUCT_NAME = 'B' LEFT JOIN ORDERS O ON O.CUSTOMER_ID = C.CUSTOMER_ID AND O.PRODUCT_NAME = 'C' WHERE O.ORDER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(S.UNITS*P.PRICE) / SUM(S.UNITS),2)AS AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD S ON P.PRODUCT_ID = S.PRODUCT_ID AND S.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID= D.ID WHERE D.NAME IS NULL ORDER BY S.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT U.UNIQUE_ID, E.NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI U ON U.ID = E.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31') AND PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE NOT SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] (SELECT '[0-5>' AS BIN, SUM(CASE WHEN DURATION >=0 AND DURATION < 300 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION (SELECT '[5-10>' AS BIN, SUM(CASE WHEN DURATION >=300 AND DURATION < 600 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION (SELECT '[10-15>' AS BIN, SUM(CASE WHEN DURATION >=600 AND DURATION < 900 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION (SELECT '15 OR MORE' AS BIN, SUM(CASE WHEN DURATION >=900 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT P.FIRSTNAME,P.LASTNAME,E.CITY,E.STATE FROM PERSON P LEFT JOIN ADDRESS E ON P.PERSONID=E.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(A.X-B.X) AS SHORTEST FROM POINT A JOIN POINT B ON A.X!=B.X ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM EMPLOYEE E INNER JOIN PROJECT P ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND(AVG(E.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E USING (EMPLOYEE_ID) GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL ORDER BY 1,2;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN ( SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CNT AS( SELECT BUYER_ID, SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS S8, SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS IPHONE FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY BUYER_ID) SELECT BUYER_ID FROM CNT WHERE S8 > 0 AND IPHONE = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN MAX_SALARY < 1000 THEN S.SALARY WHEN MAX_SALARY >= 1000 AND MAX_SALARY <= 10000 THEN S.SALARY*(1-0.24) WHEN MAX_SALARY > 10000 THEN S.SALARY*(1-0.49) END, 0) AS SALARY FROM SALARIES AS S, (SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID) AS A WHERE S.COMPANY_ID = A.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT STUDENTS.ID, STUDENTS.NAME FROM DEPARTMENTS RIGHT OUTER JOIN STUDENTS ON STUDENTS.DEPARTMENT_ID = DEPARTMENTS.ID WHERE DEPARTMENTS.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] SELECT INSTALL_DT, COUNT(PLAYER) AS INSTALLS, ROUND(COUNT(NEXT_DAY)/COUNT(PLAYER), 2) AS DAY1_RETENTION FROM (SELECT B.PLAYER_ID AS PLAYER, B.FIRST_DATE AS INSTALL_DT, A.EVENT_DATE AS NEXT_DAY FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_DATE FROM ACTIVITY GROUP BY PLAYER_ID) B LEFT JOIN ACTIVITY A ON (A.PLAYER_ID = B.PLAYER_ID) AND (A.EVENT_DATE = B.FIRST_DATE + 1)) T GROUP BY T.INSTALL_DT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH S AS ( SELECT BUYER_ID FROM SALES WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME='S8') ), I AS ( SELECT BUYER_ID FROM SALES WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME='IPHONE') ) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM S) AND BUYER_ID NOT IN (SELECT BUYER_ID FROM I);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT A.BUYER_ID FROM SALES AS A INNER JOIN PRODUCT AS B ON A.PRODUCT_ID=B.PRODUCT_ID GROUP BY A.BUYER_ID HAVING SUM(CASE WHEN B.PRODUCT_NAME='S8' THEN 1 ELSE 0 END)>0 AND SUM(CASE WHEN B.PRODUCT_NAME='IPHONE' THEN 1 ELSE 0 END)=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY VIEWER_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PROD.PRODUCT_ID AS PRODUCT_ID ,PROD.PRODUCT_NAME AS PRODUCT_NAME FROM PRODUCT PROD LEFT JOIN SALES SALES ON PROD.PRODUCT_ID = SALES.PRODUCT_ID AND (SALES.SALE_DATE > '2019-03-31' OR SALES.SALE_DATE < '2019-01-01') WHERE SALES.SELLER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM EMPLOYEE E JOIN PROJECT P ON E.EMPLOYEE_ID = P.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE (BUYER_ID) IN (SELECT BUYER_ID FROM PRODUCT RIGHT JOIN SALES USING(PRODUCT_ID) WHERE PRODUCT_NAME='S8') AND (BUYER_ID) NOT IN (SELECT BUYER_ID FROM PRODUCT RIGHT JOIN SALES USING(PRODUCT_ID) WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE AS ( SELECT C1.CUSTOMER_ID, MAX(C1.CUSTOMER_NAME) CUSTOMER_NAME,COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_NAME IN (SELECT DISTINCT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) TRUSTED_CONTACTS_CNT FROM CONTACTS C RIGHT JOIN CUSTOMERS C1 ON C.USER_ID = C1.CUSTOMER_ID GROUP BY C1.CUSTOMER_ID ) SELECT INVOICE_ID,CUSTOMER_NAME,PRICE,CONTACTS_CNT,TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CTE C ON I.USER_ID=C.CUSTOMER_ID ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 , LOGINFO L2 WHERE L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS != L2.IP_ADDRESS AND L1.LOGOUT BETWEEN L2.LOGIN AND L2.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT COURSES.CLASS AS CLASS FROM (SELECT DISTINCT * FROM COURSES) AS COURSES GROUP BY COURSES.CLASS HAVING COUNT(COURSES.CLASS) >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C1.CUSTOMER_NAME, I.PRICE, COUNT(CONT.USER_ID) AS CONTACTS_CNT, COUNT(C2.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS C1 ON I.USER_ID = C1.CUSTOMER_ID LEFT JOIN CONTACTS CONT ON C1.CUSTOMER_ID = CONT.USER_ID LEFT JOIN CUSTOMERS C2 ON CONT.CONTACT_EMAIL = C2.EMAIL GROUP BY I.INVOICE_ID, C1.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID, COUNT(VISITS.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.VISIT_ID IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(A.X-B.X)) AS SHORTEST FROM POINT A, POINT B WHERE A.X>B.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES S WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH FRIENDS AS (SELECT USER1_ID AS UID FROM FRIENDSHIP WHERE USER2_ID = 1 UNION SELECT USER2_ID AS UID FROM FRIENDSHIP WHERE USER1_ID = 1) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT DISTINCT UID FROM FRIENDS) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID IN ( SELECT DISTINCT DEPARTMENT_ID AS DEPARTMENT_ID FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE1 AS ( SELECT CON.USER_ID, CON.CONTACT_NAME, CASE WHEN CUS.CUSTOMER_NAME IS NULL THEN 0 ELSE 1 END AS TRUSTED FROM CONTACTS CON LEFT JOIN CUSTOMERS CUS ON CON.CONTACT_NAME = CUS.CUSTOMER_NAME) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COUNT(CONTACT_NAME) AS CONTACTS_CNT , COALESCE(SUM(TRUSTED),0) AS TRUSTED_CONTACTS_CNT FROM INVOICES A LEFT JOIN CUSTOMERS B ON A.USER_ID = B.CUSTOMER_ID LEFT JOIN CTE1 C ON B.CUSTOMER_ID = C.USER_ID GROUP BY INVOICE_ID, CUSTOMER_NAME, PRICE ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNI.UNIQUE_ID AS UNIQUE_ID, NAME FROM EMPLOYEES AS E LEFT JOIN EMPLOYEEUNI AS UNI ON E.ID = UNI.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, AREA, POPULATION FROM WORLD WHERE POPULATION > 25000000 OR AREA > 3000000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT(VIEWER_ID) AS ID FROM VIEWS WHERE (VIEWER_ID,VIEW_DATE) IN (SELECT VIEWER_ID,VIEW_DATE FROM VIEWS GROUP BY VIEWER_ID,VIEW_DATE HAVING COUNT(DISTINCT(ARTICLE_ID))>=2) ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE* U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES AS P INNER JOIN UNITSSOLD AS U ON P.PRODUCT_ID = U.PRODUCT_ID WHERE U.PURCHASE_DATE >= P.START_DATE AND U.PURCHASE_DATE <= P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH TMP AS (SELECT USER_ID, COUNT(*) AS CONTACTS_CNT, SUM(CASE WHEN EMAIL IS NULL THEN 0 ELSE 1 END) AS TRUSTED_CONTACTS_CNT FROM CONTACTS LEFT JOIN CUSTOMERS ON EMAIL=CONTACT_EMAIL GROUP BY USER_ID) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COALESCE(CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM INVOICES AS I LEFT JOIN CUSTOMERS AS C ON I.USER_ID=C.CUSTOMER_ID LEFT JOIN TMP ON I.USER_ID=TMP.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EUNI.UNIQUE_ID, E.NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI AS EUNI ON E.ID=EUNI.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID AS CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON (V.VISIT_ID = T.VISIT_ID) WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT O.CUSTOMER_ID, C.CUSTOMER_NAME FROM ORDERS O JOIN CUSTOMERS C ON O.CUSTOMER_ID = C.CUSTOMER_ID WHERE O.CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND O.CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND O.CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID ,C1.CUSTOMER_NAME ,I.PRICE ,COUNT(M.CONTACT_EMAIL) AS CONTACTS_CNT ,SUM(CASE WHEN C2.CUSTOMER_NAME IS NOT NULL THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C1 ON I.USER_ID = C1.CUSTOMER_ID LEFT JOIN CONTACTS M ON C1.CUSTOMER_ID = M.USER_ID LEFT JOIN CUSTOMERS C2 ON M.CONTACT_NAME = C2.CUSTOMER_NAME AND M.CONTACT_EMAIL = C2.EMAIL GROUP BY I.INVOICE_ID, C1.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH TEMP AS( SELECT P.PRODUCT_ID,P.PRICE,U.UNITS, (PRICE*UNITS) AS TOTAL FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID WHERE PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID, START_DATE, END_DATE, PURCHASE_DATE, P.PRICE, U.UNITS) SELECT PRODUCT_ID, ROUND((SUM(TEMP.TOTAL)/SUM(TEMP.UNITS)),2) AS AVERAGE_PRICE FROM TEMP GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.VISIT_ID IS NULL GROUP BY CUSTOMER_ID ORDER BY COUNT(CUSTOMER_ID) DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS ( SELECT A.*,B.PRODUCT_NAME FROM SALES A LEFT JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM ( SELECT DISTINCT * FROM VIEWS) AS A GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(VIEWER_ID) > 1 ORDER BY ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM, COUNT(*) AS CNT FROM MYNUMBERS GROUP BY NUM) T WHERE CNT = 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID ,A.DEVICE_ID FROM (SELECT PLAYER_ID ,MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) DT JOIN ACTIVITY A ON A.PLAYER_ID = DT.PLAYER_ID AND A.EVENT_DATE = DT.MIN_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(POST_ID) AS REPORT_COUNT FROM ( SELECT DISTINCT POST_ID, ACTION_DATE, EXTRA FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION = 'REPORT' ) AS T WHERE ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM( SELECT EMAIL, COUNT(*) AS NUM FROM PERSON GROUP BY EMAIL HAVING COUNT(*) > 1) AS TEMP;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] WITH TT AS (SELECT ACTOR_ID,DIRECTOR_ID, COUNT(DIRECTOR_ID) COLLAB FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID) SELECT ACTOR_ID,DIRECTOR_ID FROM TT WHERE COLLAB >=3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE, COUNT(C.CONTACT_NAME) AS CONTACTS_CNT, COUNT(CASE WHEN D.CUSTOMER_NAME IS NOT NULL THEN C.CONTACT_NAME ELSE NULL END) AS TRUSTED_CONTACTS_CNT FROM INVOICES A JOIN CUSTOMERS B ON A.USER_ID=B.CUSTOMER_ID LEFT JOIN CONTACTS C ON B.CUSTOMER_ID=C.USER_ID LEFT JOIN CUSTOMERS D ON C.CONTACT_NAME=D.CUSTOMER_NAME AND C.CONTACT_EMAIL=D.EMAIL GROUP BY A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE ORDER BY A.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(P1.X-P2.X) AS SHORTEST FROM POINT P1, POINT P2 WHERE P1.X<>P2.X ORDER BY 1 LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT P WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES S WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(DISTANCE) AS SHORTEST FROM ( SELECT ABS(T1.X - T2.X) AS DISTANCE FROM POINT T1 JOIN POINT T2 ON T1.X <> T2.X ) AS T;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND((SUM(E.EXPERIENCE_YEARS)/COUNT(E.EXPERIENCE_YEARS)),2) AS AVERAGE_YEARS FROM EMPLOYEE E JOIN PROJECT P ON E.EMPLOYEE_ID = P.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT L.AUTHOR_ID AS ID FROM VIEWS L INNER JOIN VIEWS R ON L.AUTHOR_ID = R.VIEWER_ID AND L.ARTICLE_ID = R.ARTICLE_ID ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, E.NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI B ON E.ID = B.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH T1 AS (SELECT DISTINCT VIEWER_ID, COUNT(DISTINCT ARTICLE_ID) AS CT FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE) SELECT DISTINCT VIEWER_ID AS ID FROM T1 WHERE CT>1 ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH A AS ( SELECT BUYER_ID, SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS S8FLAG, SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS IPFLAG FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY BUYER_ID) SELECT BUYER_ID FROM A WHERE S8FLAG >= 1 AND IPFLAG = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(P1.X-P2.X)) SHORTEST FROM POINT P1 CROSS JOIN POINT P2 WHERE P1.X<>P2.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T AS (SELECT BUYER_ID, PRODUCT_NAME FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM T WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM T WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(VISITS.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS LEFT OUTER JOIN TRANSACTIONS ON VISITS.VISIT_ID=TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] WITH CTE AS (SELECT COUNT(*) AS EMAIL_NUM, EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL) SELECT EMAIL FROM CTE WHERE EMAIL_NUM>1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM INSURANCE WHERE (LAT, LON) NOT IN ( SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) > 1 ) AND TIV_2015 IN ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) > 1 );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(TIV_2015) > 1) AND (LAT, LON) IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) = 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO AS L1 LEFT JOIN LOGINFO AS L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID WHERE L1.IP_ADDRESS <> L2.IP_ADDRESS AND L1.LOGOUT >= L2.LOGIN AND L1.LOGOUT <= L2.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING MAX(PRODUCT_NAME = 'S8')=1 AND MAX(PRODUCT_NAME = 'IPHONE') = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM)=1) AS T1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(CUSTOMER_ID) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID=T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT DISTINCT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID END AS FRIENDS FROM FRIENDSHIP WHERE USER1_ID=1 OR USER2_ID=1) AND PAGE_ID NOT IN (SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH MAX_SALARY AS ( SELECT COMPANY_ID,MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID ) SELECT B.COMPANY_ID, B.EMPLOYEE_ID, B.EMPLOYEE_NAME, CASE WHEN A.MAX_SALARY<1000 THEN B.SALARY WHEN MAX_SALARY BETWEEN 1000 AND 10000 THEN ROUND(B.SALARY*0.76,0) WHEN MAX_SALARY > 10000 THEN ROUND(B.SALARY*0.51,0) END AS SALARY FROM MAX_SALARY A JOIN SALARIES B ON A.COMPANY_ID=B.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH CTE AS ( SELECT VIEW_DATE, VIEWER_ID, COUNT(DISTINCT ARTICLE_ID) HOLDER FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID ) SELECT DISTINCT VIEWER_ID AS ID FROM CTE WHERE HOLDER > 1 ORDER BY VIEWER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS IS NULL OR BONUS<1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID, COUNT(VISITS.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.AMOUNT IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE AS ( SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER1_ID FROM FRIENDSHIP WHERE USER2_ID = 1 ) SELECT DISTINCT PAGE_ID RECOMMENDED_PAGE FROM CTE C JOIN LIKES L ON C.USER2_ID = L.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME='S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN P.PRODUCT_NAME='IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE B.BONUS < 1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(*) AS REPORT_COUNT FROM( SELECT DISTINCT POST_ID, ACTION_DATE, EXTRA FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND ACTION='REPORT' ) SUB GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EMP.NAME, EMPUNI.UNIQUE_ID FROM EMPLOYEEUNI EMPUNI RIGHT JOIN EMPLOYEES EMP ON EMP.ID = EMPUNI.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT A.BUYER_ID FROM (SELECT S.BUYER_ID , P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID) A GROUP BY A.BUYER_ID HAVING SUM(CASE WHEN A.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) >= 1 AND SUM(CASE WHEN A.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT S.PRODUCT_ID,P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.PRODUCT_ID, P.PRODUCT_NAME HAVING (MIN(SALE_DATE) >= '2019-01-01') AND (MAX(SALE_DATE) <= '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA HAVING COUNT(DISTINCT POST_ID) > 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT EMPLOYEE.NAME, BONUS.BONUS AS BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID=BONUS.EMPID WHERE BONUS<1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' BIN, COUNT(*) TOTAL FROM SESSIONS WHERE DURATION < 300 UNION ALL SELECT '[5-10>' BIN, COUNT(*) TOTAL FROM SESSIONS WHERE DURATION BETWEEN 300 AND 600 UNION ALL SELECT '[10-15>' BIN, COUNT(*) TOTAL FROM SESSIONS WHERE DURATION BETWEEN 600 AND 900 UNION ALL SELECT '15 OR MORE' BIN, COUNT(*) TOTAL FROM SESSIONS WHERE DURATION > 900;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='C')) O JOIN CUSTOMERS C ON O.CUSTOMER_ID=C.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN ( SELECT DISTINCT USER1_ID AS FRIEND FROM FRIENDSHIP WHERE USER2_ID=1 UNION SELECT DISTINCT USER2_ID AS FRIEND FROM FRIENDSHIP WHERE USER1_ID=1) AND PAGE_ID NOT IN ( SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM SALES WHERE BUYER_ID IN ( SELECT BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' ) AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT(POST_ID)) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE='2019-07-04' AND ACTION='REPORT' GROUP BY EXTRA ORDER BY EXTRA;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND((COUNT(A.PLAYER_ID) / COUNT(T.PLAYER_ID)),2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) T LEFT JOIN ACTIVITY A ON A.PLAYER_ID = T.PLAYER_ID AND T.FIRST_LOGIN = A.EVENT_DATE - 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN (P.PRODUCT_NAME = 'IPHONE') THEN 1 ELSE 0 END)=0 AND SUM(CASE WHEN (P.PRODUCT_NAME = 'S8') THEN 1 ELSE 0 END)>0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND((SUM(P.PRICE*U.UNITS))/(SUM(U.UNITS)),2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE AS ( SELECT USER1_ID AS USER_ID, USER2_ID AS FRIEND_ID FROM FRIENDSHIP WHERE USER1_ID < USER2_ID UNION ALL SELECT USER2_ID AS USER_ID, USER1_ID AS FRIEND_ID FROM FRIENDSHIP WHERE USER2_ID < USER1_ID ) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM ( SELECT C.USER_ID, C.FRIEND_ID, L.PAGE_ID FROM CTE C JOIN LIKES L ON C.FRIEND_ID = L.USER_ID WHERE C.USER_ID = 1 AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1) ) TEMP;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES A, PRODUCT B WHERE A.PRODUCT_ID=B.PRODUCT_ID GROUP BY BUYER_ID HAVING MAX(PRODUCT_NAME='S8') AND MAX(PRODUCT_NAME='IPHONE')=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CONTACT_CNT AS( SELECT USER_ID, COUNT(CONTACT_NAME) AS CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID ), TRUSTED_CONTACT_CNT AS ( SELECT USER_ID, SUM(CASE WHEN CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID ) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COALESCE(CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACT_CNT ON C.CUSTOMER_ID = CONTACT_CNT.USER_ID LEFT JOIN TRUSTED_CONTACT_CNT ON CONTACT_CNT.USER_ID = TRUSTED_CONTACT_CNT.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE WORLD.AREA > 3000000 OR WORLD.POPULATION > 25000000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE(PLAYER_ID, EVENT_DATE)IN (SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID) ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='A' AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='B')) AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, MAX(I.PRICE) AS PRICE, COUNT(CO.USER_ID) AS CONTACTS_CNT, SUM(CASE WHEN CO.CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM INVOICES I INNER JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT OUTER JOIN CONTACTS CO ON CO.USER_ID = C.CUSTOMER_ID GROUP BY C.CUSTOMER_NAME, I.INVOICE_ID ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISITS.VISIT_ID NOT IN (SELECT T.VISIT_ID FROM VISITS V INNER JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(U.UNITS * P.PRICE)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH SUB AS (SELECT VIEWER_ID,VIEW_DATE,COUNT(DISTINCT ARTICLE_ID) COUNT1 FROM VIEWS GROUP BY VIEWER_ID,VIEW_DATE ) SELECT DISTINCT VIEWER_ID ID FROM SUB WHERE COUNT1>1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 INNER JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.LOGIN >= L2.LOGIN AND L1.LOGIN <= L2.LOGOUT WHERE L1.IP_ADDRESS <> L2.IP_ADDRESS GROUP BY L1.ACCOUNT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE_COMPANYSALARY AS ( SELECT COMPANY_ID, CASE WHEN MAX(SALARY) < 1000 THEN 0 WHEN MAX(SALARY) BETWEEN 1000 AND 10000 THEN 0.24 WHEN MAX(SALARY)>10000 THEN 0.49 END AS TAX_RATE FROM SALARIES GROUP BY COMPANY_ID ) SELECT S.COMPANY_ID,S.EMPLOYEE_ID,S.EMPLOYEE_NAME,ROUND((S.SALARY - (C.TAX_RATE*S.SALARY)),0) AS SALARY FROM SALARIES S JOIN CTE_COMPANYSALARY C ON C.COMPANY_ID = S.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS CUST WHERE CUST.ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRICES.PRODUCT_ID, ROUND(SUM(UNITS*PRICE) / SUM(UNITS), 2) AVERAGE_PRICE FROM PRICES JOIN UNITSSOLD US ON PRICES.PRODUCT_ID = US.PRODUCT_ID AND US.PURCHASE_DATE BETWEEN PRICES.START_DATE AND PRICES.END_DATE GROUP BY PRICES.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME ='S8' THEN 1 ELSE 0 END)>=1 AND SUM(CASE WHEN P.PRODUCT_NAME= 'IPHONE' THEN 1 ELSE 0 END)=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON,COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION_DATE = '2019-07-04' AND ACTIONS.ACTION = 'REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A LEFT JOIN LOGINFO B ON A.ACCOUNT_ID = B.ACCOUNT_ID AND ((A.LOGIN<=B.LOGIN AND A.LOGOUT>=B.LOGIN) OR (A.LOGIN>=B.LOGIN AND A.LOGIN <= B.LOGOUT)) WHERE A.IP_ADDRESS <> B.IP_ADDRESS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISITS.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID =1) AND USER_ID IN ( SELECT FRIENDS FROM ( SELECT CASE WHEN USER1_ID = 1 THEN USER2_ID WHEN USER2_ID = 1 THEN USER1_ID END AS FRIENDS FROM FRIENDSHIP ) A WHERE FRIENDS IS NOT NULL);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] WITH FIRST_DATE AS( SELECT PLAYER_ID FROM ACTIVITY GROUP BY PLAYER_ID HAVING (PLAYER_ID, MIN(EVENT_DATE)+1) IN (SELECT PLAYER_ID,EVENT_DATE FROM ACTIVITY) ) SELECT ROUND(COUNT(DISTINCT F.PLAYER_ID)/COUNT(DISTINCT A.PLAYER_ID),2) AS FRACTION FROM ACTIVITY A ,FIRST_DATE F;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES A JOIN PRODUCT P USING(PRODUCT_ID) WHERE P.PRODUCT_NAME = 'S8' AND A.BUYER_ID NOT IN (SELECT DISTINCT BUYER_ID FROM SALES JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH TEMP AS ( SELECT V.CUSTOMER_ID, V.VISIT_ID FROM VISITS V LEFT OUTER JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL ), FINALTABLE AS ( SELECT CUSTOMER_ID, COUNT(VISIT_ID) AS COUNT_NO_TRANS FROM TEMP GROUP BY CUSTOMER_ID ) SELECT * FROM FINALTABLE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE I INNER JOIN (SELECT DISTINCT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) >1) A ON I.TIV_2015 = A.TIV_2015 INNER JOIN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*) =1) B ON I.LAT = B.LAT AND I.LON = B.LON;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH MAX_SALARY_CALC AS ( SELECT COMPANY_ID, MAX(SALARY) MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID ) SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, CASE WHEN M.MAX_SALARY<1000 THEN SALARY WHEN M.MAX_SALARY>=1000 AND M.MAX_SALARY<=10000 THEN ROUND((SALARY-((SALARY*24)/100)),0) ELSE ROUND((SALARY-((SALARY*49)/100)),0) END SALARY FROM SALARIES S INNER JOIN MAX_SALARY_CALC M ON S.COMPANY_ID=M.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH CTE AS ( SELECT VISIT_ID, CUSTOMER_ID FROM VISITS WHERE VISIT_ID NOT IN ( SELECT VISIT_ID FROM TRANSACTIONS) ) SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM CTE GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT(V.AUTHOR_ID) AS ID FROM VIEWS V WHERE V.AUTHOR_ID = V.VIEWER_ID ORDER BY ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN(SELECT DISTINCT(CUSTOMERS.ID) FROM CUSTOMERS,ORDERS WHERE CUSTOMERS.ID=ORDERS.CUSTOMERID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31') AND PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(EXTRA) AS REPORT_COUNT FROM (SELECT DISTINCT POST_ID, ACTION_DATE, ACTION, EXTRA FROM ACTIONS) T WHERE ACTION_DATE='2019-07-04' AND ACTION='REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID AS CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE V.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN ( SELECT CASE WHEN USER1_ID = 1 THEN USER2_ID WHEN USER2_ID = 1 THEN USER1_ID END AS FRIEND_ID FROM FRIENDSHIP WHERE USER1_ID = 1 OR USER2_ID = 1 ) AND PAGE_ID NOT IN ( SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1 );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN (SELECT VISIT_ID, COUNT(*) AS NUM_VISITS FROM TRANSACTIONS GROUP BY VISIT_ID) AS T ON VISITS.VISIT_ID = T.VISIT_ID WHERE T.NUM_VISITS IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH BASE AS ( SELECT CUSTOMER_ID, V.VISIT_ID AS V1, T.VISIT_ID AS V2, AMOUNT FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL ) SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM BASE GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE * U.UNITS)/SUM(U.UNITS), 2) AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND (U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT A.VIEWER_ID AS ID FROM VIEWS A, VIEWS B WHERE A.VIEW_DATE = B.VIEW_DATE AND A.VIEWER_ID = B.VIEWER_ID GROUP BY A.VIEWER_ID, A.VIEW_DATE HAVING COUNT(DISTINCT A.ARTICLE_ID) > 1 ORDER BY A.VIEWER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM (SELECT DISTINCT * FROM VIEWS) AS T GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(ARTICLE_ID)>1 ORDER BY VIEWER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID, DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID HAVING (COUNT(*) >= 3);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT EMAIL FROM (SELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) > 1) AS P;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES AS S INNER JOIN PRODUCT AS P USING(PRODUCT_ID) WHERE P.PRODUCT_NAME ='S8' AND S.BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES AS S INNER JOIN PRODUCT AS P USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN,COUNT(CASE WHEN DURATION/60 < 5 AND DURATION/60 >=0 THEN SESSION_ID END)AS TOTAL FROM SESSIONS UNION SELECT '[5-10>' AS BIN,COUNT(CASE WHEN DURATION/60 < 10 AND DURATION/60 >=5 THEN SESSION_ID END)AS TOTAL FROM SESSIONS UNION SELECT '[10-15>' AS BIN,COUNT(CASE WHEN DURATION/60 < 15 AND DURATION/60 >=10 THEN SESSION_ID END)AS TOTAL FROM SESSIONS UNION SELECT '15 OR MORE' AS BIN,COUNT(CASE WHEN DURATION/60 > 15 THEN SESSION_ID END)AS TOTAL FROM SESSIONS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA REPORT_REASON, COUNT(DISTINCT POST_ID) REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND EXTRA != 'NONE' AND ACTION = 'REPORT' GROUP BY ACTION, EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM (SELECT VIEWER_ID, VIEW_DATE, COUNT(DISTINCT ARTICLE_ID) AS NUM_ARTICLE FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID) > 1) TEMP1 ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH TEMP AS ( SELECT CUSTOMER_ID , MAX(CASE WHEN PRODUCT_NAME = 'A' THEN 1 ELSE 0 END) AS COL_A, MAX(CASE WHEN PRODUCT_NAME = 'B' THEN 1 ELSE 0 END) AS COL_B, MAX(CASE WHEN PRODUCT_NAME = 'C' THEN 1 ELSE 0 END) AS COL_C FROM ORDERS GROUP BY CUSTOMER_ID) SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN TEMP T ON C.CUSTOMER_ID = T.CUSTOMER_ID WHERE T.COL_A = 1 AND T.COL_B = 1 AND T.COL_C = 0;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE PAGE_ID NOT IN ( SELECT PAGE_ID FROM LIKES WHERE USER_ID=1) AND USER_ID IN (SELECT DISTINCT USER2_ID AS USER1_FRIENDS FROM (SELECT USER1_ID , USER2_ID FROM FRIENDSHIP UNION ALL SELECT USER2_ID AS USER1_ID, USER1_ID AS USER2_ID FROM FRIENDSHIP ) A WHERE USER1_ID =1 );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT SALES.PRODUCT_ID AS PRODUCT_ID, PRODUCT.PRODUCT_NAME AS PRODUCT_NAME FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID AND SALES.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE' OR PRODUCT_NAME = 'S8' GROUP BY BUYER_ID HAVING COUNT(DISTINCT PRODUCT_NAME) = 1 AND MIN(PRODUCT_NAME) = 'S8';\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT X.FIRSTNAME, X.LASTNAME, Y.CITY, Y.STATE FROM PERSON AS X LEFT JOIN ADDRESS AS Y ON X.PERSONID = Y.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT.PROJECT_ID, ROUND(AVG(EMPLOYEE.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT LEFT JOIN EMPLOYEE ON PROJECT.EMPLOYEE_ID = EMPLOYEE.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEES AS E LEFT JOIN EMPLOYEEUNI AS EU ON EU.ID = E.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE PRODUCT_NAME ='S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE PRODUCT_NAME ='IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT DISTINCT CASE WHEN USER1_ID =1 THEN USER2_ID WHEN USER2_ID =1 THEN USER1_ID END FROM FRIENDSHIP) AND PAGE_ID NOT IN (SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID =1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM ( SELECT PRODUCT_ID, (CASE WHEN STORE1 IS NOT NULL THEN STORE1 ELSE NULL END) STORE, STORE1 PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, (CASE WHEN STORE2 IS NOT NULL THEN STORE2 ELSE NULL END) STORE, STORE2 PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, (CASE WHEN STORE3 IS NOT NULL THEN STORE3 ELSE NULL END) STORE, STORE3 PRICE FROM PRODUCTS ) A WHERE A.PRICE IS NOT NULL ORDER BY A.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH CTE AS ( SELECT P.PRODUCT_ID, P.START_DATE, P.END_DATE, U.UNITS AS QUANTITY, (P.PRICE*U.UNITS) AS SELLING_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ) SELECT PRODUCT_ID, ROUND ((SUM(SELLING_PRICE) * 1.00 /SUM(QUANTITY)),2) AS AVERAGE_PRICE FROM CTE GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A, LOGINFO B WHERE A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS != B.IP_ADDRESS AND A.LOGIN <= B.LOGOUT AND B.LOGIN <= A.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT UNITSSOLD.PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AVERAGE_PRICE FROM UNITSSOLD LEFT JOIN PRICES ON UNITSSOLD.PURCHASE_DATE BETWEEN PRICES.START_DATE AND PRICES.END_DATE AND UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID GROUP BY UNITSSOLD.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN ( SELECT VISIT_ID FROM TRANSACTIONS ) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH VALID_LATLON AS (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) = 1) SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE AS I INNER JOIN VALID_LATLON AS V ON I.LAT = V.LAT AND I.LON=V.LON WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) != 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH CTE AS (SELECT P.PRODUCT_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31') SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM CTE);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016), 2) AS TIV_2016 FROM INSURANCE WHERE (LAT, LON) IN( SELECT LAT, LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(PID)=1 ) AND TIV_2015 IN( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(PID)>1 );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) T;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID , COUNT(DISTINCT(V.VISIT_ID)) AS COUNT_NO_TRANS FROM VISITS V WHERE VISIT_ID NOT IN ( SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN (SELECT DISTINCT(PRODUCT_ID) FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH CTE AS( SELECT P.PRODUCT_ID, PRICE, UNITS, (PRICE * UNITS) TOTAL_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) SELECT DISTINCT PRODUCT_ID, ROUND(SUM(TOTAL_PRICE) / SUM(UNITS),2) AVERAGE_PRICE FROM CTE GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE NOT PRODUCT_ID IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH CUST_A AS (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A'), CUST_B AS (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') SELECT CUST_A.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUST_A INNER JOIN CUST_B ON CUST_A.CUSTOMER_ID = CUST_B.CUSTOMER_ID INNER JOIN CUSTOMERS C ON CUST_A.CUSTOMER_ID = C.CUSTOMER_ID WHERE CUST_A.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT C.BUYER_ID FROM SALES C LEFT JOIN PRODUCT G ON C.PRODUCT_ID = G.PRODUCT_ID LEFT JOIN (SELECT BUYER_ID, PRODUCT_NAME FROM SALES A LEFT JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE')D ON C.BUYER_ID = D.BUYER_ID WHERE D.PRODUCT_NAME IS NULL AND G.PRODUCT_NAME = 'S8';\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES AS S INNER JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID,PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-30') AND PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME AS NAME, B.BONUS AS BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON B.EMPID = E.EMPID WHERE B.BONUS <1000 OR B.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM ( SELECT BUYER_ID, SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS TI, SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS TS8 FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY BUYER_ID ) A WHERE TI=0 AND TS8>0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A INNER JOIN LOGINFO B ON (A.ACCOUNT_ID=B.ACCOUNT_ID) AND (A.IP_ADDRESS<>B.IP_ADDRESS) WHERE A.LOGIN>=B.LOGIN AND A.LOGIN<=B.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] WITH T AS( SELECT DISTINCT * FROM COURSES) SELECT CLASS FROM T GROUP BY CLASS HAVING COUNT(CLASS) >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID ,ROUND(SUM(EXPERIENCE_YEARS)/COUNT(PROJECT_ID),2) AS AVERAGE_YEARS FROM PROJECT P LEFT JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(*) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(X1.X - X2.X)) AS SHORTEST FROM POINT X1 LEFT JOIN POINT X2 ON X1.X != X2.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH A AS (SELECT PRODUCT_NAME, BUYER_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID), B AS (SELECT DISTINCT BUYER_ID FROM A WHERE PRODUCT_NAME = 'IPHONE') SELECT DISTINCT BUYER_ID FROM A WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT * FROM B);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM PRODUCT INNER JOIN (SELECT DISTINCT(S1.PRODUCT_ID) FROM SALES AS S1 LEFT JOIN (SELECT DISTINCT(S2.PRODUCT_ID) FROM SALES AS S2 WHERE S2.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31') S3 ON S1.PRODUCT_ID = S3.PRODUCT_ID WHERE S3.PRODUCT_ID IS NULL ) AS TEMP ON PRODUCT.PRODUCT_ID = TEMP.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND S.PRODUCT_ID NOT IN (SELECT S.PRODUCT_ID FROM SALES S WHERE S.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT AND L1.IP_ADDRESS != L2.IP_ADDRESS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH T AS ( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID ) SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND((CASE WHEN T.MAX_SALARY < 1000 THEN S.SALARY WHEN T.MAX_SALARY>= 1000 AND T.MAX_SALARY <= 10000 THEN S.SALARY * 0.76 ELSE S.SALARY * 0.51 END),0)AS SALARY FROM SALARIES S LEFT JOIN T ON S.COMPANY_ID = T.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL AS EMAIL FROM( SELECT EMAIL, COUNT(EMAIL) AS EMAIL_COUNT FROM PERSON GROUP BY EMAIL ) AS PERSON2 WHERE EMAIL_COUNT > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID = 1 THEN USER2_ID WHEN USER2_ID = 1 THEN USER1_ID END AS USER_ID3 FROM FRIENDSHIP) A JOIN LIKES L ON A.USER_ID3 = L.USER_ID AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH R AS(SELECT V.VISIT_ID,V.CUSTOMER_ID,T.TRANSACTION_ID AS TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID=T.VISIT_ID) SELECT CUSTOMER_ID, COUNT(VISIT_ID) AS COUNT_NO_TRANS FROM R WHERE TRANS IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(TOTAL_AMOUNT/CNT,2) AS AVERAGE_YEARS FROM ( SELECT PROJECT_ID , SUM(EXPERIENCE_YEARS) AS TOTAL_AMOUNT , COUNT(1) AS CNT FROM PROJECT A INNER JOIN EMPLOYEE B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY PROJECT_ID )A;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1, LOGINFO L2 WHERE L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS != L2.IP_ADDRESS AND L2.LOGIN BETWEEN L1.LOGIN AND L1.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH PRICE_LOOKUP AS (SELECT UNITSSOLD.*, UNITS*PRICE AS TOTAL_PRICE FROM UNITSSOLD LEFT JOIN PRICES ON UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID AND UNITSSOLD.PURCHASE_DATE >= PRICES.START_DATE AND UNITSSOLD.PURCHASE_DATE <= PRICES.END_DATE) SELECT PRODUCT_ID, ROUND(SUM(TOTAL_PRICE) / SUM(UNITS), 2) AS AVERAGE_PRICE FROM PRICE_LOOKUP GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT AUTHOR_ID ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY 1 ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT (LIKES.PAGE_ID) AS RECOMMENDED_PAGE FROM FRIENDSHIP F JOIN LIKES ON F.USER2_ID=LIKES.USER_ID WHERE F.USER1_ID=1 AND LIKES.PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1) UNION SELECT DISTINCT (LIKES.PAGE_ID) AS RECOMMENDED_PAGE FROM FRIENDSHIP F JOIN LIKES ON F.USER1_ID=LIKES.USER_ID WHERE F.USER2_ID=1 AND LIKES.PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT.PROJECT_ID,ROUND(AVG(EMPLOYEE.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT JOIN EMPLOYEE ON PROJECT.EMPLOYEE_ID=EMPLOYEE.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT CUSTOMERS.NAME CUSTOMERS FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMERID WHERE ORDERS.CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL AS EMAIL FROM (SELECT EMAIL, COUNT(*) FROM PERSON GROUP BY EMAIL HAVING COUNT(*) >= 2) Q1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT AUTHOR_ID ID FROM VIEWS GROUP BY AUTHOR_ID HAVING SUM(CASE WHEN AUTHOR_ID = VIEWER_ID THEN 1 ELSE 0 END) >= 1 ORDER BY 1 ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN( SELECT DISTINCT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT O.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE C.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND C.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND C.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME AS CUSTOMERS FROM CUSTOMERS C LEFT JOIN ORDERS O ON O.CUSTOMERID = C.ID WHERE CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID AS PRODUCT_ID, ROUND(SUM(P.PRICE * U.UNITS) / SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON ( U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ) GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM ( SELECT S.ID, S.NAME AS NAME, D.NAME AS DEPARTMENT FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID ) TMP WHERE DEPARTMENT IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID IN( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING '2019-01-01'<= MIN(SALE_DATE) AND MAX(SALE_DATE) <='2019-03-31' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN (SELECT T.VISIT_ID FROM TRANSACTIONS T) GROUP BY V.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] SELECT C1.NAME FROM CUSTOMER AS C1 WHERE C1.REFEREE_ID IS NULL OR C1.REFEREE_ID != 2;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH PAGES_I_LIKED AS ( SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1 ), MY_FRIENDS AS ( SELECT CASE WHEN USER1_ID = 1 THEN USER2_ID ELSE USER1_ID END AS USER_ID FROM FRIENDSHIP WHERE USER1_ID = 1 OR USER2_ID = 1 ) SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM LIKES AS L JOIN MY_FRIENDS AS MF ON MF.USER_ID = L.USER_ID WHERE L.PAGE_ID NOT IN ( SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1 );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN TEMP.MAX_SAL < 1000 THEN S.SALARY WHEN 999 < TEMP.MAX_SAL AND TEMP.MAX_SAL< 9999 THEN S.SALARY - S.SALARY*0.24 WHEN TEMP.MAX_SAL > 10000 THEN S.SALARY - S.SALARY*0.49 END,0) AS SALARY FROM (SELECT COMPANY_ID, MAX(SALARY) AS MAX_SAL FROM SALARIES GROUP BY COMPANY_ID ) AS TEMP JOIN SALARIES S ON TEMP.COMPANY_ID = S.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(SUM(EXPERIENCE_YEARS)/COUNT(E.EMPLOYEE_ID),2) AS AVERAGE_YEARS FROM PROJECT AS P JOIN EMPLOYEE AS E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT PAGE_ID FROM LIKES L INNER JOIN FRIENDSHIP F1 ON F1.USER1_ID = L.USER_ID AND F1.USER2_ID = 1 UNION SELECT PAGE_ID FROM LIKES L INNER JOIN FRIENDSHIP F2 ON F2.USER2_ID = L.USER_ID AND F2.USER1_ID = 1) TMP WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT T1.PRODUCT_ID FROM PRODUCT AS T1 INNER JOIN SALES AS T2 ON T1.PRODUCT_ID = T2.PRODUCT_ID WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRODUCT_ID, ROUND(SUM(UNITS * PRICE) / SUM(UNITS), 2) AVERAGE_PRICE FROM ( SELECT US.PRODUCT_ID, US.PURCHASE_DATE, US.UNITS, P.PRICE FROM UNITSSOLD US LEFT JOIN PRICES P ON US.PRODUCT_ID = P.PRODUCT_ID AND (US.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) ) T GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] (SELECT PRODUCT_ID, 'STORE1' AS STORE , STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL ) UNION ALL (SELECT PRODUCT_ID, 'STORE2' AS STORE , STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL ) UNION ALL (SELECT PRODUCT_ID, 'STORE3' AS STORE , STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME='S8' THEN 1 ELSE 0 END)>0 AND SUM(CASE WHEN P.PRODUCT_NAME='IPHONE' THEN 1 ELSE 0 END)=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT(L1.ACCOUNT_ID) FROM LOGINFO AS L1 JOIN LOGINFO AS L2 ON L1.ACCOUNT_ID=L2.ACCOUNT_ID AND L1.IP_ADDRESS!=L2.IP_ADDRESS WHERE (L2.LOGIN BETWEEN L1.LOGIN AND L1.LOGOUT ) OR (L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE * U.UNITS)/SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID , MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(MINI) AS SHORTEST FROM ( SELECT ABS(P1.X-P2.X) AS MINI FROM POINT P1, POINT P2 WHERE P1.X != P2.X) T1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT P.FIRSTNAME, P.LASTNAME, A.CITY, A.STATE FROM PERSON P LEFT JOIN ADDRESS A ON A.PERSONID = P.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT ID1 AS ACCOUNT_ID FROM ( SELECT A.ACCOUNT_ID AS ID1,B.ACCOUNT_ID AS ID2, A.LOGIN AS LOGIN1,B.LOGIN AS LOGIN2,A.LOGOUT AS LOGOUT1,B.LOGOUT AS LOGOUT2 FROM LOGINFO A INNER JOIN LOGINFO B ON A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS<>B.IP_ADDRESS ) A WHERE (LOGIN2 <= LOGOUT1 AND LOGIN2 >= LOGIN1) OR (LOGOUT2 <= LOGOUT1 AND LOGOUT2 >= LOGIN1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(*) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID=T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON T.VISIT_ID = V.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT P.EMAIL FROM PERSON AS P GROUP BY P.EMAIL HAVING COUNT(1)>1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, STORE, PRICE FROM ( (SELECT PRODUCT_ID, 'STORE1' AS STORE, CASE WHEN STORE1 IS NOT NULL THEN STORE1 ELSE NULL END AS PRICE FROM PRODUCTS ) UNION (SELECT PRODUCT_ID, 'STORE2' AS STORE, CASE WHEN STORE2 IS NOT NULL THEN STORE2 ELSE NULL END AS PRICE FROM PRODUCTS) UNION (SELECT PRODUCT_ID, 'STORE3' AS STORE, CASE WHEN STORE3 IS NOT NULL THEN STORE3 ELSE NULL END AS PRICE FROM PRODUCTS ) ) A WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT AS P JOIN SALES AS S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(EXTRA) AS REPORT_COUNT FROM (SELECT DISTINCT(POST_ID), ACTION_DATE , ACTION , EXTRA FROM ACTIONS) AS Y WHERE ACTION_DATE='2019-07-04' AND ACTION='REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS AS P1 WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS AS P1 WHERE STORE2 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS AS P1 WHERE STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE PRODUCT_NAME='S8') AND BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE (LAT, LON) NOT IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*)>1) AND TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL ORDER BY 1,2 ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT CUSTOMERS.NAME AS CUSTOMERS FROM CUSTOMERS LEFT JOIN ORDERS ON ORDERS.CUSTOMERID = CUSTOMERS.ID WHERE ORDERS.CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P, SALES S WHERE P.PRODUCT_ID=S.PRODUCT_ID AND S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND S.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] SELECT INSTALL_DT, COUNT(PLAYER_ID) AS INSTALLS, ROUND(COUNT(NEXT_DAY) / COUNT(PLAYER_ID), 2) AS DAY1_RETENTION FROM (SELECT A1.PLAYER_ID, A1.INSTALL_DT, A2.EVENT_DATE AS NEXT_DAY FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS INSTALL_DT FROM ACTIVITY GROUP BY PLAYER_ID) A1 LEFT JOIN ACTIVITY A2 ON A1.PLAYER_ID = A2.PLAYER_ID AND A2.EVENT_DATE = A1.INSTALL_DT + 1) T GROUP BY INSTALL_DT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH TAX_RATE AS ( SELECT COMPANY_ID, CASE WHEN MAX(SALARY) < 1000 THEN 0 WHEN MAX(SALARY) > 1000 AND MAX(SALARY) < 10000 THEN 24/100 WHEN MAX(SALARY) > 10000 THEN 49/100 END AS TAX_RATE FROM SALARIES GROUP BY COMPANY_ID ) SELECT E.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY - SALARY*TAX_RATE) AS SALARY FROM SALARIES E JOIN TAX_RATE T ON E.COMPANY_ID = T.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(VISIT_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS GROUP BY VISIT_ID ) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT A.ID, A.NAME FROM STUDENTS A LEFT JOIN DEPARTMENTS B ON A.DEPARTMENT_ID = B.ID WHERE A.DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT A.PRODUCT_ID, B.PRODUCT_NAME FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID GROUP BY A.PRODUCT_ID, B.PRODUCT_NAME HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(SALESAMOUNT) / SUM(TOTALSOLD), 2 ) AS AVERAGE_PRICE FROM PRICES P INNER JOIN ( SELECT P.PRODUCT_ID AS P_ID , UNITS AS TOTALSOLD , P.PRICE AS PRICING , UNITS * P.PRICE AS SALESAMOUNT FROM PRICES P INNER JOIN UNITSSOLD U ON P.PRODUCT_ID=U.PRODUCT_ID WHERE U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ) AS SALES ON P.PRODUCT_ID=SALES.P_ID GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT LASTNAME, FIRSTNAME, CITY, STATE FROM PERSON LEFT JOIN ADDRESS ON PERSON.PERSONID = ADDRESS.PERSONID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN , COUNT(CASE WHEN DURATION < 300 THEN SESSION_ID END) AS TOTAL FROM SESSIONS UNION SELECT '[5-10>' AS BIN , COUNT(CASE WHEN DURATION >= 300 AND DURATION < 600 THEN SESSION_ID END) AS TOTAL FROM SESSIONS UNION SELECT '[10-15>' AS BIN , COUNT(CASE WHEN DURATION >= 600 AND DURATION < 900 THEN SESSION_ID END) AS TOTAL FROM SESSIONS UNION SELECT '15 OR MORE' AS BIN , COUNT(CASE WHEN DURATION >= 900 THEN SESSION_ID END) AS TOTAL FROM SESSIONS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE1 AS ( SELECT COMPANY_ID,MAX(SALARY) AS MAX_SAL FROM SALARIES GROUP BY COMPANY_ID ), CTE2 AS( SELECT COMPANY_ID AS CID, CASE WHEN MAX_SAL<1000 THEN 0 WHEN MAX_SAL>=1000 AND MAX_SAL<=10000 THEN 24 ELSE 49 END AS INTREST FROM CTE1 ) SELECT COMPANY_ID, EMPLOYEE_ID,EMPLOYEE_NAME,ROUND(SALARY-((SALARY*INTREST)/100)) AS SALARY FROM SALARIES LEFT JOIN CTE2 ON CTE2.CID=COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH CTE AS (SELECT VIEWER_ID AS ID, COUNT(DISTINCT ARTICLE_ID) AS CNT FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE) SELECT DISTINCT ID FROM CTE WHERE CNT >1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH SALES_WITHIN_TIMEFRAME AS ( SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' ), SALES_OUTSIDE_TIMEFRAME AS ( SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' ) SELECT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES_WITHIN_TIMEFRAME S LEFT JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN(SELECT * FROM SALES_OUTSIDE_TIMEFRAME);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS <> L2.IP_ADDRESS AND (L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT OR L1.LOGOUT BETWEEN L2.LOGIN AND L2.LOGOUT);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT V.VIEWER_ID AS ID FROM VIEWS AS V GROUP BY V.VIEW_DATE, V.VIEWER_ID HAVING COUNT(DISTINCT V.ARTICLE_ID) > 1 ORDER BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(P.PRICE * U.UNITS) / SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO AS A JOIN LOGINFO AS B ON A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS != B.IP_ADDRESS WHERE (A.LOGIN BETWEEN B.LOGIN AND B.LOGOUT) OR (B.LOGIN BETWEEN A.LOGIN AND A.LOGOUT) ORDER BY ACCOUNT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH SA AS (SELECT DISTINCT S.BUYER_ID, P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME IN ('S8', 'IPHONE')) SELECT BUYER_ID FROM SA WHERE BUYER_ID NOT IN (SELECT DISTINCT BUYER_ID FROM SA WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INV.INVOICE_ID, C.CUSTOMER_NAME, INV.PRICE, COALESCE(CT.CONTACTS_CNT, 0) CONTACTS_CNT, COALESCE(TCT.TRUSTED_CONTACTS_CNT,0) TRUSTED_CONTACTS_CNT FROM INVOICES INV LEFT JOIN (SELECT USER_ID,COUNT(CONTACT_NAME) AS CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID) CT ON INV.USER_ID=CT.USER_ID LEFT JOIN (SELECT USER_ID,COUNT(CONTACT_NAME) AS TRUSTED_CONTACTS_CNT FROM CONTACTS WHERE CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) GROUP BY USER_ID) TCT ON INV.USER_ID=TCT.USER_ID LEFT JOIN CUSTOMERS C ON C.CUSTOMER_ID=INV.USER_ID ORDER BY INV.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT EMPLOYEE.NAME,BONUS FROM EMPLOYEE LEFT JOIN BONUS ON (EMPLOYEE.EMPID=BONUS.EMPID) WHERE BONUS.BONUS<1000 OR BONUS.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT T USING(PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE1 AS( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID), CTE2 AS( SELECT S.*, CTE1.MAX_SALARY FROM SALARIES S LEFT JOIN CTE1 ON S.COMPANY_ID = CTE1.COMPANY_ID) SELECT COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(CASE WHEN MAX_SALARY < 1000 AND MAX_SALARY > 0 THEN SALARY WHEN MAX_SALARY < 10000 AND MAX_SALARY >= 1000 THEN SALARY * 0.76 ELSE SALARY * 0.51 END, 0) AS SALARY FROM CTE2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(U.UNITS * P.PRICE)/ SUM(U.UNITS), 2) AVERAGE_PRICE FROM PRICES P INNER JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND (U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] WITH CTE_FINAL AS ( SELECT NAME FROM CUSTOMER WHERE REFEREE_ID != 2 OR REFEREE_ID IS NULL ) SELECT * FROM CTE_FINAL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM ( SELECT EMAIL,COUNT(ID) AS EMCOUNT FROM PERSON GROUP BY EMAIL ) AS T WHERE T.EMCOUNT != 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT TAB.EMAIL FROM (SELECT EMAIL, COUNT(ID) AS NUM FROM PERSON GROUP BY EMAIL HAVING COUNT(ID) > 1) AS TAB;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT A.BUYER_ID FROM SALES A LEFT JOIN PRODUCT B USING(PRODUCT_ID) GROUP BY A.BUYER_ID HAVING SUM(CASE WHEN B.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN B.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS (SELECT * FROM SALES LEFT JOIN PRODUCT USING (PRODUCT_ID)) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME='S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(C.TIV_2016) AS TIV_2016 FROM ( SELECT A.PID, A.TIV_2015,A.TIV_2016,A.LAT,A.LON FROM INSURANCE A INNER JOIN INSURANCE B ON A.TIV_2015 = B.TIV_2015 AND A.PID != B.PID GROUP BY A.PID, A.TIV_2015,A.TIV_2016,A.LAT,A.LON )C LEFT JOIN INSURANCE D ON (C.LAT = D.LAT) AND (C.LON = D.LON) AND C.PID != D.PID WHERE D.PID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT P.EMAIL FROM PERSON P GROUP BY EMAIL HAVING COUNT(EMAIL) > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID,COUNT(V.VISIT_ID) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON (T.VISIT_ID=V.VISIT_ID) WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(P1.X - P2.X) AS SHORTEST FROM POINT P1, POINT P2 WHERE P1.X <> P2.X ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A JOIN (SELECT PLAYER_ID, MIN(EVENT_DATE) AS M_DATE FROM ACTIVITY GROUP BY PLAYER_ID) T ON A.PLAYER_ID=T.PLAYER_ID AND A.EVENT_DATE=T.M_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V WHERE V.VISIT_ID NOT IN ( SELECT DISTINCT T.VISIT_ID FROM TRANSACTIONS AS T ) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AVERAGE_PRICE FROM (SELECT P.PRODUCT_ID, PRICE, UNITS FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) A GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID , C0.CUSTOMER_NAME, PRICE, COUNT(C1.CONTACT_EMAIL) AS CONTACTS_CNT, COUNT(C2.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES I INNER JOIN CUSTOMERS C0 ON I.USER_ID = C0.CUSTOMER_ID LEFT OUTER JOIN CONTACTS C1 ON C0.CUSTOMER_ID = C1.USER_ID LEFT OUTER JOIN CUSTOMERS C2 ON C2.EMAIL = C1.CONTACT_EMAIL GROUP BY INVOICE_ID , C0.CUSTOMER_NAME , PRICE ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN ( SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.NAME, U.UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI U ON E.ID = U.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S1.COMPANY_ID, S1.EMPLOYEE_ID, S1.EMPLOYEE_NAME, CASE WHEN TAB.MAXSALARY < 1000 THEN ROUND(S1.SALARY) WHEN TAB.MAXSALARY >= 1000 AND TAB.MAXSALARY < 10000 THEN ROUND(0.76*S1.SALARY) ELSE ROUND(0.51*S1.SALARY) END SALARY FROM SALARIES S1 INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAXSALARY FROM SALARIES GROUP BY COMPANY_ID) TAB ON TAB.COMPANY_ID = S1.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT FIN.CUSTOMER_ID, COUNT(FIN.CUSTOMER_ID) COUNT_NO_TRANS FROM (SELECT V.CUSTOMER_ID AS CUSTOMER_ID FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL) FIN GROUP BY FIN.CUSTOMER_ID ORDER BY COUNT(FIN.CUSTOMER_ID) DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM (SELECT TRANSACTIONS.VISIT_ID AS VISITSID, VISITS.CUSTOMER_ID AS CUSTOMER_ID, TRANSACTIONS.TRANSACTION_ID, TRANSACTIONS.AMOUNT AS AMOUNT FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE AMOUNT IS NULL) AS A GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.NAME,EU.UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EU ON EU.ID=E.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CONTACTS_COUNT AS ( SELECT USER_ID, COUNT(CONTACT_EMAIL) AS TOTAL_CONTACTS FROM CONTACTS GROUP BY USER_ID ), TRUSTED_CONTACT_COUNTS AS ( SELECT USER_ID, COUNT(CONTACT_EMAIL) AS TOTAL_TRUTSED_CONTACTS FROM ( SELECT A.CUSTOMER_ID, A.EMAIL, B.USER_ID, B.CONTACT_EMAIL FROM CUSTOMERS A INNER JOIN CONTACTS B ON A.EMAIL=B.CONTACT_EMAIL ) T1 GROUP BY USER_ID ), INVOICEINFO_JOINED AS ( SELECT INVOICE_ID, PRICE, T1.USER_ID, (CASE WHEN TOTAL_CONTACTS IS NOT NULL THEN TOTAL_CONTACTS ELSE 0 END) AS CONTACTS_CNT , (CASE WHEN TOTAL_TRUTSED_CONTACTS IS NOT NULL THEN TOTAL_TRUTSED_CONTACTS ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM ( SELECT INVOICE_ID, PRICE, A.USER_ID, TOTAL_CONTACTS FROM INVOICES A LEFT JOIN CONTACTS_COUNT B ON A.USER_ID=B.USER_ID) T1 LEFT JOIN TRUSTED_CONTACT_COUNTS T2 ON T1.USER_ID=T2.USER_ID ) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICEINFO_JOINED A LEFT JOIN CUSTOMERS B ON A.USER_ID=B.CUSTOMER_ID ORDER BY INVOICE_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND ACTION='REPORT'GROUP BY EXTRA HAVING EXTRA IS NOT NULL ORDER BY REPORT_REASON;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT COALESCE(U.UNIQUE_ID,NULL) AS UNIQUE_ID , NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI U ON E.ID=U.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES S WHERE SALE_DATE > CAST('2019-03-31' AS DATE) OR SALE_DATE < CAST('2019-01-01' AS DATE) );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) TOTAL FROM SESSIONS WHERE (DURATION/60) BETWEEN 0 AND 5 UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) TOTAL FROM SESSIONS WHERE (DURATION/60) BETWEEN 5 AND 10 UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) TOTAL FROM SESSIONS WHERE (DURATION/60) BETWEEN 10 AND 15 UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) TOTAL FROM SESSIONS WHERE (DURATION/60)>= 15;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT P INNER JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT A.NAME, A.ID FROM STUDENTS A LEFT JOIN DEPARTMENTS B ON A.DEPARTMENT_ID=B.ID WHERE B.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM ( SELECT CLASS, COUNT(CLASS) AS CLASS_B FROM COURSES GROUP BY CLASS) AS CL WHERE CL.CLASS_B>=5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EU.UNIQUE_ID , E.NAME FROM EMPLOYEES E LEFT OUTER JOIN EMPLOYEEUNI EU ON E.ID = EU.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A, LOGINFO B WHERE A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS != B.IP_ADDRESS AND B.LOGIN >= A.LOGIN AND B.LOGIN <= A.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT A.PRODUCT_ID FROM PRODUCT AS A JOIN SALES AS B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.SALE_DATE < '2019-01-01' OR B.SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V2.AUTHOR_ID AS ID FROM VIEWS V1 INNER JOIN VIEWS V2 ON V1.AUTHOR_ID = V2.VIEWER_ID AND V1.ARTICLE_ID = V2.ARTICLE_ID ORDER BY ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH T1 AS( SELECT P.PRODUCT_ID AS PRODUCT_ID, S.UNITS AS QUANTITY, P.PRICE*S.UNITS AS SALES FROM PRICES P LEFT JOIN UNITSSOLD S ON P.PRODUCT_ID=S.PRODUCT_ID AND S.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ) SELECT T1.PRODUCT_ID AS PRODUCT_ID, ROUND(SUM(T1.SALES)/SUM(T1.QUANTITY),2) AS AVERAGE_PRICE FROM T1 GROUP BY T1.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA REPORT_REASON, COUNT(DISTINCT POST_ID) REPORT_COUNT FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT X.CLASS FROM (SELECT CLASS, COUNT(STUDENT) FROM COURSES GROUP BY CLASS HAVING COUNT(STUDENT)>=5) X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH F AS ( SELECT USER1_ID U1, USER2_ID U2 FROM FRIENDSHIP UNION SELECT USER2_ID U1, USER1_ID U2 FROM FRIENDSHIP ) SELECT DISTINCT B.PAGE_ID RECOMMENDED_PAGE FROM F A JOIN LIKES B ON A.U1 = 1 AND A.U2 = B.USER_ID WHERE B.PAGE_ID NOT IN (SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(SUM(CASE WHEN A.EVENT_DATE + 1 = B.EVENT_DATE THEN 1 ELSE 0 END)/COUNT(DISTINCT A.PLAYER_ID), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS A JOIN ACTIVITY AS B ON A.PLAYER_ID = B.PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME AS CUSTOMERS FROM CUSTOMERS AS C LEFT JOIN ORDERS AS O ON C.ID=O.CUSTOMERID WHERE CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS CUST LEFT JOIN ORDERS ORD ON CUST.ID = ORD.CUSTOMERID WHERE ORD.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S WHERE NOT S.DEPARTMENT_ID IN (SELECT D.ID FROM DEPARTMENTS D);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT STUDENTS.ID,STUDENTS.NAME FROM STUDENTS LEFT OUTER JOIN DEPARTMENTS ON STUDENTS.DEPARTMENT_ID=DEPARTMENTS.ID WHERE DEPARTMENTS.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH T AS ( SELECT VIEW_DATE, VIEWER_ID ID,COUNT(DISTINCT(ARTICLE_ID)) C FROM VIEWS GROUP BY VIEW_DATE,VIEWER_ID ) SELECT DISTINCT(ID) FROM T WHERE C>1 ORDER BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE PAGE_ID IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID IN ((SELECT USER1_ID AS FRIEND_ID FROM FRIENDSHIP WHERE USER2_ID = 1) UNION (SELECT USER2_ID AS FRIEND_ID FROM FRIENDSHIP WHERE USER1_ID = 1)) ) AND PAGE_ID NOT IN ( SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT TMP.EMAIL AS EMAIL FROM ( SELECT COUNT(*) AS DUPLICATES, EMAIL FROM PERSON GROUP BY EMAIL) AS TMP WHERE TMP.DUPLICATES >1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT B.PLAYER_ID,B.DEVICE_ID FROM (SELECT PLAYER_ID ,MIN(EVENT_DATE) AS DT FROM ACTIVITY GROUP BY PLAYER_ID )A JOIN ACTIVITY B ON A.PLAYER_ID=B.PLAYER_ID AND A.DT=B.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] WITH CTE AS (SELECT PLAYER_ID,MIN(EVENT_DATE) AS FIRST_LOG FROM ACTIVITY GROUP BY PLAYER_ID) SELECT ROUND(COUNT(DISTINCT A.PLAYER_ID)/(SELECT COUNT(DISTINCT PLAYER_ID) FROM ACTIVITY),2) AS FRACTION FROM ACTIVITY A INNER JOIN CTE ON A.PLAYER_ID = CTE.PLAYER_ID AND A.EVENT_DATE = CTE.FIRST_LOG + 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT DISTINCT U.PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(VIEWER_ID) >= 2 AND COUNT(DISTINCT ARTICLE_ID) >=2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T USING (VISIT_ID) WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES WHERE BUYER_ID IN ( SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' GROUP BY BUYER_ID) AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE' GROUP BY BUYER_ID) GROUP BY BUYER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN ( SELECT A.ID FROM CUSTOMERS A INNER JOIN ORDERS B ON A.ID = B.CUSTOMERID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT CASE WHEN SUM(SINGLE_TAG) = NULL THEN NULL ELSE MAX(SINGLE_TAG) END AS NUM FROM (SELECT NUM, CASE WHEN COUNT(*) = 1 THEN NUM ELSE NULL END AS SINGLE_TAG FROM MYNUMBERS GROUP BY NUM) N;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT DISTINCT ABS(A.X-B.X) AS SHORTEST FROM POINT A, POINT B WHERE ABS(A.X-B.X) >0 ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS (SELECT BUYER_ID, CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END AS SS, CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END AS IPHONE FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID ) SELECT BUYER_ID FROM CTE GROUP BY BUYER_ID HAVING SUM(SS)>=1 AND SUM(IPHONE) =0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID,EVENT_DATE) IN (SELECT PLAYER_ID, MIN(EVENT_DATE)Y FROM ACTIVITY GROUP BY PLAYER_ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(U.UNITS*P.PRICE)/SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT A.PRODUCT_ID,B.PRODUCT_NAME FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID=B.PRODUCT_ID WHERE A.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND A.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE>'2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH A AS (SELECT V.CUSTOMER_ID, V.VISIT_ID, T.TRANSACTION_ID, T.AMOUNT FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL) SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM A GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID ORDER BY EVENT_DATE );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT O.CUSTOMER_ID, C.CUSTOMER_NAME FROM ORDERS O JOIN CUSTOMERS C ON C.CUSTOMER_ID=O.CUSTOMER_ID WHERE O.PRODUCT_NAME='A' AND O.CUSTOMER_ID IN (SELECT O.CUSTOMER_ID FROM ORDERS O WHERE O.PRODUCT_NAME='B') AND O.CUSTOMER_ID NOT IN (SELECT O.CUSTOMER_ID FROM ORDERS O WHERE O.PRODUCT_NAME='C');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A, LOGINFO B WHERE A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS != B.IP_ADDRESS AND (A.LOGIN BETWEEN B.LOGIN AND B.LOGOUT);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT(A.AUTHOR_ID) AS ID FROM VIEWS A INNER JOIN VIEWS B ON A.AUTHOR_ID = B.VIEWER_ID AND A.ARTICLE_ID = B.ARTICLE_ID ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T AS( SELECT BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID =P.PRODUCT_ID WHERE PRODUCT_NAME='S8'), T1 AS( SELECT BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID =P.PRODUCT_ID WHERE PRODUCT_NAME='IPHONE') SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT T.BUYER_ID FROM T) AND BUYER_ID NOT IN (SELECT T1.BUYER_ID FROM T1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT BUYER_ID, PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME='IPHONE') AND BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME='S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN ( SELECT S.BUYER_ID FROM PRODUCT AS P, SALES AS S WHERE P.PRODUCT_ID = S.PRODUCT_ID AND P.PRODUCT_NAME = 'S8' ) AND BUYER_ID NOT IN ( SELECT S.BUYER_ID FROM PRODUCT AS P, SALES AS S WHERE P.PRODUCT_ID = S.PRODUCT_ID AND P.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(*) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID=PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN ( SELECT DISTINCT BUYER_ID FROM SALES JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH CTE AS ( SELECT P.PRODUCT_ID, CASE WHEN U.PURCHASE_DATE BETWEEN START_DATE AND END_DATE THEN UNITS ELSE 0 END AS UNITS_SOLD, PRICE FROM PRICES P INNER JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID) SELECT PRODUCT_ID, ROUND((SUM(PRICE * UNITS_SOLD) / SUM(UNITS_SOLD)),2) AS AVERAGE_PRICE FROM CTE GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT VIEWER_ID ID FROM ( SELECT VIEWER_ID, VIEW_DATE, COUNT(DISTINCT ARTICLE_ID) ARTICLE_CNT FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE ) TB GROUP BY VIEWER_ID HAVING MAX(ARTICLE_CNT) > 1 ORDER BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT T.EXTRA AS REPORT_REASON, COUNT(DISTINCT T.POST_ID) AS REPORT_COUNT FROM ( SELECT POST_ID, EXTRA FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' ) T GROUP BY T.EXTRA;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] WITH CTE AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS INSTALL_DT FROM ACTIVITY GROUP BY PLAYER_ID ) SELECT INSTALL_DT, COUNT(DISTINCT A.PLAYER_ID) AS INSTALLS, ROUND(COUNT(B.PLAYER_ID)/COUNT(A.PLAYER_ID),2) DAY1_RETENTION FROM CTE A LEFT JOIN ACTIVITY B ON A.PLAYER_ID = B.PLAYER_ID AND A.INSTALL_DT +1 = B.EVENT_DATE GROUP BY A.INSTALL_DT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT('TIMESTAMP') >= 3;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH A AS( SELECT S.PRODUCT_ID, S.BUYER_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM A WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM A WHERE PRODUCT_NAME = 'IPHONE') AND BUYER_ID IN (SELECT BUYER_ID FROM A WHERE PRODUCT_NAME = 'S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM ORDERS O RIGHT JOIN CUSTOMERS C ON O.CUSTOMERID = C.ID WHERE O.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID ORDER BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRODUCT_ID,ROUND(SUM(UNITS*PRICE)/SUM(UNITS),2) AS AVERAGE_PRICE FROM (SELECT PRICES.PRODUCT_ID AS PRODUCT_ID,UNITS,PRICE FROM PRICES JOIN UNITSSOLD ON PRICES.PRODUCT_ID = UNITSSOLD.PRODUCT_ID AND PURCHASE_DATE BETWEEN START_DATE AND END_DATE)T1 GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(P1.X-P2.X)) AS SHORTEST FROM POINT AS P1 JOIN POINT AS P2 ON P1.X <> P2.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COUNT(DISTINCT(CO.CONTACT_NAME)) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_NAME IN ( SELECT DISTINCT(CUSTOMER_NAME) FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS CO ON CO.USER_ID = C.CUSTOMER_ID GROUP BY INVOICE_ID, CUSTOMER_NAME, PRICE ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH SOLD AS ( SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' ), NOT_SOLD AS ( SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' ) SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM NOT_SOLD) AND PRODUCT_ID IN (SELECT PRODUCT_ID FROM SOLD);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL AS EMAIL FROM( SELECT EMAIL, COUNT(EMAIL) FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1 ) AS EMAIL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE DURATION < 300 UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE DURATION >= 300 AND DURATION < 600 UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE DURATION >= 600 AND DURATION < 900 UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE DURATION >= 900;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID ID FROM (SELECT VIEWER_ID, VIEW_DATE, COUNT(DISTINCT ARTICLE_ID) CNT FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE) TEMP WHERE CNT > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS (SELECT * FROM SALES LEFT JOIN PRODUCT USING (PRODUCT_ID)) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME='IPHONE') AND BUYER_ID IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME='S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS USING(VISIT_ID) WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY VIEWER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH CTE AS (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31'), CTE1 AS (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31') SELECT PRODUCT_ID,PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID IN (SELECT * FROM CTE) AND PRODUCT_ID NOT IN (SELECT * FROM CTE1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON TRANSACTIONS.VISIT_ID=VISITS.VISIT_ID WHERE TRANSACTIONS.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT A.PRODUCT_ID,ROUND(SUM(A.PRICE*B.UNITS)/SUM(B.UNITS),2) AS AVERAGE_PRICE FROM PRICES A JOIN UNITSSOLD B ON A.PRODUCT_ID=B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE GROUP BY A.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT(POST_ID)) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' AND EXTRA IS NOT NULL GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE, COUNT(C.USER_ID) AS CONTACTS_CNT, COUNT(D.CUSTOMER_NAME) AS TRUSTED_CONTACTS_CNT FROM INVOICES A LEFT JOIN CUSTOMERS B ON A.USER_ID = B.CUSTOMER_ID LEFT JOIN CONTACTS C ON B.CUSTOMER_ID = C.USER_ID LEFT JOIN CUSTOMERS D ON D.CUSTOMER_NAME = C.CONTACT_NAME GROUP BY A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE ORDER BY A.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT COURSES.CLASS FROM COURSES GROUP BY COURSES.CLASS HAVING COUNT(DISTINCT COURSES.STUDENT) >= 5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH T1 AS ( SELECT P.PRODUCT_NAME, P.PRODUCT_ID, S.SALE_DATE, CASE WHEN S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' THEN 1 ELSE 0 END AS TEMP1 FROM PRODUCT P INNER JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID ) SELECT DISTINCT PRODUCT_ID, PRODUCT_NAME FROM T1 WHERE TEMP1 = 1 AND PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM T1 WHERE TEMP1 = 0);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] WITH CTE AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) SELECT ROUND(COUNT(A.PLAYER_ID)/ COUNT(CTE.PLAYER_ID),2) AS FRACTION FROM CTE LEFT JOIN ACTIVITY A ON CTE.PLAYER_ID = A.PLAYER_ID AND A.EVENT_DATE - CTE.FIRST_LOGIN = 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH EXCLUDE AS(SELECT P.PRODUCT_ID,P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID=S.PRODUCT_ID WHERE S.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31') SELECT P.PRODUCT_ID,P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN(SELECT DISTINCT PRODUCT_ID FROM EXCLUDE);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(P1.X - P2.X) AS SHORTEST FROM POINT P1, POINT P2 WHERE P1.X != P2.X ORDER BY 1 ASC LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME , B.BONUS AS BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON B.EMPID=E.EMPID WHERE B.BONUS IS NULL OR B.BONUS < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C WHERE C.CUSTOMER_ID IN ( SELECT O.CUSTOMER_ID FROM ORDERS O WHERE O.PRODUCT_NAME = 'A') AND C.CUSTOMER_ID IN ( SELECT O.CUSTOMER_ID FROM ORDERS O WHERE O.PRODUCT_NAME = 'B') AND C.CUSTOMER_ID NOT IN ( SELECT O.CUSTOMER_ID FROM ORDERS O WHERE O.PRODUCT_NAME = 'C') ORDER BY C.CUSTOMER_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS USING(VISIT_ID) WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD U JOIN PRICES P ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM SALES WHERE BUYER_ID IN (SELECT S.BUYER_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT S.BUYER_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH CTE AS (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A' AND CUSTOMER_ID IN ( SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B' ) ) SELECT CTE.CUSTOMER_ID, CUSTOMERS.CUSTOMER_NAME FROM CTE LEFT JOIN CUSTOMERS ON CTE.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID WHERE CTE.CUSTOMER_ID NOT IN ( SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH A AS ( SELECT DISTINCT BUYER_ID, PRODUCT_NAME FROM PRODUCT AS P JOIN SALES AS S ON P.PRODUCT_ID = S.PRODUCT_ID), B AS ( SELECT BUYER_ID, SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS BUY_S8, SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS BUY_IP FROM A GROUP BY BUYER_ID) SELECT BUYER_ID FROM B WHERE BUY_S8>0 AND BUY_IP = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT DISTINCT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) NOT IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)>1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S_ID AS ID,S_NAME AS NAME FROM(SELECT S.ID AS S_ID,S.NAME AS S_NAME,S.DEPARTMENT_ID AS S_DID,D.NAME AS D_NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID WHERE D.NAME IS NULL)FHFH;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN ( SELECT MAX(TIV_2015) AS TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) > 1 ) AND PID IN ( SELECT MAX(PID) FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) = 1 );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS AS S LEFT JOIN DEPARTMENTS AS D ON D.ID=S.DEPARTMENT_ID WHERE D.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH BASE AS (SELECT VIEW_DATE, VIEWER_ID, COUNT(DISTINCT ARTICLE_ID) AS CNT FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID) SELECT DISTINCT VIEWER_ID AS ID FROM BASE WHERE CNT>1 ORDER BY VIEWER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA > 3000000 UNION SELECT NAME, POPULATION, AREA FROM WORLD WHERE POPULATION > 25000000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(CASE WHEN DURATION/60 <=5 THEN SESSION_ID END) TOTAL FROM SESSIONS UNION SELECT '[5-10>' AS BIN, COUNT(CASE WHEN DURATION/60 <=10 AND DURATION/60 >5 THEN SESSION_ID END) TOTAL FROM SESSIONS UNION SELECT '[10-15>' AS BIN, COUNT(CASE WHEN DURATION/60 <=15 AND DURATION/60 >10 THEN SESSION_ID END) TOTAL FROM SESSIONS UNION SELECT '15 OR MORE' AS BIN, COUNT(CASE WHEN DURATION/60 > 15 THEN SESSION_ID END) TOTAL FROM SESSIONS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, STORE, PRICE FROM ( SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) BASE WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM INSURANCE WHERE PID IN (SELECT DISTINCT A.PID FROM INSURANCE A JOIN INSURANCE B ON A.PID != B.PID AND A.TIV_2015 = B.TIV_2015 WHERE A.PID NOT IN (SELECT C.PID FROM INSURANCE C JOIN INSURANCE D ON C.PID != D.PID AND C.LAT = D.LAT AND C.LON = D.LON));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT A.PRODUCT_ID, ROUND( SUM(A.PRICE * B.UNITS) / SUM(B.UNITS), 2 ) AS AVERAGE_PRICE FROM PRICES AS A RIGHT JOIN UNITSSOLD AS B ON A.PRODUCT_ID = B.PRODUCT_ID AND (B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE1 AS ( SELECT S.BUYER_ID,P.PRODUCT_NAME FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' ), CTE2 AS ( SELECT S.BUYER_ID AS OTHER ,P.PRODUCT_NAME FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE' ) SELECT BUYER_ID FROM CTE1 C1 LEFT JOIN CTE2 C2 ON C1.BUYER_ID = C2.OTHER WHERE OTHER IS NULL GROUP BY BUYER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM (SELECT S.ID, S.NAME, D.NAME AS NAM FROM STUDENTS AS S LEFT JOIN DEPARTMENTS AS D ON S.DEPARTMENT_ID=D.ID) AS A WHERE NAM IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COALESCE(COUNT(CT.CONTACT_NAME), 0) AS CONTACTS_CNT, SUM(CASE WHEN CT.CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END ) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS CT ON C.CUSTOMER_ID = CT.USER_ID GROUP BY C.CUSTOMER_NAME, I.INVOICE_ID, I.PRICE ORDER BY I.INVOICE_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(*) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN ( SELECT V.VISIT_ID FROM VISITS V JOIN TRANSACTIONS T ON V.VISIT_ID=T.VISIT_ID ) GROUP BY CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH C1 AS ( SELECT S.PRODUCT_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' ) SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN ( SELECT S.PRODUCT_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH TEMP AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID ) SELECT A.PLAYER_ID, DEVICE_ID FROM TEMP A LEFT JOIN ACTIVITY B ON A.PLAYER_ID = B.PLAYER_ID AND A.FIRST_LOGIN = B.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID ORDER BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT SALES.PRODUCT_ID, PRODUCT_NAME FROM PRODUCT JOIN SALES ON PRODUCT.PRODUCT_ID=SALES.PRODUCT_ID WHERE PRODUCT.PRODUCT_ID NOT IN (SELECT DISTINCT SALES.PRODUCT_ID FROM SALES WHERE SALE_DATE>'2019-03-31' OR SALE_DATE<'2019-01-01');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM ( SELECT * FROM UNITSSOLD LEFT JOIN PRICES USING(PRODUCT_ID) ) T WHERE PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN ( SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME='S8' ) AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME='IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS ( SELECT * FROM SALES LEFT JOIN PRODUCT USING (PRODUCT_ID) ) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN ( SELECT CASE WHEN USER1_ID = 1 THEN USER2_ID WHEN USER2_ID =1 THEN USER1_ID END AS FRIENDS_ID FROM FRIENDSHIP WHERE USER1_ID =1 OR USER2_ID =1) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH C1 AS ( SELECT S.*, P.PRODUCT_NAME, P.UNIT_PRICE FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID) SELECT BUYER_ID FROM (SELECT BUYER_ID, SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS S8, SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS IPHONE FROM C1 GROUP BY BUYER_ID)Q WHERE S8 >= 1 AND IPHONE = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM PRODUCT P RIGHT JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) =0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) >0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) - COUNT(TRANSACTION_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID GROUP BY CUSTOMER_ID HAVING COUNT(TRANSACTION_ID) < COUNT(CUSTOMER_ID);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT S.SELLER_ID, S.BUYER_ID, P.PRODUCT_NAME, P.PRODUCT_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME IN ('S8','IPHONE') ) SELECT DISTINCT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE ');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN ( SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT D.UNIQUE_ID AS UNIQUE_ID, E.NAME AS NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI D ON E.ID=D.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID, DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID HAVING COUNT(ACTOR_ID+DIRECTOR_ID)>=3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(DISTINCT STUDENT) >= 5 ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O ON O.CUSTOMER_ID = C.CUSTOMER_ID WHERE C.CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME IN ('A','B') GROUP BY CUSTOMER_ID HAVING COUNT(*)>1) AND C.CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(*) >= 2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMERS.CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS INNER JOIN ORDERS ON CUSTOMERS.CUSTOMER_ID = ORDERS.CUSTOMER_ID WHERE PRODUCT_NAME = 'A' AND CUSTOMERS.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMERS.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT (T1.AUTHOR_ID) AS ID FROM VIEWS T1 JOIN VIEWS T2 ON T1.AUTHOR_ID=T2.VIEWER_ID AND T1.ARTICLE_ID=T2.ARTICLE_ID ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, STORE, PRICE FROM ( SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) T WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S1.ID, S1.NAME FROM STUDENTS S1 LEFT JOIN DEPARTMENTS D1 ON S1.DEPARTMENT_ID = D1.ID WHERE D1.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID, (DIRECTOR_ID) FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID HAVING COUNT(*) >= 3;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT Q.AUTHOR_ID AS ID FROM ( SELECT V1.AUTHOR_ID AS AUTHOR_ID, V1.ARTICLE_ID FROM VIEWS V1 INNER JOIN (SELECT VIEWER_ID, ARTICLE_ID FROM VIEWS) V2 ON V1.ARTICLE_ID=V2.ARTICLE_ID AND V1.AUTHOR_ID=V2.VIEWER_ID ) Q ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH TIV2015_COUNTS AS (SELECT TIV_2015, COUNT(*) AS COUNTS FROM INSURANCE I GROUP BY TIV_2015), UNIQUE_CITY AS ( SELECT LAT, LON, COUNT(*) AS COUNTS FROM INSURANCE I GROUP BY LAT, LON ) SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE I WHERE TIV_2015 IN (SELECT TIV_2015 FROM TIV2015_COUNTS WHERE COUNTS >= 2) AND (LAT, LON) IN (SELECT LAT, LON FROM UNIQUE_CITY WHERE COUNTS = 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON LEFT JOIN ADDRESS ON PERSON.PERSONID = ADDRESS.PERSONID WHERE PERSON.PERSONID > 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT A.NAME, BONUS FROM EMPLOYEE A LEFT JOIN BONUS B ON A.EMPID = B.EMPID WHERE COALESCE(B.BONUS,0) < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(*) >1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND EXTRA <> 'NONE' AND ACTION = 'REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT (AUTHOR_ID) AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID GROUP BY AUTHOR_ID ORDER BY AUTHOR_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T AS( SELECT S.*, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM T WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM T WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(DURATION) AS TOTAL FROM SESSIONS WHERE DURATION < 300 UNION SELECT '[5-10>', COUNT(DURATION) FROM SESSIONS WHERE DURATION BETWEEN 300 AND 599 UNION SELECT '[10-15>', COUNT(DURATION) FROM SESSIONS WHERE DURATION BETWEEN 600 AND 899 UNION SELECT '15 OR MORE', COUNT(DURATION) FROM SESSIONS WHERE DURATION >= 900;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH PRICED_UNITS AS ( SELECT U.PRODUCT_ID, U.UNITS, P.PRICE, P.PRICE*U.UNITS AS TOTAL_PRICE FROM UNITSSOLD U INNER JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ) SELECT PRODUCT_ID, ROUND(SUM(TOTAL_PRICE)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM PRICED_UNITS GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, EMP.NAME FROM EMPLOYEES EMP LEFT JOIN EMPLOYEEUNI EMPU ON EMPU.ID = EMP.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM BONUS B RIGHT JOIN EMPLOYEE E ON B.EMPID = E.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT RECOMMENDED_PAGE FROM (SELECT A.USER1_ID USER_ID, A.USER2_ID FRIEND_ID, B.PAGE_ID RECOMMENDED_PAGE FROM FRIENDSHIP A INNER JOIN LIKES B ON A.USER2_ID=B.USER_ID WHERE A.USER1_ID=1 AND B.PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID =1) UNION SELECT A.USER2_ID USER_ID, A.USER1_ID FRIEND_ID, B.PAGE_ID RECOMMENDED_PAGE FROM FRIENDSHIP A INNER JOIN LIKES B ON A.USER1_ID=B.USER_ID WHERE A.USER2_ID=1 AND B.PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID =1))X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES JOIN PRODUCT USING (PRODUCT_ID) GROUP BY BUYER_ID HAVING ( SUM(CASE WHEN PRODUCT_NAME ='S8' THEN 1 ELSE 0 END)>0 AND SUM(CASE WHEN PRODUCT_NAME ='IPHONE' THEN 1 ELSE 0 END)=0);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(CON.CONTACT_EMAIL) AS CONTACTS_CNT, COUNT(C2.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS CON ON C.CUSTOMER_ID = CON.USER_ID LEFT JOIN CUSTOMERS C2 ON CON.CONTACT_EMAIL = C2.EMAIL GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EU ON E.ID=EU.ID ORDER BY NAME ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS (SELECT A.BUYER_ID, B.PRODUCT_NAME FROM SALES AS A LEFT JOIN PRODUCT AS B ON A.PRODUCT_ID = B.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM CTE WHERE BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(DISTINCT CT.CONTACT_NAME) AS CONTACTS_CNT, COUNT(DISTINCT CC.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES I INNER JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS CT ON CT.USER_ID= C.CUSTOMER_ID LEFT JOIN CUSTOMERS CC ON CC.EMAIL = CT.CONTACT_EMAIL GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(DISTINCT(V.VISIT_ID)) AS COUNT_NO_TRANS FROM VISITS AS V, TRANSACTIONS AS T WHERE V.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID PROJECT_ID , ROUND(AVG(E.EXPERIENCE_YEARS),2) AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEES E LEFT OUTER JOIN EMPLOYEEUNI U ON E.ID = U.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(1)>1) AND (LAT, LON) IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(1)=1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE1 AS (SELECT DISTINCT A.BUYER_ID FROM SALES A INNER JOIN PRODUCT B USING (PRODUCT_ID) WHERE PRODUCT_NAME = 'S8'), CTE2 AS (SELECT DISTINCT A.BUYER_ID FROM SALES A INNER JOIN PRODUCT B USING (PRODUCT_ID) WHERE PRODUCT_NAME = 'IPHONE') SELECT A.BUYER_ID FROM CTE1 A LEFT OUTER JOIN CTE2 B USING (BUYER_ID) WHERE B.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND S.BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH TEMP AS (SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY, CASE WHEN MAX(SALARY) > 10000 THEN 0.49 WHEN MAX(SALARY) < 1000 THEN 0 ELSE 0.24 END AS TAX FROM SALARIES GROUP BY COMPANY_ID) SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(S.SALARY*(1-T.TAX), 0) AS SALARY FROM SALARIES AS S LEFT JOIN TEMP AS T ON S.COMPANY_ID = T.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH PRICE_SOLD AS ( SELECT PR.PRODUCT_ID, PR.PRICE, US.UNITS FROM PRICES AS PR LEFT JOIN UNITSSOLD AS US ON PR.PRODUCT_ID = US.PRODUCT_ID WHERE US.PURCHASE_DATE <= PR.END_DATE AND US.PURCHASE_DATE >= PR.START_DATE ) SELECT PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AS AVERAGE_PRICE FROM PRICE_SOLD GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID, COUNT(VISITS.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISITS.VISIT_ID NOT IN (SELECT TRANSACTIONS.VISIT_ID FROM TRANSACTIONS) GROUP BY VISITS.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH SOLD_PRICE AS ( SELECT U.PRODUCT_ID, U.UNITS, U.UNITS * P.PRICE AS TOTAL_PRICE FROM UNITSSOLD AS U LEFT JOIN PRICES AS P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE >= P.START_DATE AND U.PURCHASE_DATE <= P.END_DATE ) SELECT PRODUCT_ID, ROUND(SUM(TOTAL_PRICE)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM SOLD_PRICE GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON P. PRODUCT_ID = S.PRODUCT_ID WHERE PRODUCT_NAME= 'S8' AND BUYER_ID NOT IN (SELECT DISTINCT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON P. PRODUCT_ID = S.PRODUCT_ID WHERE PRODUCT_NAME= 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016), 2) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1 ) AND (LAT, LON) NOT IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*)>1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT O.CUSTOMER_ID, C.CUSTOMER_NAME FROM ORDERS AS O LEFT JOIN CUSTOMERS AS C ON O.CUSTOMER_ID = C.CUSTOMER_ID WHERE (O.CUSTOMER_ID, 'A') IN (SELECT CUSTOMER_ID, PRODUCT_NAME FROM ORDERS) AND (O.CUSTOMER_ID, 'B') IN (SELECT CUSTOMER_ID, PRODUCT_NAME FROM ORDERS) AND (O.CUSTOMER_ID, 'C') NOT IN (SELECT CUSTOMER_ID, PRODUCT_NAME FROM ORDERS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA > 3000000 OR POPULATION > 25000000 ORDER BY NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH S8 AS (SELECT A.BUYER_ID, A.PRODUCT_ID, B.PRODUCT_NAME FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID=B.PRODUCT_ID AND B.PRODUCT_NAME='S8'), IP AS (SELECT A.BUYER_ID, A.PRODUCT_ID, B.PRODUCT_NAME FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID=B.PRODUCT_ID AND B.PRODUCT_NAME='IPHONE'), S8_B AS (SELECT DISTINCT(BUYER_ID) AS BUYER_ID FROM S8), IP_B AS (SELECT DISTINCT(BUYER_ID) AS BUYER_ID FROM IP) SELECT A.BUYER_ID FROM S8_B A LEFT JOIN IP_B B ON A.BUYER_ID=B.BUYER_ID WHERE B.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE PRODUCT_NAME='S8') AND BUYER_ID NOT IN (SELECT DISTINCT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM ( SELECT A.*,B.BUYER_ID FROM PRODUCT A LEFT JOIN SALES B ON A.PRODUCT_ID=B.PRODUCT_ID )C WHERE PRODUCT_NAME='S8' AND BUYER_ID NOT IN (SELECT DISTINCT BUYER_ID FROM ( SELECT A.*,B.BUYER_ID FROM PRODUCT A LEFT JOIN SALES B ON A.PRODUCT_ID=B.PRODUCT_ID )A WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH ACT AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS DATA_MIN FROM ACTIVITY GROUP BY PLAYER_ID) SELECT ACTIVITY.PLAYER_ID, ACTIVITY.DEVICE_ID FROM ACTIVITY INNER JOIN ACT ON ACT.PLAYER_ID = ACTIVITY.PLAYER_ID WHERE ACTIVITY.EVENT_DATE = ACT.DATA_MIN;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS ) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH TOTAL_UNITS AS (SELECT U1.PRODUCT_ID, SUM(U1.UNITS) TOTAL_UNITS FROM UNITSSOLD U1 GROUP BY U1.PRODUCT_ID), TOTAL_DAILY_REVENUE AS ( SELECT P.PRODUCT_ID, U2.PURCHASE_DATE, (P.PRICE * U2.UNITS) TOTAL_DAILY_REVENUE FROM PRICES P INNER JOIN UNITSSOLD U2 ON P.PRODUCT_ID = U2.PRODUCT_ID WHERE U2.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ), TOTAL_REVENUE AS ( SELECT TOTAL_DAILY_REVENUE.PRODUCT_ID, SUM(TOTAL_DAILY_REVENUE.TOTAL_DAILY_REVENUE) TOTAL_REVENUE FROM TOTAL_DAILY_REVENUE GROUP BY TOTAL_DAILY_REVENUE.PRODUCT_ID ) SELECT TOTAL_UNITS.PRODUCT_ID, ROUND((TOTAL_REVENUE.TOTAL_REVENUE / TOTAL_UNITS.TOTAL_UNITS), 2) AVERAGE_PRICE FROM TOTAL_UNITS JOIN TOTAL_REVENUE ON TOTAL_UNITS.PRODUCT_ID = TOTAL_REVENUE.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT T1.ACCOUNT_ID FROM LOGINFO T1, LOGINFO T2 WHERE T1.ACCOUNT_ID = T2.ACCOUNT_ID AND T1.IP_ADDRESS != T2.IP_ADDRESS AND T2.LOGIN BETWEEN T1.LOGIN AND T1.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT(P.PRODUCT_ID), P.PRODUCT_NAME FROM PRODUCT P, SALES S WHERE P.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2018-12-31' AND '2019-04-01' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH TABLE1 AS ( SELECT CUS.CUSTOMER_ID AS CUSTOMER_ID, CUSTOMER_NAME, PRICE, INVOICE_ID FROM CUSTOMERS CUS LEFT JOIN CONTACTS CON ON CUS.CUSTOMER_ID = CON.USER_ID JOIN INVOICES I ON I.USER_ID = CUS.CUSTOMER_ID ), TABLE2 AS ( SELECT CUS.CUSTOMER_ID AS CUSTOMER_ID, COUNT(CONTACT_EMAIL) AS CONTACTS_CNT FROM CUSTOMERS CUS LEFT JOIN CONTACTS CON ON CUS.CUSTOMER_ID = CON.USER_ID GROUP BY CUSTOMER_ID ), TABLE3 AS ( SELECT CUSTOMER_ID, COUNT(CONTACT_EMAIL) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS CUS LEFT JOIN CONTACTS CON ON CUS.CUSTOMER_ID = CON.USER_ID WHERE CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) GROUP BY CUSTOMER_ID ) SELECT DISTINCT INVOICE_ID, CUSTOMER_NAME, PRICE, CONTACTS_CNT, CASE WHEN TRUSTED_CONTACTS_CNT IS NULL THEN 0 ELSE TRUSTED_CONTACTS_CNT END AS TRUSTED_CONTACTS_CNT FROM TABLE1 LEFT JOIN TABLE2 ON TABLE1.CUSTOMER_ID = TABLE2.CUSTOMER_ID LEFT JOIN TABLE3 ON TABLE3.CUSTOMER_ID = TABLE1.CUSTOMER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH CTE AS (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME IN ('A','B') GROUP BY CUSTOMER_ID HAVING COUNT(PRODUCT_NAME) >=2) SELECT A.CUSTOMER_ID ,B.CUSTOMER_NAME FROM CTE A JOIN CUSTOMERS B ON A.CUSTOMER_ID = B.CUSTOMER_ID WHERE A.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME ='C');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] WITH TEMP AS (SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) SELECT ROUND(COUNT(A1.PLAYER_ID)/(SELECT COUNT(DISTINCT PLAYER_ID) FROM ACTIVITY),2) AS FRACTION FROM TEMP A1 JOIN ACTIVITY A2 ON A2.PLAYER_ID = A1.PLAYER_ID AND A1.EVENT_DATE = A2.EVENT_DATE-1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EN ON E.ID = EN.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT DISTINCT ID FROM DEPARTMENTS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(A.X-B.X) SHORTEST FROM POINT A JOIN POINT B ON A.X<B.X ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S, PRODUCT P WHERE S.PRODUCT_ID=P.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME='S8' THEN 1 ELSE 0 END) >0 AND SUM(CASE WHEN P.PRODUCT_NAME='IPHONE' THEN 1 ELSE 0 END)=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID , S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID WHERE D.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T USING(VISIT_ID) WHERE T.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*) = 1 UNION ALL SELECT NULL FROM MYNUMBERS ORDER BY NUM DESC LIMIT 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT(A.ACCOUNT_ID) FROM LOGINFO A INNER JOIN LOGINFO B ON B.LOGIN BETWEEN A.LOGIN AND A.LOGOUT AND A.IP_ADDRESS != B.IP_ADDRESS AND A.ACCOUNT_ID = B.ACCOUNT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID , C1.CUSTOMER_NAME , I.PRICE , COUNT(C2.CONTACT_NAME) AS CONTACTS_CNT , SUM(CASE WHEN C2.CONTACT_EMAIL IN (SELECT DISTINCT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM INVOICES AS I INNER JOIN CUSTOMERS AS C1 ON I.USER_ID = C1.CUSTOMER_ID LEFT JOIN CONTACTS AS C2 ON C1.CUSTOMER_ID = C2.USER_ID GROUP BY I.INVOICE_ID , C1.CUSTOMER_NAME , I.PRICE ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EMPIN.UNIQUE_ID, EMP.NAME FROM EMPLOYEES EMP LEFT JOIN EMPLOYEEUNI EMPIN ON EMP.ID = EMPIN.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(1) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT(PAGE_ID) AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN ((SELECT USER2_ID AS FRIEND1 FROM FRIENDSHIP WHERE USER1_ID = 1) UNION ALL (SELECT USER1_ID AS FRIEND1 FROM FRIENDSHIP WHERE USER2_ID = 1)) AND PAGE_ID NOT IN (SELECT DISTINCT(PAGE_ID) FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(DISTINCT B.PLAYER_ID)/COUNT(A.PLAYER_ID),2) FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) MINDDT FROM ACTIVITY GROUP BY PLAYER_ID) A LEFT JOIN ACTIVITY B ON A.PLAYER_ID = B.PLAYER_ID AND A.MINDDT = B.EVENT_DATE-1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(C.S) AS SHORTEST FROM (SELECT ABS(B.X-A.X) AS S FROM POINT A CROSS JOIN POINT B WHERE ABS(B.X-A.X)>0) C;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C INNER JOIN (SELECT CUSTOMER_ID, SUM(CASE WHEN PRODUCT_NAME = 'A' THEN 1 ELSE 0 END) AS A, SUM(CASE WHEN PRODUCT_NAME = 'B' THEN 1 ELSE 0 END) AS B, SUM(CASE WHEN PRODUCT_NAME = 'C' THEN 1 ELSE 0 END) AS C FROM ORDERS GROUP BY CUSTOMER_ID ) M ON C.CUSTOMER_ID = M.CUSTOMER_ID WHERE M.A > 0 AND M.B > 0 AND M.C = 0;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT A.NAME AS CUSTOMERS FROM CUSTOMERS A WHERE A.ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V JOIN (SELECT VISIT_ID FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS))X ON V.VISIT_ID = X.VISIT_ID GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID RECOMMENDED_PAGE FROM (SELECT USER2_ID FRIEND_ID FROM FRIENDSHIP WHERE USER1_ID=1 UNION SELECT USER1_ID FRIEND_ID FROM FRIENDSHIP WHERE USER2_ID=1) ALL_FRIENDS INNER JOIN LIKES ON ALL_FRIENDS.FRIEND_ID = LIKES.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT TRANSACTIONS.VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L2.ACCOUNT_ID=L1.ACCOUNT_ID AND L2.IP_ADDRESS<>L1.IP_ADDRESS AND (L2.LOGIN BETWEEN L1.LOGIN AND L1.LOGOUT);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P USING (PRODUCT_ID) WHERE P.PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P USING (PRODUCT_ID) WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES LEFT JOIN PRODUCT ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE BUYER_ID IN ( SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' ) AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.VIEWER_ID AS ID FROM VIEWS V1 JOIN VIEWS V2 ON V1.VIEW_DATE = V2.VIEW_DATE AND V1.VIEWER_ID = V2.VIEWER_ID AND V1.ARTICLE_ID <> V2.ARTICLE_ID ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH B AS (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGGED_DATE FROM ACTIVITY GROUP BY PLAYER_ID) SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A LEFT JOIN B ON A.PLAYER_ID = B.PLAYER_ID WHERE A.EVENT_DATE = B.FIRST_LOGGED_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM PRODUCT P LEFT JOIN SALES S USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM PRODUCT P LEFT JOIN SALES S USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT SALARIES.COMPANY_ID, SALARIES.EMPLOYEE_ID, SALARIES.EMPLOYEE_NAME, ROUND(SALARIES.SALARY * TAXES.TAX) AS SALARY FROM SALARIES JOIN ( SELECT COMPANY_ID, CASE WHEN MAX(SALARY) < 1000 THEN (1 - 0) WHEN (MAX(SALARY) >= 1000) AND (MAX(SALARY) <= 10000) THEN (1 - 0.24) ELSE (1 - 0.49) END AS TAX FROM SALARIES GROUP BY COMPANY_ID ) AS TAXES USING (COMPANY_ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM ( SELECT VIEWER_ID, COUNT(DISTINCT ARTICLE_ID) AS ARTICLE_VIEWS FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID ) SUB WHERE ARTICLE_VIEWS > 1 ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT TMP.* FROM ( SELECT PRODUCT_ID, 'STORE1' AS STORE, CASE WHEN STORE1 IS NOT NULL THEN STORE1 ELSE NULL END AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, CASE WHEN STORE2 IS NOT NULL THEN STORE2 ELSE NULL END AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, CASE WHEN STORE3 IS NOT NULL THEN STORE3 ELSE NULL END AS PRICE FROM PRODUCTS) AS TMP WHERE TMP.PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COALESCE(COUNT(CT.USER_ID),0) CONTACTS_CNT, COALESCE(COUNT(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 END),0) TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID=C.CUSTOMER_ID LEFT JOIN CONTACTS CT ON I.USER_ID=CT.USER_ID GROUP BY INVOICE_ID, CUSTOMER_NAME, PRICE ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT AS P LEFT JOIN EMPLOYEE AS E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH WLS AS( SELECT VIEWER_ID,VIEW_DATE,COUNT(DISTINCT ARTICLE_ID) AS NUM FROM VIEWS GROUP BY VIEWER_ID,VIEW_DATE ) SELECT DISTINCT VIEWER_ID AS ID FROM WLS WHERE NUM>1 ORDER BY VIEWER_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION < 5 * 60 UNION SELECT '[5-10>' AS BIN, COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION >= 5 * 60 AND DURATION < 10 * 60 UNION SELECT '[10-15>' AS BIN, COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION >= 10 * 60 AND DURATION < 15 * 60 UNION SELECT '15 OR MORE' AS BIN, COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION >= 15 * 60;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME,BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID=BONUS.EMPID WHERE NAME NOT IN ( SELECT NAME FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID=B.EMPID WHERE B.BONUS > 1000);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID AS CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISITS.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] WITH COUNTS AS ( SELECT EMAIL, COUNT(ID) AS C FROM PERSON GROUP BY EMAIL ) SELECT EMAIL FROM COUNTS WHERE C > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT DISTINCT S.ID, S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON D.ID=S.DEPARTMENT_ID WHERE D.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) >= 1 AND SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH MAX_SALARIES AS ( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID ) SELECT S.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(CASE WHEN MAX_SALARY < 1000 THEN SALARY WHEN MAX_SALARY > 10000 THEN 0.51*SALARY ELSE 0.76*SALARY END) AS SALARY FROM SALARIES AS S JOIN MAX_SALARIES AS M ON S.COMPANY_ID = M.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE_CUSTOMER_INVOICE AS (SELECT I.INVOICE_ID,C.CUSTOMER_ID,C.CUSTOMER_NAME,I.PRICE FROM INVOICES I JOIN CUSTOMERS C ON I.USER_ID=C.CUSTOMER_ID), CTE_TOTAL_CONTACTS AS (SELECT USER_ID AS CUSTOMER_ID,COUNT(*)TOT_CONTACTS FROM CONTACTS GROUP BY USER_ID), CTE_TRUSTED_CONTACTS AS (SELECT USER_ID AS CUSTOMER_ID,COUNT(*) TRUSTED_CONTACTS FROM CONTACTS C JOIN CUSTOMERS CC ON C.CONTACT_NAME =CC.CUSTOMER_NAME AND C.CONTACT_EMAIL=CC.EMAIL GROUP BY USER_ID), CTE_CONTACTS_MERGED AS (SELECT C.CUSTOMER_ID,TOT_CONTACTS AS CONTACTS_CNT ,COALESCE(TRUSTED_CONTACTS,0)TRUSTED_CONTACTS_CNT FROM CTE_TOTAL_CONTACTS C LEFT JOIN CTE_TRUSTED_CONTACTS CC ON C.CUSTOMER_ID=CC.CUSTOMER_ID) SELECT I.INVOICE_ID,I.CUSTOMER_NAME,I.PRICE, COALESCE(C.CONTACTS_CNT,0)CONTACTS_CNT,COALESCE(C.TRUSTED_CONTACTS_CNT,0)TRUSTED_CONTACTS_CNT FROM CTE_CUSTOMER_INVOICE I LEFT JOIN CTE_CONTACTS_MERGED C ON I.CUSTOMER_ID = C.CUSTOMER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID,DIRECTOR_ID FROM (SELECT ACTOR_ID,DIRECTOR_ID,COUNT(ACTOR_ID) AS NUM FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID) AS X WHERE NUM >= 3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(P1.X-P2.X) AS SHORTEST FROM POINT AS P1 JOIN POINT AS P2 ON P1.X<>P2.X ORDER BY 1 LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, 'STORE1' STORE, STORE1 PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE2' STORE, STORE2 PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE3' STORE, STORE3 PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) UNIQUE_LEADS, COUNT(DISTINCT(PARTNER_ID)) UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES AS S INNER JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN( SELECT DISTINCT BUYER_ID FROM SALES AS S INNER JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE AS (SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, C.CUSTOMER_ID AS USER_ID FROM INVOICES I JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID), CTE2 AS (SELECT USER_ID, COUNT(USER_ID) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COALESCE(CTE2.CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(CTE2.TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM CTE LEFT JOIN CTE2 USING(USER_ID) ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AS AVERAGE_PRICE FROM (SELECT U.PRODUCT_ID, PRICE, UNITS FROM PRICES P RIGHT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND PURCHASE_DATE>= START_DATE AND PURCHASE_DATE<=END_DATE) A GROUP BY PRODUCT_ID ORDER BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM (SELECT DISTINCT STUDENT , CLASS FROM COURSES)T1 GROUP BY CLASS HAVING COUNT(CLASS)>= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] WITH CTE1 AS ( SELECT PLAYER_ID,MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID ) SELECT ROUND( COUNT(DISTINCT A.PLAYER_ID) / (SELECT COUNT(DISTINCT PLAYER_ID) FROM ACTIVITY ) ,2) AS FRACTION FROM CTE1 A JOIN ACTIVITY B ON A.PLAYER_ID = B.PLAYER_ID AND B.EVENT_DATE-A.EVENT_DATE = 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES S WHERE (S.SALE_DATE < '2019-01-01') OR (S.SALE_DATE > '2019-03-31') );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT * FROM FRIENDSHIP) A JOIN LIKES ON ( A.USER1_ID=LIKES.USER_ID AND USER2_ID=1 OR A.USER2_ID=LIKES.USER_ID AND USER1_ID=1 ) WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH CTE AS (SELECT A.PRODUCT_ID, A.SALE_DATE, B.PRODUCT_NAME FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID) SELECT PRODUCT_ID, PRODUCT_NAME FROM CTE WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM CTE WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31') AND PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM CTE WHERE (SALE_DATE < '2019-01-01') OR (SALE_DATE > '2019-03-31')) GROUP BY PRODUCT_ID, PRODUCT_NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID ,COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.AUTHOR_ID AS ID FROM VIEWS V1, VIEWS V2 WHERE V1.AUTHOR_ID = V2.VIEWER_ID AND V1.ARTICLE_ID = V2.ARTICLE_ID ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C WHERE CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='A' ) AND CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='B' ) AND CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='C' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE AS (SELECT USER2_ID USER_ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER1_ID USER_ID FROM FRIENDSHIP WHERE USER2_ID = 1) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT PAGE_ID FROM LIKES WHERE USER_ID IN (SELECT USER_ID FROM CTE)) SUB WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM PRODUCT P INNER JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) =0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) >0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE (ACTION_DATE = '2019-07-04') AND (ACTION = 'REPORT') GROUP BY EXTRA;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT UNITSSOLD.PRODUCT_ID, ROUND(SUM(PRICES.PRICE * UNITSSOLD.UNITS) / SUM(UNITSSOLD.UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD JOIN PRICES ON UNITSSOLD.PRODUCT_ID = PRICES.PRODUCT_ID AND UNITSSOLD.PURCHASE_DATE BETWEEN PRICES.START_DATE AND PRICES.END_DATE GROUP BY UNITSSOLD.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH ALL_FRIENDS AS ( SELECT USER1_ID AS FRIEND_ID FROM FRIENDSHIP WHERE USER2_ID = 1 UNION ALL SELECT USER2_ID AS FRIEND_ID FROM FRIENDSHIP WHERE USER1_ID = 1 ) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES L JOIN ALL_FRIENDS F ON F.FRIEND_ID = L.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN ( SELECT O.CUSTOMERID FROM ORDERS AS O );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT T2.UNIQUE_ID, T1.NAME FROM EMPLOYEES T1 LEFT JOIN EMPLOYEEUNI AS T2 ON T1.ID=T2.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A JOIN LOGINFO B ON A. ACCOUNT_ID=B. ACCOUNT_ID WHERE A.IP_ADDRESS <> B.IP_ADDRESS AND (A.LOGIN BETWEEN B.LOGIN AND B.LOGOUT OR B.LOGIN BETWEEN A.LOGIN AND A.LOGOUT);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME AS NAME, B.BONUS AS BONUS FROM EMPLOYEE AS E LEFT JOIN BONUS AS B ON E.EMPID = B.EMPID WHERE B.BONUS < 1000 OR BONUS IS NULL ORDER BY BONUS DESC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT PERSON.EMAIL FROM PERSON GROUP BY PERSON.EMAIL HAVING COUNT(EMAIL) > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE AS (SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID) SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, (ROUND(CASE WHEN CTE.MAX_SALARY < 1000 THEN S.SALARY WHEN CTE.MAX_SALARY <= 10000 THEN S.SALARY * 0.76 ELSE S.SALARY * 0.51 END, 0)) AS SALARY FROM SALARIES AS S JOIN CTE ON S.COMPANY_ID = CTE.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(P1.X - P2.X) AS SHORTEST FROM POINT P1 INNER JOIN POINT P2 ON P1.X > P2.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH TEMP AS ( SELECT A.PRODUCT_ID, A.PRICE, B.UNITS FROM PRICES A LEFT OUTER JOIN UNITSSOLD B ON (A.PRODUCT_ID = B.PRODUCT_ID AND A.START_DATE <= B.PURCHASE_DATE AND A.END_DATE >= B.PURCHASE_DATE)) SELECT PRODUCT_ID, ROUND(SUM(PRICE * UNITS)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM TEMP GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EE.UNIQUE_ID, E.NAME FROM EMPLOYEES AS E LEFT OUTER JOIN EMPLOYEEUNI AS EE ON E.ID = EE.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, SUM(CASE WHEN DURATION >=0 AND DURATION < 5*60 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS S UNION SELECT '[5-10>' AS BIN, SUM(CASE WHEN DURATION >=5*60 AND DURATION < 10*60 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS S UNION SELECT '[10-15>' AS BIN, SUM(CASE WHEN DURATION >=10*60 AND DURATION < 15*60 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS S UNION SELECT '15 OR MORE' AS BIN, SUM(CASE WHEN DURATION >=15*60 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS S;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON P.PRODUCT_ID=S.PRODUCT_ID WHERE P.PRODUCT_NAME='S8' AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON P.PRODUCT_ID=S.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(VISIT_ID) AS COUNT_NO_TRANS FROM VISITS AS V WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT USING (PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME='S8' THEN 1 ELSE 0 END)>0 AND SUM(CASE WHEN PRODUCT_NAME='IPHONE' THEN 1 ELSE 0 END)=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.AUTHOR_ID AS ID FROM VIEWS V1 INNER JOIN VIEWS V2 ON V1.AUTHOR_ID = V2.VIEWER_ID AND V1.ARTICLE_ID = V2.ARTICLE_ID ORDER BY V1.AUTHOR_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH A AS ( SELECT CUSTOMERS.CUSTOMER_ID, CUSTOMER_NAME, ORDER_ID FROM CUSTOMERS INNER JOIN ORDERS ON CUSTOMERS.CUSTOMER_ID = ORDERS.CUSTOMER_ID WHERE PRODUCT_NAME = 'A'), B AS ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, A.ORDER_ID FROM A INNER JOIN ORDERS ON A.CUSTOMER_ID = ORDERS.CUSTOMER_ID WHERE PRODUCT_NAME = 'B' ) SELECT B.CUSTOMER_ID, CUSTOMER_NAME FROM B WHERE B.CUSTOMER_ID NOT IN (SELECT CUSTOMERS.CUSTOMER_ID FROM CUSTOMERS INNER JOIN ORDERS ON CUSTOMERS.CUSTOMER_ID = ORDERS.CUSTOMER_ID WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] WITH STUDENT_COUNT AS (SELECT CLASS, COUNT(*) AS STU_COUNT FROM COURSES GROUP BY CLASS) SELECT CLASS FROM STUDENT_COUNT WHERE STU_COUNT >=5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(A.X-B.X)) AS SHORTEST FROM POINT A, POINT B WHERE A.X<B.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT.PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT.PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT A.PRODUCT_ID,A.PRODUCT_NAME FROM (SELECT SALES.PRODUCT_ID, SALES.SALE_DATE, PRODUCT.PRODUCT_NAME FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID=PRODUCT.PRODUCT_ID)AS A WHERE A.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE<'2019-01-01' OR SALE_DATE>'2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT P1.EMAIL AS EMAIL FROM PERSON P1, PERSON P2 WHERE P1.ID < P2.ID AND P1.EMAIL = P2.EMAIL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH AUX_TABLE AS ( SELECT P.PRODUCT_ID, SUM(U.UNITS) AS TOTAL_UNITS, SUM(P.PRICE*U.UNITS) AS TOTAL_PRICE FROM PRICES AS P INNER JOIN UNITSSOLD AS U ON P.START_DATE <= U.PURCHASE_DATE AND P.END_DATE >= U.PURCHASE_DATE AND P.PRODUCT_ID = U.PRODUCT_ID GROUP BY P.PRODUCT_ID ) SELECT PRODUCT_ID, ROUND(TOTAL_PRICE/TOTAL_UNITS,2) AS AVERAGE_PRICE FROM AUX_TABLE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T USING (VISIT_ID) WHERE T.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT P1.EMAIL AS EMAIL FROM PERSON P1, PERSON P2 WHERE P1.ID != P2.ID AND P1.EMAIL = P2.EMAIL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID, CUSTOMERS.CUSTOMER_NAME FROM (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A' )A JOIN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B' )B ON A.CUSTOMER_ID = B.CUSTOMER_ID LEFT JOIN CUSTOMERS ON A.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID WHERE A.CUSTOMER_ID NOT IN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS) ,2) AS AVERAGE_PRICE FROM PRICES AS P LEFT JOIN UNITSSOLD AS U ON P.PRODUCT_ID = U.PRODUCT_ID WHERE U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID AS CUSTOMER_ID, COUNT(A.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS A LEFT JOIN TRANSACTIONS B USING(VISIT_ID) WHERE B.VISIT_ID IS NULL GROUP BY A.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH FD AS (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) SELECT FD.PLAYER_ID, DEVICE_ID FROM ACTIVITY JOIN FD ON FD.PLAYER_ID = ACTIVITY.PLAYER_ID WHERE EVENT_DATE = MIN_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID END AS USER_ID FROM FRIENDSHIP ) A JOIN LIKES B ON A.USER_ID = B.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE SALE_DATE >= '2019-01-01'AND SALE_DATE <='2019-03-31' AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH BASE AS ( SELECT S.BUYER_ID , CASE WHEN PRODUCT_NAME ='S8' THEN 1 ELSE 0 END AS S8, CASE WHEN PRODUCT_NAME ='IPHONE' THEN 1 ELSE 0 END AS IPHONE FROM SALES S INNER JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID ) SELECT BUYER_ID FROM BASE GROUP BY BUYER_ID HAVING SUM(S8) >0 AND SUM(IPHONE)=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH IN_RANGE AS ( SELECT DISTINCT PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE SALES.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' ), OUT_RANGE AS ( SELECT DISTINCT PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE SALES.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' ) SELECT * FROM IN_RANGE WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM OUT_RANGE );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT SALES.BUYER_ID FROM SALES WHERE SALES.BUYER_ID IN (SELECT B.BUYER_ID FROM PRODUCT A LEFT JOIN SALES B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE A.PRODUCT_NAME = 'S8') AND SALES.BUYER_ID NOT IN ( SELECT B.BUYER_ID FROM PRODUCT A LEFT JOIN SALES B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE A.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY CUSTOMER_ID UNION SELECT CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V RIGHT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE V.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] WITH TT AS (SELECT CLASS, COUNT(CLASS) AS NUM_STUDENT FROM COURSES GROUP BY CLASS) SELECT CLASS FROM TT WHERE NUM_STUDENT >=5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE PRODUCT_NAME IN ('S8','IPHONE') GROUP BY BUYER_ID HAVING COUNT(DISTINCT PRODUCT_NAME) =1 AND MIN(PRODUCT_NAME) = 'S8';\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID , ROUND(SUM(EXPERIENCE_YEARS)/COUNT(EXPERIENCE_YEARS),2) AVERAGE_YEARS FROM PROJECT A, EMPLOYEE B WHERE A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT DISTINCT BUYER_ID FROM SALES WHERE PRODUCT_ID=( SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME='S8' ) ), DEMO AS ( SELECT DISTINCT BUYER_ID FROM SALES WHERE PRODUCT_ID=( SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME='IPHONE' ) ) SELECT CTE.BUYER_ID FROM CTE LEFT JOIN DEMO ON CTE.BUYER_ID=DEMO.BUYER_ID WHERE DEMO.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT V.PRODUCT_ID, V.STORE, V.PRICE FROM ( SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS ) AS V WHERE V.PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CUSTOMER AS (SELECT C.CUSTOMER_ID ,C.CUSTOMER_NAME,COUNT(DISTINCT CO.CONTACT_NAME) CONTACTS_CNT, SUM(CASE WHEN CO.CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS C LEFT JOIN CONTACTS CO ON C.CUSTOMER_ID = CO.USER_ID GROUP BY C.CUSTOMER_ID , C.CUSTOMER_NAME ) SELECT I.INVOICE_ID,C.CUSTOMER_NAME,I.PRICE,C.CONTACTS_CNT,C.TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMER C ON I.USER_ID = C.CUSTOMER_ID ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT S.PRODUCT_ID, ROUND(SUM(P.PRICE * S.UNITS)/SUM(S.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD S JOIN PRICES P USING (PRODUCT_ID) WHERE S.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY S.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE_FRIENDS AS ( SELECT CASE WHEN USER1_ID = 1 THEN USER2_ID WHEN USER2_ID = 1 THEN USER1_ID END AS USER_ID FROM FRIENDSHIP WHERE USER1_ID = 1 OR USER2_ID=1 ), ALREADY_LIKED AS ( SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID = 1 ), PAGES_REC AS ( SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES INNER JOIN CTE_FRIENDS CF ON LIKES.USER_ID=CF.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM ALREADY_LIKED) ) SELECT * FROM PAGES_REC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME CUSTOMERS FROM CUSTOMERS C WHERE C.ID NOT IN (SELECT O.CUSTOMERID FROM ORDERS O);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_ID NOT IN (SELECT DISTINCT S2.PRODUCT_ID FROM SALES S2 WHERE S2.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, PRODUCT_NAME FROM SALES S JOIN PRODUCT P USING (PRODUCT_ID) WHERE (P.PRODUCT_ID) NOT IN (SELECT S.PRODUCT_ID FROM SALES S WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON P LEFT JOIN ADDRESS A USING(PERSONID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES AS S INNER JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM PERSON AS P GROUP BY EMAIL HAVING COUNT(ID) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM, COUNT(*) AS CNT FROM MYNUMBERS GROUP BY NUM) T WHERE T.CNT=1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P USING (PRODUCT_ID) WHERE PRODUCT_NAME = 'IPHONE' ) AND BUYER_ID IN ( SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P USING (PRODUCT_ID) WHERE PRODUCT_NAME = 'S8' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.NAME, U.UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI U USING (ID);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A, LOGINFO B WHERE A.LOGIN BETWEEN B.LOGIN AND B.LOGOUT AND A.IP_ADDRESS <> B.IP_ADDRESS AND A.ACCOUNT_ID = B.ACCOUNT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT STUDENTS.ID, STUDENTS.NAME FROM STUDENTS LEFT JOIN DEPARTMENTS ON DEPARTMENTS.ID = STUDENTS.DEPARTMENT_ID WHERE DEPARTMENTS.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH S8 AS( SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P USING(PRODUCT_ID) WHERE P.PRODUCT_NAME ='S8' ), IP AS( SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P USING(PRODUCT_ID) WHERE P.PRODUCT_NAME ='IPHONE' ) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM S8) AND BUYER_ID NOT IN (SELECT BUYER_ID FROM IP);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH COMBINE_T AS (SELECT * FROM SALES JOIN PRODUCT USING(PRODUCT_ID)) SELECT DISTINCT BUYER_ID FROM COMBINE_T WHERE PRODUCT_NAME='S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM COMBINE_T WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(DISTINCT CO.CONTACT_EMAIL) AS CONTACTS_CNT, COUNT(DISTINCT CU.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES I INNER JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS CO ON I.USER_ID = CO.USER_ID LEFT JOIN CUSTOMERS CU ON CO.CONTACT_EMAIL = CU.EMAIL GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT TOTAL.PRODUCT_ID, TOTAL.PRODUCT_NAME FROM (SELECT DISTINCT(P.PRODUCT_ID), P.PRODUCT_NAME FROM SALES AS S LEFT OUTER JOIN PRODUCT AS P USING (PRODUCT_ID)) AS TOTAL LEFT OUTER JOIN (SELECT DISTINCT(P.PRODUCT_ID), P.PRODUCT_NAME FROM SALES AS S LEFT OUTER JOIN PRODUCT AS P USING (PRODUCT_ID) WHERE S.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31') AS NOTSPRING USING (PRODUCT_ID) WHERE NOTSPRING.PRODUCT_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.VISIT_ID IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM ( SELECT S.ID, S.NAME, D.NAME AS DPT_NAME FROM STUDENTS AS S LEFT JOIN DEPARTMENTS AS D ON S.DEPARTMENT_ID = D.ID) SUB WHERE SUB.DPT_NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES JOIN PRODUCT ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID AND PRODUCT.PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT DISTINCT BUYER_ID FROM SALES JOIN PRODUCT ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID AND PRODUCT.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE1 AS (SELECT SALES.BUYER_ID,SALES.PRODUCT_ID FROM SALES LEFT JOIN (SELECT BUYER_ID,PRODUCT_NAME,PRODUCT.PRODUCT_ID FROM SALES INNER JOIN PRODUCT ON SALES.PRODUCT_ID =PRODUCT.PRODUCT_ID WHERE PRODUCT.PRODUCT_NAME ='IPHONE') AS P ON SALES.BUYER_ID =P.BUYER_ID WHERE P.BUYER_ID IS NULL ) SELECT DISTINCT CTE1.BUYER_ID AS BUYER_ID FROM CTE1 LEFT JOIN PRODUCT ON CTE1.PRODUCT_ID =PRODUCT.PRODUCT_ID WHERE PRODUCT.PRODUCT_NAME='S8';\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT(V.AUTHOR_ID) AS ID FROM ( SELECT AUTHOR_ID, VIEWER_ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ) V ORDER BY ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(A.X - B.X) SHORTEST FROM POINT A JOIN POINT B ON A.X != B.X ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH PRODA AS ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A' ), PRODB AS ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B' ), PRODC AS ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C' ) SELECT U.* FROM CUSTOMERS U JOIN PRODA ON U.CUSTOMER_ID = PRODA.CUSTOMER_ID JOIN PRODB ON U.CUSTOMER_ID = PRODB.CUSTOMER_ID LEFT JOIN PRODC ON U.CUSTOMER_ID = PRODC.CUSTOMER_ID WHERE PRODC.CUSTOMER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID GROUP BY AUTHOR_ID HAVING COUNT(*) >= 1 ORDER BY ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND(SUM(E.EXPERIENCE_YEARS)/COUNT(E.EMPLOYEE_ID),2) AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM ( SELECT CLASS,COUNT(*) FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5)A;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] SELECT INSTALL_DT, COUNT(DISTINCT X.PLAYER_ID) AS INSTALLS, ROUND(CAST(COALESCE(COUNT(DISTINCT A.PLAYER_ID),0) AS DECIMAL)/COUNT(DISTINCT X.PLAYER_ID),2) AS DAY1_RETENTION FROM (SELECT DISTINCT PLAYER_ID, MIN(EVENT_DATE) AS INSTALL_DT FROM ACTIVITY GROUP BY PLAYER_ID) X LEFT JOIN ACTIVITY A ON X.PLAYER_ID = A.PLAYER_ID AND X.INSTALL_DT + 1 = A.EVENT_DATE GROUP BY INSTALL_DT ORDER BY INSTALL_DT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT L1.ACCOUNT_ID FROM LOGINFO AS L1 JOIN LOGINFO AS L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.LOGIN < L2.LOGIN AND L1.LOGOUT >= L2.LOGIN AND L1.IP_ADDRESS != L2.IP_ADDRESS GROUP BY L1.ACCOUNT_ID HAVING COUNT(DISTINCT(L1.IP_ADDRESS)) >= 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] WITH T1 AS ( SELECT * FROM ACTIONS WHERE EXTRA IS NOT NULL ) SELECT EXTRA AS REPORT_REASON , COUNT(DISTINCT(POST_ID)) AS REPORT_COUNT FROM T1 WHERE ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) > 1) AND (LAT, LON) IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) = 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT COURSES_B.CLASS FROM (SELECT CLASS, COUNT(DISTINCT STUDENT) AS NUM FROM COURSES GROUP BY CLASS) AS COURSES_B WHERE NUM >=5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S WHERE DEPARTMENT_ID NOT IN (SELECT D.ID FROM DEPARTMENTS D);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(DISTINCT A1.PLAYER_ID)/COUNT(DISTINCT TEMP.PLAYER_ID), 2) AS FRACTION FROM ACTIVITY A1 RIGHT JOIN (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FST_LOGIN FROM ACTIVITY A2 GROUP BY A2.PLAYER_ID )TEMP ON A1.PLAYER_ID = TEMP.PLAYER_ID AND A1.EVENT_DATE = TEMP.FST_LOGIN + 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM ( SELECT *,CASE WHEN USER1_ID=1 THEN USER2_ID ELSE USER1_ID END AS F1 FROM FRIENDSHIP WHERE USER1_ID = '1' OR USER2_ID='1' ) T JOIN LIKES L ON T.F1=L.USER_ID WHERE L.PAGE_ID NOT IN ( SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(1) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID WHERE TRANSACTIONS.TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT DISTINCT INVOICE_ID, CUSTOMER_NAME AS CUSTOMER_NAME, PRICE, COALESCE(CONTACTS_CNT,0) AS CONTACTS_CNT, COUNT(CONTACT_EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN (SELECT USER_ID, COUNT(DISTINCT CONTACT_EMAIL) AS CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID) C ON I.USER_ID = C.USER_ID LEFT JOIN (SELECT CU.CUSTOMER_ID, CUSTOMER_NAME, CONTACT_EMAIL FROM CUSTOMERS CU LEFT JOIN (SELECT USER_ID,CONTACT_EMAIL FROM CONTACTS WHERE CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS)) CC ON CU.CUSTOMER_ID = CC.USER_ID ) B ON B.CUSTOMER_ID = I.USER_ID GROUP BY INVOICE_ID, CUSTOMER_NAME, PRICE,COALESCE(CONTACTS_CNT,0) ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRODUCT_ID, ROUND(SUM(INDIV_PRICE) / SUM(UNITS), 2) AS AVERAGE_PRICE FROM (SELECT P.PRODUCT_ID, U.UNITS, U.UNITS * P.PRICE AS INDIV_PRICE FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE <= P.END_DATE AND U.PURCHASE_DATE >= P.START_DATE ) DT GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] WITH LOGINS AS (SELECT ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT FROM LOGINFO) SELECT DISTINCT A.ACCOUNT_ID FROM LOGINS A INNER JOIN LOGINS B ON (A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS <> B.IP_ADDRESS AND (A.LOGIN BETWEEN B.LOGIN AND B.LOGOUT OR B.LOGIN BETWEEN A.LOGIN AND A.LOGOUT));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID,PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE<'2019-01-01' OR SALE_DATE>'2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH NOT_2019_Q1 AS ( SELECT * FROM SALES WHERE SALE_DATE <'2019-01-01' OR SALE_DATE >'2019-03-31' ) SELECT DISTINCT PRODUCT_ID , PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM NOT_2019_Q1 );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES AS T1 INNER JOIN PRODUCT USING(PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON (V.VISIT_ID = T.VISIT_ID) WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID,S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID=D.ID WHERE S.DEPARTMENT_ID NOT IN (SELECT DISTINCT ID FROM DEPARTMENTS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND(AVG(E.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM EMPLOYEE E JOIN PROJECT P ON P.EMPLOYEE_ID=E.EMPLOYEE_ID GROUP BY P.PROJECT_ID ORDER BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>=2;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID=1 UNION ALL SELECT USER1_ID FROM FRIENDSHIP WHERE USER2_ID=1) AND PAGE_ID NOT IN (SELECT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] (SELECT V.CUSTOMER_ID,COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID=T.VISIT_ID WHERE AMOUNT IS NULL GROUP BY V.CUSTOMER_ID);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES, PRODUCT WHERE BUYER_ID IN (SELECT BUYER_ID FROM SALES S, PRODUCT P WHERE S.PRODUCT_ID = P.PRODUCT_ID AND P.PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S, PRODUCT P WHERE S.PRODUCT_ID = P.PRODUCT_ID AND P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID AS PRODUCT_ID, ROUND(SUM(UNITS * PRICE) / SUM(UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD US LEFT JOIN PRICES P ON US.PRODUCT_ID = P.PRODUCT_ID AND P.START_DATE <= US.PURCHASE_DATE AND P.END_DATE >= US.PURCHASE_DATE GROUP BY P.PRODUCT_ID ORDER BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND S.BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(ID) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS ) GROUP BY CUSTOMER_ID ORDER BY 2 DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT OUTER JOIN TRANSACTIONS USING(VISIT_ID) WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT DISTINCT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT A.EMAIL AS EMAIL FROM (SELECT * FROM PERSON)A , (SELECT * FROM PERSON)B WHERE A.ID!=B.ID AND A.EMAIL=B.EMAIL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID NOT IN (2) OR REFEREE_ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON , COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS A WHERE ACTION_DATE='2019-07-04' AND ACTION='REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A JOIN LOGINFO B ON A.ACCOUNT_ID=B.ACCOUNT_ID AND B.LOGIN BETWEEN A.LOGIN AND A.LOGOUT AND A.IP_ADDRESS != B.IP_ADDRESS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(*) AS COUNT_NO_TRANS FROM VISITS A LEFT JOIN TRANSACTIONS B ON A.VISIT_ID= B.VISIT_ID WHERE B.TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID ORDER BY CUSTOMER_ID DESC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM (SELECT DISTINCT EMAIL, COUNT(*) AS CNT FROM PERSON GROUP BY EMAIL) AS E WHERE CNT>1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON T.VISIT_ID = V.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA REPORT_REASON, COUNT(DISTINCT POST_ID) REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' GROUP BY EXTRA HAVING EXTRA IS NOT NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE1 AS( SELECT S.BUYER_ID, SUM(CASE WHEN P.PRODUCT_NAME='S8' THEN 1 ELSE 0 END) AS S8_FLG, SUM(CASE WHEN P.PRODUCT_NAME='IPHONE' THEN 1 ELSE 0 END) AS IPHONE_FLG FROM SALES AS S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID ) SELECT BUYER_ID FROM CTE1 WHERE S8_FLG >= '1' AND IPHONE_FLG='0';\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE> '2019-01-01' AND SALE_DATE <'2019-03-31' AND PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE <'2018-12-31' OR SALE_DATE >'2019-04-01'))A ON P.PRODUCT_ID = A.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE V.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME AS CUSTOMERS FROM CUSTOMERS C LEFT OUTER JOIN ORDERS O ON C.ID = O.CUSTOMERID WHERE O.CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH TAX_R AS( SELECT COMPANY_ID, CASE WHEN MAX(SALARY) < 1000 THEN 0 WHEN MAX(SALARY) <= 10000 AND MAX(SALARY) > 1000 THEN 0.24 WHEN MAX(SALARY) > 10000 THEN 0.49 END AS RATIO FROM SALARIES GROUP BY COMPANY_ID ) SELECT T1.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY *(1-RATIO)) AS SALARY FROM SALARIES T1 JOIN TAX_R T2 ON T1.COMPANY_ID = T2.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(P1.X - P2.X)) AS SHORTEST FROM POINT P1 JOIN POINT P2 ON P1.X <> P2.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(DISTINCT A2.PLAYER_ID)/COUNT(DISTINCT A1.PLAYER_ID),2) AS FRACTION FROM ACTIVITY AS A1 LEFT JOIN (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID AND A1.EVENT_DATE = A2.FIRST_DATE + 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] WITH WLS AS( SELECT DISTINCT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND EXTRA IS NOT NULL AND ACTION = 'REPORT' GROUP BY EXTRA ) SELECT * FROM WLS;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT T.PLAYER_ID, A.DEVICE_ID FROM ( SELECT PLAYER_ID, MIN(EVENT_DATE)AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID ) AS T JOIN ACTIVITY AS A ON T.PLAYER_ID = A.PLAYER_ID AND T.MIN_DATE = A.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT EMP.NAME, BON.BONUS FROM EMPLOYEE EMP LEFT JOIN BONUS BON ON EMP.EMPID = BON.EMPID WHERE BON.BONUS < 1000 OR BON.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.UNIQUE_ID, EE.NAME FROM EMPLOYEEUNI AS E RIGHT JOIN EMPLOYEES AS EE ON E.ID = EE.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] WITH SINGLE_NUMS AS ( SELECT NUM, COUNT(*) AS NUM_COUNT FROM MYNUMBERS GROUP BY NUM ) SELECT MAX(NUM) AS NUM FROM SINGLE_NUMS WHERE NUM_COUNT = 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CONTACTTYPES AS ( SELECT A.USER_ID, COUNT(A.CONTACT_NAME) AS CONTACTS, COUNT(B.CUSTOMER_NAME) AS TRUSTED_CONTACTS FROM CONTACTS AS A LEFT JOIN CUSTOMERS AS B ON A.CONTACT_EMAIL = B.EMAIL GROUP BY A.USER_ID ) SELECT A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE, COALESCE(C.CONTACTS,0) AS CONTACTS_CNT, COALESCE(C.TRUSTED_CONTACTS,0) AS TRUSTED_CONTACTS_CNT FROM INVOICES AS A JOIN CUSTOMERS AS B ON A.USER_ID=B.CUSTOMER_ID LEFT JOIN CONTACTTYPES AS C ON A.USER_ID=C.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM ( SELECT DISTINCT BUYER_ID FROM SALES WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'S8') ) S LEFT OUTER JOIN ( SELECT DISTINCT BUYER_ID FROM SALES WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'IPHONE') ) I ON S.BUYER_ID = I.BUYER_ID WHERE I.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH PRODUCTSALES AS ( SELECT S.SELLER_ID, S.PRODUCT_ID, S.BUYER_ID, S.SALE_DATE, S.QUANTITY, S.PRICE, P.PRODUCT_NAME, P.UNIT_PRICE FROM PRODUCT P JOIN SALES S ON S.PRODUCT_ID = P.PRODUCT_ID ), BUYS8 AS ( SELECT DISTINCT BUYER_ID FROM PRODUCTSALES WHERE PRODUCT_NAME = 'S8' ), NOTBUYIPHONE AS ( SELECT DISTINCT BUYER_ID FROM PRODUCTSALES WHERE BUYER_ID NOT IN ( SELECT DISTINCT BUYER_ID FROM PRODUCTSALES WHERE PRODUCT_NAME = 'IPHONE' ) ) SELECT DISTINCT B.BUYER_ID FROM BUYS8 B JOIN NOTBUYIPHONE N ON B.BUYER_ID = N.BUYER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT O.CUSTOMER_ID, CUSTOMER_NAME FROM ORDERS O JOIN CUSTOMERS C ON O.CUSTOMER_ID = C.CUSTOMER_ID GROUP BY C.CUSTOMER_NAME, O.CUSTOMER_ID HAVING SUM(CASE WHEN O.PRODUCT_NAME IN ('A','B') THEN 1 WHEN O.PRODUCT_NAME IN ('C') THEN 0.5 ELSE 0 END)=2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S WHERE DEPARTMENT_ID NOT IN (SELECT DISTINCT ID FROM DEPARTMENTS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE1 AS ( SELECT S.PRODUCT_ID, S.BUYER_ID,P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID ) ,CTE2 AS ( SELECT BUYER_ID, (CASE WHEN PRODUCT_NAME= 'S8' THEN 1 ELSE 0 END)AS S8_FLAG, (CASE WHEN PRODUCT_NAME= 'IPHONE' THEN 1 ELSE 0 END)AS IPHONE_FLAG FROM CTE1 ) SELECT BUYER_ID FROM CTE2 GROUP BY BUYER_ID HAVING SUM(S8_FLAG)>0 AND SUM(IPHONE_FLAG)=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH SALES_LIST AS ( SELECT S.PRODUCT_ID,S.BUYER_ID,P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM SALES_LIST WHERE BUYER_ID IN (SELECT BUYER_ID FROM SALES_LIST WHERE PRODUCT_NAME='S8' ) AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES_LIST WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT(CUSTOMER_ID) , COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM ( SELECT CUSTOMER_ID FROM VISITS WHERE VISIT_ID NOT IN ( SELECT DISTINCT(VISIT_ID) FROM TRANSACTIONS ) ) AS N GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AVERAGE_YEARS FROM PROJECT LEFT JOIN EMPLOYEE USING (EMPLOYEE_ID) GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT A.INVOICE_ID, A.CUSTOMER_NAME, A.PRICE, (CASE WHEN A.CONTACTS_CNT IS NULL THEN 0 ELSE A.CONTACTS_CNT END) AS CONTACTS_CNT, (CASE WHEN B.TRUSTED_CONTACTS_CNT IS NULL THEN 0 ELSE B.TRUSTED_CONTACTS_CNT END ) AS TRUSTED_CONTACTS_CNT FROM (SELECT INVOICE_ID, CUSTOMER_ID, CUSTOMER_NAME, PRICE, COUNT(DISTINCT CONTACTS.CONTACT_EMAIL) AS CONTACTS_CNT FROM INVOICES INNER JOIN CUSTOMERS ON INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID LEFT JOIN CONTACTS ON CUSTOMERS.CUSTOMER_ID = CONTACTS.USER_ID GROUP BY INVOICE_ID, CUSTOMER_ID, CUSTOMER_NAME, PRICE) A LEFT JOIN (SELECT INVOICE_ID, CUSTOMER_ID, CUSTOMER_NAME, PRICE, COUNT(DISTINCT CONTACTS.CONTACT_EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES INNER JOIN CUSTOMERS ON INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID LEFT JOIN CONTACTS ON CUSTOMERS.CUSTOMER_ID = CONTACTS.USER_ID WHERE CONTACTS.CONTACT_EMAIL IN (SELECT DISTINCT EMAIL FROM CUSTOMERS) GROUP BY INVOICE_ID, CUSTOMER_ID, CUSTOMER_NAME, PRICE) B ON A.INVOICE_ID = B.INVOICE_ID AND A.CUSTOMER_ID = B.CUSTOMER_ID ORDER BY A.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(BASE.TIV_2016) AS TIV_2016 FROM ( SELECT A.PID, A.TIV_2016 FROM (SELECT * FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM (SELECT TIV_2015, COUNT(*) AS N FROM INSURANCE GROUP BY TIV_2015)BASE15 WHERE N>1) ) A LEFT JOIN INSURANCE B ON A.PID !=B.PID AND A.LAT=B.LAT AND A.LON=B.LON WHERE B.PID IS NULL )BASE;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND((1-SUB.TAX_RATE)*S.SALARY) AS SALARY FROM SALARIES S JOIN ( SELECT COMPANY_ID, CASE WHEN MAX(SALARY) < 1000 THEN 0 WHEN MAX(SALARY) <= 10000 THEN 0.24 ELSE 0.49 END AS TAX_RATE FROM SALARIES GROUP BY COMPANY_ID ) SUB ON S.COMPANY_ID = SUB.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT DISTINCT P.PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT AS P LEFT JOIN EMPLOYEE AS E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH TEMP AS ( SELECT USER2_ID AS ID FROM FRIENDSHIP WHERE USER1_ID='1' UNION SELECT USER1_ID AS ID FROM FRIENDSHIP WHERE USER2_ID='1' ) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT * FROM TEMP) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID='1');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID AS ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID=L2.ACCOUNT_ID WHERE L1.IP_ADDRESS <> L2.IP_ADDRESS AND L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*) = 1) Y;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(DISTANCE) AS SHORTEST FROM( SELECT ABS(A.X - B.X) AS DISTANCE FROM POINT A CROSS JOIN POINT B WHERE A.X != B.X) AS TEMP;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE V.VISIT_ID = T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A, LOGINFO B WHERE A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS <> B.IP_ADDRESS AND B.LOGIN BETWEEN A.LOGIN AND A.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH CTE AS ( SELECT I1.PID FROM INSURANCE AS I1 JOIN INSURANCE AS I2 ON I1.TIV_2015=I2.TIV_2015 AND I1.PID!=I2.PID ), CTE2 AS ( SELECT I1.PID FROM INSURANCE AS I1 JOIN INSURANCE AS I2 ON I1.LAT=I2.LAT AND I1.LON=I2.LON AND I1.PID<>I2.PID ), DEMO AS ( SELECT DISTINCT PID FROM CTE WHERE PID NOT IN (SELECT PID FROM CTE2) ) SELECT SUM(I.TIV_2016) AS TIV_2016 FROM DEMO AS D JOIN INSURANCE AS I ON D.PID=I.PID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH T AS (SELECT U.PRODUCT_ID, PURCHASE_DATE, UNITS, P.PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) SELECT PRODUCT_ID, ROUND(SUM(UNITS * PRICE) / SUM(UNITS),2) AS AVERAGE_PRICE FROM T GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(N.NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) N;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM (SELECT VIEWER_ID, VIEW_DATE, COUNT(DISTINCT ARTICLE_ID) AS NUM_ARTICLES FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE) AS A WHERE NUM_ARTICLES>1 GROUP BY VIEWER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID ,COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM ( SELECT CUSTOMER_ID ,TRANSACTION_ID FROM ( SELECT VISIT_ID ,CUSTOMER_ID FROM VISITS ) V LEFT JOIN ( SELECT TRANSACTION_ID ,VISIT_ID FROM TRANSACTIONS ) T ON V.VISIT_ID = T.VISIT_ID ) A WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT PERSON.FIRSTNAME, PERSON.LASTNAME, ADDRESS.CITY, ADDRESS.STATE FROM PERSON LEFT OUTER JOIN ADDRESS ON (PERSON.PERSONID = ADDRESS.PERSONID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V WHERE V.VISIT_ID NOT IN (SELECT T.VISIT_ID FROM TRANSACTIONS T) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT T1.INVOICE_ID , T2.CUSTOMER_NAME , T1.PRICE , COUNT(T3.USER_ID) AS CONTACTS_CNT , COUNT(T4.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES AS T1 INNER JOIN CUSTOMERS AS T2 ON T2.CUSTOMER_ID = T1.USER_ID LEFT JOIN CONTACTS AS T3 ON T3.USER_ID = T2.CUSTOMER_ID LEFT JOIN CUSTOMERS AS T4 ON T4.EMAIL = T3.CONTACT_EMAIL GROUP BY T1.INVOICE_ID, T2.CUSTOMER_NAME, T1.PRICE ORDER BY T1.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT U.UNIQUE_ID AS UNIQUE_ID , E.NAME AS NAME FROM EMPLOYEEUNI U RIGHT JOIN EMPLOYEES E ON E.ID=U.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH CTE AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID ) SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN (SELECT PLAYER_ID, MIN_EVENT_DATE FROM CTE);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH T1 AS (SELECT T_A.CUSTOMER_ID FROM (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') T_A JOIN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') T_B ON T_A.CUSTOMER_ID = T_B.CUSTOMER_ID) SELECT DISTINCT T1.CUSTOMER_ID, CUSTOMER_NAME FROM T1 JOIN CUSTOMERS C ON T1.CUSTOMER_ID=C.CUSTOMER_ID AND T1.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C2.NAME AS CUSTOMERS FROM CUSTOMERS C2 WHERE C2.ID NOT IN (SELECT O.CUSTOMERID FROM CUSTOMERS C, ORDERS O WHERE C.ID = O.CUSTOMERID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM (SELECT TIV_2015, COUNT(*) AS CNT FROM INSURANCE GROUP BY TIV_2015) TBL1 WHERE CNT > 1) AND (LAT,LON) IN ( SELECT LAT, LON FROM (SELECT LAT, LON, COUNT(*) CNT FROM INSURANCE GROUP BY LAT,LON) TBL2 WHERE CNT = 1 );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS (SELECT S.BUYER_ID, S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION ALL SELECT USER1_ID FROM FRIENDSHIP WHERE USER2_ID = 1) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1) GROUP BY PAGE_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME AS NAME, B.BONUS AS BONUS FROM EMPLOYEE AS E LEFT JOIN BONUS AS B ON E.EMPID = B.EMPID WHERE B.BONUS IS NULL OR B.BONUS < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM (SELECT DISTINCT I1.* FROM INSURANCE I1 JOIN INSURANCE I2 ON I1.TIV_2015 = I2.TIV_2015 AND I1.PID <> I2.PID AND (I1.LAT <> I2.LAT OR I1.LON <> I2.LON) AND (I1.LAT,I1.LON) IN (SELECT DISTINCT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*) = 1))A;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT(POST_ID)) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE ='2019-07-04' AND ACTION='REPORT' GROUP BY EXTRA HAVING EXTRA IS NOT NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A' OR PRODUCT_NAME = 'B' GROUP BY CUSTOMER_ID HAVING COUNT(DISTINCT PRODUCT_NAME) = 2) AND CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES JOIN PRODUCT USING(PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE PRODUCT_NAME WHEN 'S8' THEN 1 ELSE 0 END)>0 AND SUM(CASE PRODUCT_NAME WHEN 'IPHONE' THEN 1 ELSE 0 END)=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH TMP AS( SELECT A.USER_ID , COUNT(A.CONTACT_EMAIL) AS CONTACTS_CNT , COUNT(B.EMAIL) AS TRUSTED_CONTACTS_CNT FROM CONTACTS A LEFT JOIN CUSTOMERS B ON A.CONTACT_EMAIL = B.EMAIL GROUP BY USER_ID ) SELECT A.INVOICE_ID , B.CUSTOMER_NAME , A.PRICE , CASE WHEN C.CONTACTS_CNT IS NULL THEN 0 ELSE C.CONTACTS_CNT END AS CONTACTS_CNT , CASE WHEN C.TRUSTED_CONTACTS_CNT IS NULL THEN 0 ELSE C.TRUSTED_CONTACTS_CNT END AS TRUSTED_CONTACTS_CNT FROM INVOICES A JOIN CUSTOMERS B ON A.USER_ID = B.CUSTOMER_ID LEFT JOIN TMP C ON A.USER_ID = C.USER_ID ORDER BY A.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='C' ) AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='B');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1, LOGINFO L2 WHERE L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS <> L2.IP_ADDRESS AND (L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT OR L1.LOGOUT BETWEEN L2.LOGIN AND L2.LOGOUT);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(CON.USER_ID) AS CONTACTS_CNT, COUNT(C1.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS CON ON C.CUSTOMER_ID = CON.USER_ID LEFT JOIN CUSTOMERS C1 ON C1.EMAIL = CON.CONTACT_EMAIL GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH CTE AS ( SELECT DISTINCT P.PRODUCT_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE < '2019-01-01' OR S.SALE_DATE > '2019-03-31' ) SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM CTE);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH A AS(SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID=1 UNION SELECT USER1_ID FROM FRIENDSHIP WHERE USER2_ID=1) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES L JOIN A ON A.USER2_ID=L.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH TB AS (SELECT U.PRODUCT_ID, U.PURCHASE_DATE, U.UNITS, P.PRICE FROM UNITSSOLD U INNER JOIN PRICES P ON U.PRODUCT_ID=P.PRODUCT_ID AND U.PURCHASE_DATE >= P.START_DATE AND U.PURCHASE_DATE <= P.END_DATE) SELECT PRODUCT_ID, ROUND(SUM(UNITS*PRICE)/SUM(UNITS),2) AS AVERAGE_PRICE FROM TB GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT SALARIES.COMPANY_ID, SALARIES.EMPLOYEE_ID, SALARIES.EMPLOYEE_NAME, ROUND((1 - TAX_RATE) * SALARY) AS SALARY FROM SALARIES INNER JOIN ( SELECT COMPANY_ID, ( CASE WHEN MAX(SALARY) < 1000 THEN .0 WHEN MAX(SALARY) >= 1000 AND MAX(SALARY) <= 10000 THEN .24 ELSE .49 END ) AS TAX_RATE FROM SALARIES GROUP BY COMPANY_ID ) AS TAX ON SALARIES.COMPANY_ID = TAX.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH NT1 AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID ) SELECT ACTIVITY.PLAYER_ID, ACTIVITY.DEVICE_ID FROM ACTIVITY INNER JOIN NT1 ON ACTIVITY.PLAYER_ID= NT1.PLAYER_ID AND ACTIVITY.EVENT_DATE=NT1.FIRST_LOGIN;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN , COUNT(DURATION) TOTAL FROM SESSIONS WHERE DURATION < 300 UNION SELECT '[5-10>' AS BIN , COUNT(DURATION) TOTAL FROM SESSIONS WHERE DURATION BETWEEN 300 AND 599 UNION SELECT '[10-15>' AS BIN , COUNT(DURATION) TOTAL FROM SESSIONS WHERE DURATION BETWEEN 600 AND 899 UNION SELECT '15 OR MORE AS BIN', COUNT(DURATION) TOTAL FROM SESSIONS WHERE DURATION > 899;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE PRODUCT_ID NOT IN(SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM ( SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*) = 1 ) T;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(U.UNITS * P.PRICE) / SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD AS U LEFT JOIN PRICES AS P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE >= P.START_DATE AND U.PURCHASE_DATE <= P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON (S.PRODUCT_ID = P.PRODUCT_ID) WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES A JOIN PRODUCT B ON (A.PRODUCT_ID = B.PRODUCT_ID) AND B.PRODUCT_NAME = 'IPHONE') AND P.PRODUCT_NAME ='S8' GROUP BY S.BUYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT A.PRODUCT_ID, A.STORE, A.PRICE FROM (SELECT PRODUCT_ID, STORE1 AS PRICE, 'STORE1' AS STORE FROM PRODUCTS UNION SELECT PRODUCT_ID, STORE2 AS PRICE, 'STORE2' AS STORE FROM PRODUCTS UNION SELECT PRODUCT_ID, STORE3 AS PRICE, 'STORE3' AS STORE FROM PRODUCTS) AS A WHERE A.PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS,COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME ORDER BY MAKE_NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT P.FIRSTNAME, P.LASTNAME, A.CITY, A.STATE FROM PERSON P LEFT OUTER JOIN ADDRESS A ON P.PERSONID = A.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES RIGHT JOIN ( SELECT USER2_ID ID FROM FRIENDSHIP WHERE USER1_ID=1 UNION SELECT USER1_ID ID FROM FRIENDSHIP WHERE USER2_ID=1 )MAIN ON USER_ID=ID WHERE (1,PAGE_ID) NOT IN (SELECT USER_ID,PAGE_ID FROM LIKES) AND PAGE_ID IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT T1.BUYER_ID FROM SALES T1 INNER JOIN PRODUCT T2 ON T1.PRODUCT_ID = T2.PRODUCT_ID GROUP BY T1.BUYER_ID HAVING( SUM(CASE WHEN T2.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END )>0 AND SUM(CASE WHEN T2.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END )=0 );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID ,COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID=T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRICES.PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM PRICES LEFT JOIN UNITSSOLD ON PRICES.PRODUCT_ID = UNITSSOLD.PRODUCT_ID AND PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY PRICES.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.VIEWER_ID AS ID FROM VIEWS V1 JOIN VIEWS V2 ON V1.VIEWER_ID = V2.VIEWER_ID WHERE V1.VIEW_DATE=V2.VIEW_DATE AND V1.ARTICLE_ID != V2.ARTICLE_ID ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM( SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T1 WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND P.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.VISIT_ID IS NULL GROUP BY CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 UNION SELECT NAME, POPULATION, AREA FROM WORLD WHERE POPULATION >= 25000000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(DISTINCT T.PLAYER_ID)/(SELECT COUNT(DISTINCT PLAYER_ID) FROM ACTIVITY),2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS T JOIN ACTIVITY A ON T.PLAYER_ID = A.PLAYER_ID AND T.EVENT_DATE = A.EVENT_DATE - 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH WATCH_CNT AS ( SELECT VIEWER_ID, VIEW_DATE FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID) > 1) SELECT DISTINCT VIEWER_ID AS ID FROM WATCH_CNT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH SAME_TIV_2015 AS (SELECT I.TIV_2015 FROM INSURANCE I GROUP BY I.TIV_2015 HAVING COUNT(I.TIV_2015)>1), DIFF_LAT AS (SELECT I2.LAT, I2.LON FROM INSURANCE I2 GROUP BY I2.LAT, I2.LON HAVING(COUNT(I2.LAT)=1)) SELECT SUM(I3.TIV_2016) AS TIV_2016 FROM INSURANCE I3 WHERE I3.TIV_2015 IN (SELECT TIV_2015 FROM SAME_TIV_2015) AND (I3.LAT,I3.LON) IN (SELECT LAT,LON FROM DIFF_LAT);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] WITH AGG AS ( SELECT CLASS , COUNT(CLASS) AS NUMBER FROM COURSES GROUP BY CLASS) SELECT CLASS FROM AGG WHERE NUMBER >=5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) =0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID , 'STORE1' AS STORE , STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID , 'STORE2' AS STORE , STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION SELECT PRODUCT_ID , 'STORE3' AS STORE , STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] WITH R AS ( SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE DURATION >= 0 AND DURATION < 300 UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE DURATION >= 300 AND DURATION < 600 UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE DURATION >= 600 AND DURATION < 900 UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE DURATION >= 900 ) SELECT * FROM R;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH T2 AS ( SELECT USER_ID, COUNT(CONTACT_EMAIL) AS CONTACTS_CNT, SUM(TRUSTED_CONTACT_FLAG) AS TRUSTED_CONTACTS_CNT FROM (SELECT USER_ID, CONTACT_EMAIL, CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END AS TRUSTED_CONTACT_FLAG FROM CONTACTS) T1 GROUP BY USER_ID) SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE,COALESCE(T2.CONTACTS_CNT,0) AS CONTACTS_CNT,COALESCE(T2.TRUSTED_CONTACTS_CNT,0) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN T2 ON I.USER_ID = T2.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID, COUNT(A.CUSTOMER_ID) COUNT_NO_TRANS FROM VISITS A WHERE A.VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY A.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID < 2 OR REFEREE_ID IS NULL OR REFEREE_ID > 2;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH SALES_CTE AS( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' GROUP BY SELLER_ID,PRODUCT_ID,BUYER_ID,SALE_DATE ) SELECT PRODUCT_ID,PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT * FROM SALES_CTE );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM (SELECT S.BUYER_ID, CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END AS S8, CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END AS IPHONE FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID) TEMP1 GROUP BY BUYER_ID HAVING SUM(S8) > 0 AND SUM(IPHONE) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS USING(VISIT_ID) WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] SELECT INSTALL_DT, COUNT(PLAYER_ID) AS INSTALLS, ROUND(COUNT(NEXT_DAY)/ COUNT(PLAYER_ID), 2) AS DAY1_RETENTION FROM ( SELECT A1.PLAYER_ID, A1.INSTALL_DT, A2.EVENT_DATE AS NEXT_DAY FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS INSTALL_DT FROM ACTIVITY GROUP BY PLAYER_ID) A1 LEFT JOIN ACTIVITY A2 ON A1.PLAYER_ID = A2.PLAYER_ID AND A1.INSTALL_DT + 1 = A2.EVENT_DATE ) T GROUP BY INSTALL_DT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN ( SELECT BUYER_ID FROM SALES WHERE PRODUCT_ID =(SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'S8')) AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES WHERE PRODUCT_ID =(SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'IPHONE'));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH TMP AS( SELECT CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_EMAIL) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS LEFT JOIN CONTACTS ON CUSTOMER_ID = USER_ID GROUP BY CUSTOMER_ID, CUSTOMER_NAME ) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES JOIN TMP ON USER_ID = CUSTOMER_ID ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.AUTHOR_ID AS ID FROM VIEWS V1 JOIN VIEWS V2 ON V1.ARTICLE_ID = V2.ARTICLE_ID AND V1.AUTHOR_ID = V2.VIEWER_ID ORDER BY V1.AUTHOR_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM (SELECT * FROM ACTIONS WHERE EXTRA IS NOT NULL) AS A2 WHERE ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' GROUP BY EXTRA HAVING COUNT(EXTRA) > 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT V.VIEWER_ID AS ID FROM VIEWS V GROUP BY V.VIEW_DATE, V.VIEWER_ID HAVING COUNT(V.VIEWER_ID) > 1 AND COUNT(DISTINCT V.ARTICLE_ID) > 1 ORDER BY V.VIEWER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT UNITSSOLD.PRODUCT_ID, ROUND(SUM(UNITS * PRICE) / SUM(UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD LEFT JOIN PRICES ON (UNITSSOLD.PURCHASE_DATE BETWEEN PRICES.START_DATE AND PRICES.END_DATE) AND PRICES.PRODUCT_ID = UNITSSOLD.PRODUCT_ID GROUP BY UNITSSOLD.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(B.BUYER_ID) FROM SALES B WHERE B.BUYER_ID IN( SELECT B.BUYER_ID FROM SALES B LEFT JOIN PRODUCT A ON A.PRODUCT_ID=B.PRODUCT_ID WHERE A.PRODUCT_NAME='S8') AND B.BUYER_ID NOT IN( SELECT B.BUYER_ID FROM SALES B LEFT JOIN PRODUCT A ON A.PRODUCT_ID=B.PRODUCT_ID WHERE A.PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT EMP.NAME, BN.BONUS FROM EMPLOYEE AS EMP LEFT JOIN BONUS AS BN ON EMP.EMPID = BN.EMPID WHERE BN.BONUS <1000 OR BN.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT AS P INNER JOIN EMPLOYEE AS E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EMU.UNIQUE_ID, EM.NAME FROM EMPLOYEES EM LEFT JOIN EMPLOYEEUNI EMU ON EM.ID=EMU.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2)AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID=P.PRODUCT_ID AND PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(TIV_2015) > 1) AND (LAT, LON) IN( SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(LAT) = 1 AND COUNT(LON) = 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH T AS (SELECT USER_ID, COUNT(CONTACT_NAME) AS CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID), T2 AS (SELECT CO.USER_ID, COUNT(C.CUSTOMER_NAME) AS TRUSTED_CONTACTS_CNT FROM CONTACTS CO LEFT JOIN CUSTOMERS C ON C.CUSTOMER_NAME = CO.CONTACT_NAME AND C.EMAIL = CO.CONTACT_EMAIL GROUP BY CO.USER_ID) SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COALESCE(T.CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(T2.TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN T ON T.USER_ID = I.USER_ID LEFT JOIN T2 ON T2.USER_ID = I.USER_ID ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH TB1 AS ( SELECT COMPANY_ID, CASE WHEN MAX(SALARY) > 10000 THEN 0.51 WHEN MAX(SALARY) < 1000 THEN 1 ELSE 0.76 END AS RATE FROM SALARIES GROUP BY COMPANY_ID) SELECT SALARIES.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY*RATE) AS SALARY FROM SALARIES, TB1 WHERE TB1.COMPANY_ID = SALARIES.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES INNER JOIN PRODUCT USING(PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] SELECT INSTALL_DT, COUNT(INSTALL_DT) AS INSTALLS, ROUND(COUNT(A.EVENT_DATE)/COUNT(INSTALL_DT),2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS INSTALL_DT FROM ACTIVITY GROUP BY PLAYER_ID) AS B LEFT JOIN ACTIVITY A ON A.EVENT_DATE = B.INSTALL_DT + 1 AND B.PLAYER_ID = A.PLAYER_ID GROUP BY INSTALL_DT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.NAME, EU.UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EU ON E.ID = EU.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT DISTINCT E.NAME, B.BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE B.BONUS < 1000 OR B.BONUS IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM (SELECT DISTINCT * FROM VIEWS)W GROUP BY VIEWER_ID,VIEW_DATE HAVING COUNT(VIEWER_ID)>1 ORDER BY VIEWER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(P1.X-P2.X) AS SHORTEST FROM POINT P1 CROSS JOIN POINT P2 WHERE ABS(P1.X-P2.X) != 0 ORDER BY SHORTEST ASC LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT T1.PROJECT_ID,ROUND(AVG(T2.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT T1 LEFT JOIN EMPLOYEE T2 ON T1.EMPLOYEE_ID = T2.EMPLOYEE_ID GROUP BY T1.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] WITH CTE_LEAD AS ( SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME ), CTE_PARTNER AS ( SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME ) SELECT A.DATE_ID, A.MAKE_NAME, A.UNIQUE_LEADS, B.UNIQUE_PARTNERS FROM CTE_LEAD A INNER JOIN CTE_PARTNER B ON A.DATE_ID = B.DATE_ID AND A.MAKE_NAME = B.MAKE_NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1, LOGINFO L2 WHERE L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS != L2.IP_ADDRESS AND L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM ( SELECT PRODUCT_ID, 'STORE1' STORE, STORE1 PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' STORE, STORE2 PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' STORE, STORE3 PRICE FROM PRODUCTS ) T WHERE PRICE IS NOT NULL ORDER BY PRODUCT_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM FRIENDSHIP AS F INNER JOIN LIKES AS L ON (F.USER1_ID=1 OR F.USER2_ID=1) AND (F.USER1_ID = L.USER_ID OR F.USER2_ID = L.USER_ID) WHERE L.PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT A.ID AS ID, A.NAME AS NAME FROM STUDENTS A LEFT JOIN DEPARTMENTS B ON A.DEPARTMENT_ID = B.ID WHERE B.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT G.VIEWER_ID AS ID FROM (SELECT DISTINCT V.VIEWER_ID, V.ARTICLE_ID, V.VIEW_DATE FROM VIEWS V) G, (SELECT DISTINCT V.VIEWER_ID, V.ARTICLE_ID, V.VIEW_DATE FROM VIEWS V) P WHERE P.ARTICLE_ID != G.ARTICLE_ID AND P.VIEW_DATE = G.VIEW_DATE AND P.VIEWER_ID = G.VIEWER_ID ORDER BY G.VIEWER_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT A.NAME, B.BONUS FROM EMPLOYEE A LEFT OUTER JOIN BONUS B USING (EMPID) WHERE B.BONUS < 1000 OR B.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT X.NAME, Y.BONUS FROM EMPLOYEE AS X LEFT JOIN BONUS Y ON X.EMPID = Y.EMPID WHERE Y.BONUS IS NULL OR Y.BONUS < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH FIRST_LOGIN_PER_PLAYER AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A, FIRST_LOGIN_PER_PLAYER F WHERE A.PLAYER_ID = F.PLAYER_ID AND F.FIRST_LOGIN = A.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A RIGHT JOIN (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_DATE FROM ACTIVITY GROUP BY PLAYER_ID) F ON A.PLAYER_ID = F.PLAYER_ID AND A.EVENT_DATE = F.FIRST_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE AS (SELECT COMPANY_ID, MAX(SALARY) AS MAXIMUM FROM SALARIES GROUP BY COMPANY_ID) SELECT COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY FROM SALARIES WHERE COMPANY_ID IN (SELECT COMPANY_ID FROM CTE WHERE MAXIMUM <1000) UNION SELECT COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY*0.76,0) FROM SALARIES WHERE COMPANY_ID IN (SELECT COMPANY_ID FROM CTE WHERE MAXIMUM >= 1000 AND MAXIMUM <=10000) UNION SELECT COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY*0.51,0) FROM SALARIES WHERE COMPANY_ID IN (SELECT COMPANY_ID FROM CTE WHERE MAXIMUM >=10000);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH CTE AS ( SELECT DISTINCT A.CUSTOMER_ID FROM ORDERS A INNER JOIN ORDERS B ON A.CUSTOMER_ID = B.CUSTOMER_ID WHERE A.PRODUCT_NAME = 'A' AND B.PRODUCT_NAME = 'B' AND A.CUSTOMER_ID NOT IN ( SELECT DISTINCT C.CUSTOMER_ID FROM ORDERS C WHERE C.PRODUCT_NAME = 'C' ) ) SELECT CTE.CUSTOMER_ID , C.CUSTOMER_NAME FROM CTE INNER JOIN CUSTOMERS C ON CTE.CUSTOMER_ID = C.CUSTOMER_ID ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] (SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(DISTINCT STUDENT) >= 5);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC, CUSTOMER_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(P.X-P1.X)) SHORTEST FROM POINT P, POINT P1 WHERE P.X <>P1.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(SUM(EXPERIENCE_YEARS) / COUNT(PROJECT_ID), 2) AS AVERAGE_YEARS FROM (SELECT P.PROJECT_ID, E.EXPERIENCE_YEARS FROM EMPLOYEE AS E JOIN PROJECT AS P ON P.EMPLOYEE_ID = E.EMPLOYEE_ID) AS A GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT D1.ACTOR_ID, D1.DIRECTOR_ID FROM ACTORDIRECTOR D1 GROUP BY ACTOR_ID, DIRECTOR_ID HAVING COUNT(DIRECTOR_ID) >=3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) >0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) =0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID , ROUND(SUM(EXPERIENCE_YEARS)/COUNT(*),2) AS AVERAGE_YEARS FROM PROJECT P LEFT JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E1.NAME, E2.UNIQUE_ID FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM ( SELECT * FROM VISITS V WHERE VISIT_ID NOT IN ( SELECT VISIT_ID FROM TRANSACTIONS T ) ) A GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A' ) AND CUSTOMER_ID IN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B' ) AND CUSTOMER_ID NOT IN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C' ) ORDER BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH CTE AS (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A' ) SELECT C.CUSTOMER_ID, CUSTOMER_NAME FROM (SELECT CUSTOMER_ID FROM ORDERS O WHERE PRODUCT_NAME = 'B' AND CUSTOMER_ID IN (SELECT * FROM CTE) AND CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C' ) ) AS K LEFT JOIN CUSTOMERS AS C ON C.CUSTOMER_ID = K.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT D.DATE_ID, D.MAKE_NAME, COUNT(DISTINCT D.LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT D.PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES D GROUP BY D.DATE_ID, D.MAKE_NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH TEMP AS( SELECT COMPANY_ID , MAX(SALARY) AS MAX_SAL , CASE WHEN MAX(SALARY) < 1000 THEN 0 WHEN MAX(SALARY) BETWEEN 1000 AND 10000 THEN 24 WHEN MAX(SALARY) > 10000 THEN 49 END AS TAX FROM SALARIES GROUP BY COMPANY_ID) SELECT SALARIES.COMPANY_ID , EMPLOYEE_ID , EMPLOYEE_NAME , ROUND((SALARY - ((SALARY*TAX)/100))) AS SALARY FROM SALARIES JOIN TEMP ON TEMP.COMPANY_ID = SALARIES.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.VIEWER_ID AS ID FROM VIEWS V1 INNER JOIN VIEWS V2 ON V1.VIEWER_ID = V2.VIEWER_ID AND V1.VIEW_DATE = V2.VIEW_DATE WHERE V1.ARTICLE_ID != V2.ARTICLE_ID ORDER BY V1.VIEWER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] WITH CTE AS ( SELECT P.PROJECT_ID,P.EMPLOYEE_ID, E.EXPERIENCE_YEARS FROM PROJECT P LEFT JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID) SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM CTE GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT A.NAME, B.UNIQUE_ID FROM EMPLOYEES A LEFT JOIN EMPLOYEEUNI B ON A.ID=B.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.AMOUNT IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM (SELECT BUYER_ID, SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS BUYS8 , SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS BUYIPHONE FROM (SELECT S.BUYER_ID, S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID) T1 GROUP BY BUYER_ID) T2 WHERE BUYS8 >0 AND BUYIPHONE = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT C.CLASS FROM (SELECT DISTINCT STUDENT, CLASS FROM COURSES ) AS C GROUP BY C.CLASS HAVING COUNT(*) >= 5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.NAME, E1.UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI E1 ON E.ID = E1.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRODUCT_ID, ROUND(SUM(REVENUE) / SUM(UNITS),2) AS AVERAGE_PRICE FROM ( SELECT A.PRODUCT_ID, A.UNITS, B.PRICE*A.UNITS AS REVENUE FROM UNITSSOLD A LEFT JOIN PRICES B ON B.START_DATE <= A.PURCHASE_DATE AND A.PURCHASE_DATE <= B.END_DATE AND A.PRODUCT_ID = B.PRODUCT_ID ) T GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT B.PLAYER_ID, A.DEVICE_ID FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) B JOIN ACTIVITY A ON B.PLAYER_ID = A.PLAYER_ID AND B.FIRST_LOGIN = A.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT DISTINCT US.PRODUCT_ID, ROUND( SUM(US.UNITS*P.PRICE)/SUM(US.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD US, PRICES P WHERE US.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE AND US.PRODUCT_ID = P.PRODUCT_ID GROUP BY US.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH INV AS ( SELECT I.INVOICE_ID, C.CUSTOMER_ID, C.CUSTOMER_NAME, I.PRICE FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID ), CTCT AS ( SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME, COUNT(DISTINCT T.CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN T.CONTACT_NAME IN (SELECT DISTINCT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS C LEFT JOIN CONTACTS T ON C.CUSTOMER_ID = T.USER_ID GROUP BY C.CUSTOMER_ID, C.CUSTOMER_NAME ) SELECT INV.INVOICE_ID, INV.CUSTOMER_NAME, INV.PRICE, CTCT.CONTACTS_CNT, CTCT.TRUSTED_CONTACTS_CNT FROM INV JOIN CTCT ON INV.CUSTOMER_ID = CTCT.CUSTOMER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE PID IN (SELECT PID FROM INSURANCE WHERE TIV_2015 IN(SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(TIV_2015) > 1) AND (LAT, LON) NOT IN(SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*) > 1));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH DATA AS ( SELECT USER1_ID AS USER_ID, USER2_ID AS FRIENDSWITH FROM FRIENDSHIP WHERE USER1_ID =1 UNION ALL SELECT USER2_ID AS USER_ID, USER1_ID AS FRIENDSWITH FROM FRIENDSHIP WHERE USER2_ID = 1) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM DATA D JOIN LIKES L ON D.FRIENDSWITH = L.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES L WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(P1.X - P2.X) AS SHORTEST FROM POINT P1 INNER JOIN POINT P2 ON P1.X != P2.X ORDER BY ABS(P1.X - P2.X) ASC LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID AS CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH SALESINFO AS (SELECT PRODUCT_ID , SUM(CASE WHEN SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' THEN 1 ELSE 0 END) AS FLAG FROM SALES GROUP BY PRODUCT_ID) SELECT PRODUCT_ID , PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM SALESINFO WHERE FLAG = 0);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM EMPLOYEE E LEFT OUTER JOIN BONUS B ON E.EMPID = B.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT US.PRODUCT_ID, ROUND(SUM(P.PRICE*US.UNITS)/SUM(US.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD US LEFT JOIN PRICES P ON P.PRODUCT_ID=US.PRODUCT_ID AND US.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY US.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT P.FIRSTNAME,P.LASTNAME,A.CITY,A.STATE FROM PERSON P LEFT OUTER JOIN ADDRESS A ON A.PERSONID=P.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE PID IN (SELECT DISTINCT(A.PID) FROM INSURANCE A JOIN INSURANCE B ON A.TIV_2015 = B.TIV_2015 AND A.PID != B.PID) AND PID NOT IN (SELECT DISTINCT(A.PID) FROM INSURANCE A JOIN INSURANCE B ON A.LAT = B.LAT AND A.LON = B.LON AND A.PID != B.PID);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID AND P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID =P.PRODUCT_ID WHERE PRODUCT_NAME='S8' AND BUYER_ID NOT IN(SELECT BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID =P.PRODUCT_ID WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS ( SELECT * FROM PRODUCT JOIN SALES USING (PRODUCT_ID) ) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME='S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID , ROUND(SUM(U.UNITS*P.PRICE)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID WHERE PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY U.PRODUCT_ID ORDER BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E2.UNIQUE_ID, NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI E2 ON E.ID=E2.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES AS S INNER JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME= 'S8' AND BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES AS S INNER JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE ');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN ( SELECT DISTINCT BUYER_ID FROM SALES S1 INNER JOIN PRODUCT P1 ON S1.PRODUCT_ID =P1.PRODUCT_ID WHERE P1.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT DISTINCT ACTOR_ID, DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID HAVING COUNT(ACTOR_ID = DIRECTOR_ID) >=3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM ( SELECT B.USER_ID, B.PAGE_ID FROM FRIENDSHIP A LEFT JOIN LIKES B ON (A.USER2_ID=B.USER_ID OR A.USER1_ID=B.USER_ID) AND (A.USER1_ID=1 OR A.USER2_ID=1) WHERE B.PAGE_ID NOT IN ( SELECT DISTINCT(PAGE_ID) FROM LIKES WHERE USER_ID=1) ) T;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P USING (PRODUCT_ID) WHERE P.PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES S1 LEFT JOIN PRODUCT P1 USING (PRODUCT_ID) WHERE P1.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S INNER JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND S.PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT TBL1.CLASS FROM ( SELECT CLASS, COUNT(CLASS) AS MYCOUNT FROM COURSES GROUP BY CLASS ) AS TBL1 WHERE TBL1.MYCOUNT >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS AS S LEFT JOIN DEPARTMENTS AS P ON P.ID = S.DEPARTMENT_ID WHERE P.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.NAME, UNIQUE_ID FROM EMPLOYEES AS E LEFT JOIN EMPLOYEEUNI AS EU ON E.ID = EU.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID, COUNT(A.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS A LEFT JOIN TRANSACTIONS B ON A.VISIT_ID = B.VISIT_ID WHERE B.VISIT_ID IS NULL GROUP BY A.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT CASE WHEN A.ID=B.ID THEN B.UNIQUE_ID END AS UNIQUE_ID,A.NAME FROM EMPLOYEES A LEFT JOIN EMPLOYEEUNI B ON A.ID=B.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS LEFT JOIN ORDERS ON ORDERS.CUSTOMERID=CUSTOMERS.ID WHERE CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT PLAYER_ID,DEVICE_ID FROM ACTIVITY A INNER JOIN(SELECT PLAYER_ID PLAYER_ID1,MIN(EVENT_DATE) FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID ORDER BY PLAYER_ID) FA ON A.EVENT_DATE=FA.FIRST_LOGIN AND A.PLAYER_ID=FA.PLAYER_ID1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM DEPARTMENTS AS D RIGHT JOIN STUDENTS AS S ON D.ID = S.DEPARTMENT_ID WHERE D.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, CUSTOMER_NAME, PRICE, COUNT(CON1.CONTACT_EMAIL) AS CONTACTS_CNT, COUNT(CASE WHEN CON1.CONTACT_EMAIL IN (SELECT DISTINCT EMAIL FROM CUSTOMERS) THEN CON1.CONTACT_EMAIL END) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON C.CUSTOMER_ID = I.USER_ID LEFT JOIN CONTACTS CON1 ON CON1.USER_ID = C.CUSTOMER_ID GROUP BY I.INVOICE_ID, CUSTOMER_NAME, PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID,ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID=P.PRODUCT_ID AND (U.PURCHASE_DATE >=P.START_DATE) AND (U.PURCHASE_DATE <=P.END_DATE) GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM ( SELECT CASE WHEN USER1_ID = 1 THEN USER2_ID WHEN USER2_ID = 1 THEN USER1_ID END AS USER_ID FROM FRIENDSHIP ) AS FRIENDS JOIN LIKES ON FRIENDS.USER_ID = LIKES.USER_ID WHERE PAGE_ID NOT IN ( SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1 );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT DISTINCT(DATE_ID), MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS ,COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S1.COMPANY_ID, S1.EMPLOYEE_ID, S1.EMPLOYEE_NAME, ( CASE WHEN N.COMPANY_MAX < 1000 THEN S1.SALARY WHEN N.COMPANY_MAX >= 10000 THEN ROUND(0.51*S1.SALARY, 0) ELSE ROUND(0.76*S1.SALARY, 0) END) AS SALARY FROM SALARIES AS S1 JOIN (SELECT S2.COMPANY_ID, MAX(S2.SALARY) AS COMPANY_MAX FROM SALARIES AS S2 GROUP BY S2.COMPANY_ID) AS N ON S1.COMPANY_ID = N.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(DISTINCT V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH T AS ( SELECT COMPANY_ID, (CASE WHEN MAX(SALARY) >10000 THEN 0.49 WHEN MAX(SALARY) <= 10000 AND MAX(SALARY)>= 1000 THEN 0.24 WHEN MAX(SALARY) <1000 THEN 0 END) AS TAX FROM SALARIES GROUP BY COMPANY_ID ) SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(S.SALARY - S.SALARY * T.TAX, 0) AS SALARY FROM SALARIES S LEFT JOIN T ON S.COMPANY_ID = T.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(S.BUYER_ID) FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND S.BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT A.COMPANY_ID, A.EMPLOYEE_ID, A.EMPLOYEE_NAME, ROUND(CASE WHEN B.MAXSAL > 10000 THEN 0.51*A.SALARY WHEN B.MAXSAL > 1000 THEN 0.76*A.SALARY ELSE A.SALARY END) AS SALARY FROM SALARIES AS A LEFT JOIN (SELECT COMPANY_ID, MAX(SALARY) AS MAXSAL FROM SALARIES GROUP BY COMPANY_ID) AS B ON A.COMPANY_ID = B.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S, PRODUCT P WHERE S.PRODUCT_ID = P.PRODUCT_ID AND P.PRODUCT_NAME = 'S8' AND S.BUYER_ID NOT IN ( SELECT S.BUYER_ID FROM SALES S, PRODUCT P WHERE S.PRODUCT_ID = P.PRODUCT_ID AND P.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT OUTER JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC,CUSTOMER_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE AS ( SELECT L.PAGE_ID AS RECOMMENDED_PAGE FROM LIKES L JOIN FRIENDSHIP F ON L.USER_ID = F.USER2_ID WHERE F.USER1_ID = 1 UNION SELECT L.PAGE_ID AS RECOMMENDED_PAGE FROM LIKES L JOIN FRIENDSHIP F ON L.USER_ID = F.USER1_ID WHERE F.USER2_ID = 1 ) SELECT RECOMMENDED_PAGE FROM CTE WHERE RECOMMENDED_PAGE NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH PIT_TABLE AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) SELECT ACTIVITY.PLAYER_ID, ACTIVITY.DEVICE_ID FROM ACTIVITY JOIN PIT_TABLE ON ACTIVITY.PLAYER_ID = PIT_TABLE.PLAYER_ID AND ACTIVITY.EVENT_DATE = PIT_TABLE.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL ORDER BY 1,2;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A, LOGINFO B WHERE A.LOGIN < B.LOGIN AND A.LOGOUT >= B.LOGIN AND A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS != B.IP_ADDRESS;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT S.BUYER_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM CTE WHERE BUYER_ID IN ( SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8' ) AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT P.LASTNAME, P.FIRSTNAME, A.CITY, A.STATE FROM PERSON P LEFT JOIN ADDRESS A ON A.PERSONID = P.PERSONID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH CTE AS ( SELECT VIEWER_ID, VIEW_DATE, COUNT(DISTINCT ARTICLE_ID) AS CNT FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID) >= 2 ) SELECT DISTINCT VIEWER_ID AS ID FROM CTE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE V.VISIT_ID NOT IN (SELECT T.VISIT_ID FROM TRANSACTIONS T) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT A.CLASS FROM (SELECT STUDENT, CLASS FROM COURSES GROUP BY STUDENT, CLASS)A GROUP BY CLASS HAVING COUNT(CLASS) >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME,B.BONUS FROM EMPLOYEE E LEFT OUTER JOIN BONUS B ON E.EMPID=B.EMPID WHERE B.BONUS<1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM (SELECT EMAIL, COUNT(ID) COUNTOFEMAIL FROM PERSON GROUP BY EMAIL) T WHERE T.COUNTOFEMAIL > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S, PRODUCT P WHERE S.PRODUCT_ID = P.PRODUCT_ID AND P.PRODUCT_ID IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31') AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31') ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM (SELECT V.VISIT_ID,CUSTOMER_ID,AMOUNT,TRANSACTION_ID FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL) A GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND((SUM(P.PRICE * US.UNITS) / SUM(US.UNITS)), 2) AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD US ON P.PRODUCT_ID = US.PRODUCT_ID AND US.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM PRODUCT WHERE PRODUCT.PRODUCT_ID IN( SELECT SALES.PRODUCT_ID FROM SALES WHERE SALE_DATE >= '2019-01-01' AND SALE_DATE <= '2019-03-31' ) AND PRODUCT.PRODUCT_ID NOT IN( SELECT SALES.PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM ( SELECT BUYER_ID, SUM(CASE WHEN P1.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS S8_CNT, SUM(CASE WHEN P1.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS IPHONE_CNT FROM SALES AS S1 INNER JOIN PRODUCT P1 ON S1.PRODUCT_ID = P1.PRODUCT_ID GROUP BY BUYER_ID ) AS PC WHERE S8_CNT>0 AND IPHONE_CNT = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*S.UNITS) / SUM(S.UNITS), 2) AVERAGE_PRICE FROM UNITSSOLD S JOIN PRICES P ON P.PRODUCT_ID = S.PRODUCT_ID AND S.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L2.ACCOUNT_ID = L1.ACCOUNT_ID AND L2.IP_ADDRESS <> L1.IP_ADDRESS AND L2.LOGIN BETWEEN L1.LOGIN AND L1.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] WITH CTE AS ( SELECT DISTINCT POST_ID, ACTION_DATE, ACTION, EXTRA FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' ) SELECT EXTRA AS REPORT_REASON, COUNT(EXTRA) AS REPORT_COUNT FROM CTE GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM (SELECT CLASS, COUNT(*) AS CNT FROM COURSES GROUP BY CLASS) AS TEMP_TABLE WHERE CNT>=5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH TEMP AS(SELECT P.PRODUCT_ID AS PRODUCT_ID, P.PRODUCT_NAME, S.SALE_DATE FROM PRODUCT P LEFT JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31') SELECT P2.PRODUCT_ID, P2.PRODUCT_NAME FROM PRODUCT P2 WHERE P2.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM TEMP);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID,P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE NOT (SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31'));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM ( SELECT BUYER_ID, MAX(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS BOUGHT_IPHONE, MAX(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS BOUGHT_S8 FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID GROUP BY BUYER_ID ) A WHERE BOUGHT_IPHONE = 0 AND BOUGHT_S8 = 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH OUT_FRAME AS ( SELECT S.PRODUCT_ID FROM SALES S WHERE S.SALE_DATE > CAST('2019-03-31' AS DATE) OR S.SALE_DATE < CAST('2019-01-01' AS DATE) ) SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM OUT_FRAME);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT AUTHOR_ID ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM (SELECT DISTINCT A.PID, A.TIV_2016 FROM INSURANCE A INNER JOIN INSURANCE B ON A.TIV_2015 = B.TIV_2015 AND A.PID <> B.PID WHERE A.PID NOT IN (SELECT A.PID FROM INSURANCE A INNER JOIN INSURANCE B ON A.LAT = B.LAT AND A.LON = B.LON AND A.PID <> B.PID) ) A;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT A.DATE_ID, A.MAKE_NAME,A.UNIQUE_LEADS,B.UNIQUE_PARTNERS FROM (SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS FROM DAILYSALES WHERE DATE_ID IS NOT NULL AND MAKE_NAME IS NOT NULL GROUP BY DATE_ID, MAKE_NAME) A LEFT JOIN (SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES WHERE DATE_ID IS NOT NULL AND MAKE_NAME IS NOT NULL GROUP BY DATE_ID, MAKE_NAME) B ON A.DATE_ID=B.DATE_ID AND A.MAKE_NAME=B.MAKE_NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P1.PRODUCT_ID, P1.PRODUCT_NAME FROM PRODUCT P1 WHERE P1.PRODUCT_ID NOT IN( SELECT DISTINCT S.PRODUCT_ID FROM SALES S WHERE SALE_DATE<'2019-01-01' OR SALE_DATE>'2019-03-31' AND QUANTITY>0);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH CTE1 AS (SELECT CUSTOMER_ID FROM ORDERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND PRODUCT_NAME = 'A' AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C')) SELECT CTE1.CUSTOMER_ID, CUSTOMER_NAME FROM CTE1 JOIN CUSTOMERS C ON C.CUSTOMER_ID = CTE1.CUSTOMER_ID ORDER BY CTE1.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.VIEWER_ID AS ID FROM VIEWS V1 JOIN VIEWS V2 ON V1.VIEWER_ID = V2.AUTHOR_ID AND V1.ARTICLE_ID = V2.ARTICLE_ID ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(A.NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM)=1)A;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT C.CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS C, ORDERS O WHERE C.CUSTOMER_ID = O.CUSTOMER_ID AND PRODUCT_NAME='A' AND CUSTOMER_NAME IN (SELECT DISTINCT CUSTOMER_NAME FROM CUSTOMERS C, ORDERS O WHERE C.CUSTOMER_ID = O.CUSTOMER_ID AND PRODUCT_NAME='B') AND CUSTOMER_NAME NOT IN (SELECT DISTINCT CUSTOMER_NAME FROM CUSTOMERS C, ORDERS O WHERE C.CUSTOMER_ID = O.CUSTOMER_ID AND PRODUCT_NAME='C');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID,COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID=T.VISIT_ID WHERE V.VISIT_ID NOT IN (SELECT T1.VISIT_ID FROM TRANSACTIONS T1) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(DISTINCT(STUDENT)) > 4;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH FRIENDS AS ( SELECT USER1_ID AS FRIEND FROM FRIENDSHIP WHERE USER2_ID = 1 UNION ALL SELECT USER2_ID AS FRIEND FROM FRIENDSHIP WHERE USER1_ID = 1 ) SELECT DISTINCT PAGE_ID RECOMMENDED_PAGE FROM FRIENDS A INNER JOIN LIKES B ON A.FRIEND = B.USER_ID AND PAGE_ID NOT IN (SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT ACCOUNT_ID FROM ( SELECT A.ACCOUNT_ID FROM LOGINFO A JOIN LOGINFO B ON A.ACCOUNT_ID=B.ACCOUNT_ID WHERE B.LOGIN BETWEEN A.LOGIN AND A.LOGOUT AND A.IP_ADDRESS!=B.IP_ADDRESS ) X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT(VIEWER_ID) AS ID FROM (SELECT COUNT(DISTINCT B.ARTICLE_ID) AS M, A.VIEWER_ID, A.VIEW_DATE FROM VIEWS A, VIEWS B WHERE A.VIEWER_ID = B.VIEWER_ID AND A.VIEW_DATE = B.VIEW_DATE AND A.ARTICLE_ID != B.ARTICLE_ID GROUP BY A.VIEWER_ID, A.VIEW_DATE) AS T WHERE M>1 ORDER BY VIEWER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID,ROUND(SUM(UNITS*PRICE)/COALESCE(SUM(UNITS),1),2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND PURCHASE_DATE>=START_DATE AND PURCHASE_DATE<=END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S WHERE DEPARTMENT_ID NOT IN( SELECT ID FROM DEPARTMENTS );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31') ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID, A.CUSTOMER_NAME FROM CUSTOMERS A INNER JOIN ORDERS B ON A.CUSTOMER_ID = B.CUSTOMER_ID WHERE B.PRODUCT_NAME IN ('A','B') AND A.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME ='C') GROUP BY A.CUSTOMER_ID, A.CUSTOMER_NAME HAVING COUNT(B.PRODUCT_NAME) >= 2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(P1.X-P2.X) AS SHORTEST FROM POINT P1 JOIN POINT P2 ON P1.X!=P2.X ORDER BY 1 ASC LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM ( SELECT NUM, COUNT(*) CNT FROM MYNUMBERS GROUP BY NUM) T WHERE T.CNT = 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID,MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID;\n[SQL_2] SELECT DISTINCT(T.PLAYER_ID), R.FIRST_LOGIN FROM ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) R JOIN ACTIVITY AS T ON T.PLAYER_ID = R.PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(VISIT_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID ORDER BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID AS PRODUCT_ID,ROUND(SUM(U.UNITS * P.PRICE)/ SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID=U.PRODUCT_ID AND (PURCHASE_DATE BETWEEN START_DATE AND END_DATE) GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID AS PRODUCT_ID, PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY P.PRODUCT_ID, PRODUCT_NAME HAVING MIN(SALE_DATE) >= CAST('2019-01-01' AS DATE) AND MAX(SALE_DATE) <= CAST('2019-03-31' AS DATE);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT DISTINCT(PRODUCT_ID) FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE, COUNT(C.CONTACT_EMAIL) CONTACTS_CNT, COUNT(D.EMAIL) TRUSTED_CONTACTS_CNT FROM INVOICES A INNER JOIN CUSTOMERS B ON A.USER_ID = B.CUSTOMER_ID LEFT OUTER JOIN CONTACTS C ON C.USER_ID = B.CUSTOMER_ID LEFT OUTER JOIN CUSTOMERS D ON D.EMAIL = C.CONTACT_EMAIL GROUP BY A.INVOICE_ID , B.CUSTOMER_NAME, A.PRICE ORDER BY A.INVOICE_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION ='REPORT' AND ACTION_DATE = '2019-7-4' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI U USING (ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT(POST_ID)) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND EXTRA IS NOT NULL AND ACTION = 'REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH CTE AS ( SELECT PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM PRODUCT INNER JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE SALES.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' ) SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT CTE.PRODUCT_ID FROM CTE );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT A.DATE_ID, A.MAKE_NAME, COUNT(DISTINCT A.LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT A.PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES B LEFT JOIN DAILYSALES A ON A.DATE_ID = B.DATE_ID AND A.MAKE_NAME = B.MAKE_NAME GROUP BY A.DATE_ID, A.MAKE_NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS != L2.IP_ADDRESS AND L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(1) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT X.PRODUCT_ID,X.STORE, X.PRICE FROM ( SELECT PRODUCT_ID,'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID,'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID,'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS ) X WHERE X.PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A JOIN LOGINFO B ON A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS != B.IP_ADDRESS WHERE (A.LOGIN >= B.LOGIN AND A.LOGIN <= B.LOGOUT) OR (A.LOGOUT <= B.LOGOUT AND A.LOGOUT >= B.LOGIN);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN( SELECT DISTINCT(CUSTOMERID) FROM ORDERS );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(P1.X - P2.X)) AS SHORTEST FROM POINT P1, POINT P2 WHERE P2.X != P1.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) >= 1 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) < 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT TB1.CUSTOMER_ID,COUNT(TB1.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS AS TB1 LEFT JOIN (SELECT TB3.VISIT_ID, SUM(TB3.AMOUNT) AS AMOUNT FROM TRANSACTIONS AS TB3 GROUP BY TB3.VISIT_ID) AS TB2 ON TB1.VISIT_ID = TB2.VISIT_ID WHERE TB2.AMOUNT IS NULL GROUP BY TB1.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , COUNT(*) COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS ) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT A.AUTHOR_ID AS ID FROM VIEWS A, VIEWS B WHERE A.ARTICLE_ID = B.ARTICLE_ID AND A.AUTHOR_ID = B.VIEWER_ID ORDER BY A.AUTHOR_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.BUYER_ID IN (SELECT BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8') AND S.BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN (SELECT P2.PRODUCT_ID FROM PRODUCT P2 INNER JOIN SALES S2 ON P2.PRODUCT_ID = S2.PRODUCT_ID WHERE SALE_DATE < '2018-12-31' OR SALE_DATE > '2019-04-01');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT T1.BUYER_ID FROM SALES AS T1 INNER JOIN PRODUCT AS T2 ON T1.PRODUCT_ID = T2.PRODUCT_ID GROUP BY T1.BUYER_ID HAVING SUM(CASE WHEN T2.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN T2.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT SUB.BUYER_ID FROM ( SELECT A.BUYER_ID, SUM(S8_IND) AS S8_IND, SUM(IPHONE_IND) AS IPHONE_IND FROM SALES A LEFT JOIN ( SELECT PRODUCT_ID, CASE WHEN PRODUCT_NAME IN ('S8') THEN 1 ELSE 0 END AS S8_IND, CASE WHEN PRODUCT_NAME IN('IPHONE')THEN 1 ELSE 0 END AS IPHONE_IND FROM PRODUCT) B ON A.PRODUCT_ID=B.PRODUCT_ID GROUP BY A.BUYER_ID) SUB WHERE S8_IND >= 1 AND IPHONE_IND <= 0 GROUP BY SUB.BUYER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM EMPLOYEE LEFT OUTER JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT.PRODUCT_ID FROM PRODUCT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V.AUTHOR_ID AS ID FROM VIEWS V INNER JOIN VIEWS U ON V.AUTHOR_ID = U.VIEWER_ID AND V.ARTICLE_ID = U.ARTICLE_ID ORDER BY V.AUTHOR_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT T1.VIEWER_ID AS ID FROM (SELECT DISTINCT * FROM VIEWS) AS T1 GROUP BY T1.VIEWER_ID HAVING COUNT(DISTINCT T1.VIEW_DATE)!= COUNT(T1.VIEW_DATE) ORDER BY T1.VIEWER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] WITH TIME_MIN AS ( SELECT SESSION_ID, DURATION/60 AS DURATION_MIN FROM SESSIONS ) SELECT '[0-5>' AS BIN, COUNT(CASE WHEN DURATION_MIN < 5 THEN 1 END) AS TOTAL FROM TIME_MIN UNION SELECT '[5-10>' AS BIN, COUNT(CASE WHEN DURATION_MIN BETWEEN 5 AND 10 THEN 1 END) AS TOTAL FROM TIME_MIN UNION SELECT '[10-15>' AS BIN, COUNT(CASE WHEN DURATION_MIN BETWEEN 10 AND 15 THEN 1 END) AS TOTAL FROM TIME_MIN UNION SELECT '15 OR MORE' AS BIN, COUNT(CASE WHEN DURATION_MIN > 15 THEN 1 END) AS TOTAL FROM TIME_MIN;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH MAX_SALARY AS ( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID), MAX_SALARY_JOIN AS( SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, S.SALARY, M.MAX_SALARY FROM SALARIES AS S LEFT JOIN MAX_SALARY AS M ON S.COMPANY_ID = M.COMPANY_ID) SELECT COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(CASE WHEN MAX_SALARY < 1000 THEN SALARY WHEN MAX_SALARY >1000 AND MAX_SALARY<10000 THEN SALARY*0.76 ELSE SALARY * 0.51 END, 0) AS SALARY FROM MAX_SALARY_JOIN;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE AS( SELECT CUSTOMERS.CUSTOMER_ID AS ID, CUSTOMERS.CUSTOMER_NAME AS NAME, CONTACTS.CONTACT_NAME AS CONTACT_NAME FROM CUSTOMERS LEFT JOIN CONTACTS ON CUSTOMERS.CUSTOMER_ID = CONTACTS.USER_ID), CTE2 AS( SELECT ID,NAME,COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM( CASE WHEN CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CTE GROUP BY ID,NAME ) SELECT INVOICES.INVOICE_ID, CTE2.NAME AS CUSTOMER_NAME,INVOICES.PRICE,CTE2.CONTACTS_CNT,CTE2.TRUSTED_CONTACTS_CNT FROM INVOICES LEFT JOIN CTE2 ON INVOICES.USER_ID = CTE2.ID ORDER BY INVOICES.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM INSURANCE WHERE PID IN (SELECT A.PID FROM INSURANCE A JOIN INSURANCE B ON A.PID != B.PID AND A.TIV_2015 = B.TIV_2015) AND PID NOT IN (SELECT C.PID FROM INSURANCE C JOIN INSURANCE D ON C.PID != D.PID AND C.LAT = D.LAT AND C.LON = D.LON);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN ( SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID END AS FRIEND_ID FROM FRIENDSHIP ) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] WITH PROJ_EXP AS ( SELECT A.*, B. EXPERIENCE_YEARS FROM PROJECT AS A LEFT JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID ) SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJ_EXP GROUP BY PROJECT_ID ORDER BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(VISIT_ID) AS COUNT_NO_TRANS FROM ( SELECT V.CUSTOMER_ID, V.VISIT_ID, T.TRANSACTION_ID FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL ) ABC GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C LEFT JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE C.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND C.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME ='B') AND C.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER1_ID FROM FRIENDSHIP WHERE USER2_ID = 1) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE1 AS ( SELECT CUSTOMER_ID, COUNT(DISTINCT CONTACT_NAME) AS NUM1 FROM CUSTOMERS JOIN CONTACTS ON CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID GROUP BY CUSTOMER_ID ), CTE2 AS ( SELECT CUSTOMER_ID, COUNT(DISTINCT CONTACT_NAME) AS NUM2 FROM CUSTOMERS JOIN CONTACTS ON CONTACTS.USER_ID = CUSTOMERS.CUSTOMER_ID WHERE CONTACT_NAME IN(SELECT CUSTOMER_NAME FROM CUSTOMERS) GROUP BY CUSTOMER_ID ) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COALESCE(CTE1.NUM1,0) AS CONTACTS_CNT, COALESCE(CTE2.NUM2,0) AS TRUSTED_CONTACTS_CNT FROM INVOICES LEFT JOIN CUSTOMERS ON INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID LEFT JOIN CTE1 ON INVOICES.USER_ID = CTE1.CUSTOMER_ID LEFT JOIN CTE2 ON INVOICES.USER_ID = CTE2.CUSTOMER_ID ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID=L2.ACCOUNT_ID AND (L1.LOGIN<=L2.LOGOUT AND L1.LOGOUT>=L2.LOGIN) AND L1.IP_ADDRESS!=L2.IP_ADDRESS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH COMB AS (SELECT P.PRODUCT_ID AS PID, P.PRODUCT_NAME AS NAME, S.BUYER_ID AS BID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID) SELECT DISTINCT(BID) AS BUYER_ID FROM COMB WHERE BID IN (SELECT BID FROM COMB WHERE NAME = 'S8') AND BID NOT IN (SELECT BID FROM COMB WHERE NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P LEFT JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID , ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT A INNER JOIN EMPLOYEE E ON A.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA > 3000000 OR POPULATION >= 25000000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE='2019-07-04' AND ACTION='REPORT' AND EXTRA !='NULL' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(EMPLOYEE.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT JOIN EMPLOYEE ON PROJECT.EMPLOYEE_ID = EMPLOYEE.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT S.BUYER_ID,P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM CTE WHERE BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH CTE AS (SELECT P.PRODUCT_ID, P.PRICE*U.UNITS AS TOTAL, U.UNITS AS UNITS FROM PRICES AS P INNER JOIN UNITSSOLD AS U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) SELECT PRODUCT_ID, ROUND(SUM(TOTAL)/SUM(UNITS),2) AS AVERAGE_PRICE FROM CTE GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN( SELECT CUSTOMERS.ID FROM CUSTOMERS,ORDERS WHERE CUSTOMERS.ID = ORDERS.CUSTOMERID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN ( SELECT DISTINCT BUYER_ID FROM SALES WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'IPHONE') );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH FRIENDSHIP_1 AS ( SELECT USER2_ID,USER1_ID FROM FRIENDSHIP WHERE USER2_ID = 1 ) SELECT RECOMMENDED_PAGE FROM ( SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM FRIENDSHIP F JOIN LIKES L ON F.USER2_ID=L.USER_ID WHERE F.USER1_ID = 1 AND L.PAGE_ID NOT IN(SELECT PAGE_ID FROM LIKES WHERE USER_ID =1) )A UNION ( SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM FRIENDSHIP_1 F JOIN LIKES L ON F.USER1_ID=L.USER_ID AND L.PAGE_ID NOT IN(SELECT PAGE_ID FROM LIKES WHERE USER_ID =1) );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S2.BUYER_ID FROM SALES S2 JOIN (SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8') X ON X.BUYER_ID = S2.BUYER_ID WHERE X.BUYER_ID NOT IN (SELECT A.BUYER_ID FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID AS CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID,COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V INNER JOIN ( SELECT VISIT_ID FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) ) AS T ON V.VISIT_ID =T.VISIT_ID GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT DISTINCT P.PRODUCT_ID FROM PRODUCT AS P LEFT JOIN SALES AS S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID AS ACTOR_ID ,DIRECTOR_ID AS DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(DIRECTOR_ID) >= 3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT COUNT(DISTINCT POST_ID) AS REPORT_COUNT,EXTRA AS REPORT_REASON FROM ACTIONS WHERE ACTION_DATE='2019-07-04' AND ACTION = 'REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM ((SELECT USER1_ID AS USER_ID FROM FRIENDSHIP WHERE USER2_ID=1) UNION (SELECT USER2_ID AS UER_ID FROM FRIENDSHIP WHERE USER1_ID=1)) T JOIN LIKES L ON T.USER_ID = L.USER_ID WHERE L.PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID =1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(T2.PLAYER_ID) / COUNT(T1.PLAYER_ID), 2) FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) T1 LEFT JOIN ACTIVITY T2 ON T1.PLAYER_ID = T2.PLAYER_ID AND T1.EVENT_DATE = T2.EVENT_DATE-1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT A.EXTRA AS REPORT_REASON,COUNT(A.EXTRA) AS REPORT_COUNT FROM( SELECT DISTINCT POST_ID,ACTION_DATE,ACTION,EXTRA FROM ACTIONS WHERE ACTION_DATE = '2019-07-04') A WHERE A.EXTRA IS NOT NULL AND ACTION = 'REPORT' GROUP BY A.EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] WITH T AS (SELECT PRODUCT_ID, CASE WHEN STORE1 IS NOT NULL THEN STORE1 END AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, CASE WHEN STORE2 IS NOT NULL THEN STORE2 END AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, CASE WHEN STORE3 IS NOT NULL THEN STORE3 END AS STORE, STORE3 AS PRICE FROM PRODUCTS) SELECT * FROM T WHERE T.STORE!= 'NULL';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID , COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID=T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM SALES WHERE BUYER_ID NOT IN (SELECT S1.BUYER_ID FROM SALES AS S1 JOIN PRODUCT AS P1 ON S1.PRODUCT_ID = P1.PRODUCT_ID WHERE P1.PRODUCT_NAME ='IPHONE') AND BUYER_ID IN (SELECT S1.BUYER_ID FROM SALES AS S1 JOIN PRODUCT AS P1 ON S1.PRODUCT_ID = P1.PRODUCT_ID WHERE P1.PRODUCT_NAME ='S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT DISTINCT A.BUYER_ID FROM SALES A LEFT JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT DISTINCT A.BUYER_ID FROM SALES A LEFT JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EU.UNIQUE_ID AS UNIQUE_ID, E.NAME FROM EMPLOYEES E LEFT OUTER JOIN EMPLOYEEUNI EU ON E.ID = EU.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN (SELECT DISTINCT(VISIT_ID) FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID GROUP BY VISITS.CUSTOMER_ID, TRANSACTIONS.AMOUNT HAVING TRANSACTIONS.AMOUNT IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT(P1.EMAIL) AS EMAIL FROM PERSON P1 JOIN PERSON P2 ON P1.EMAIL = P2.EMAIL AND P1.ID != P2.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT AS P WHERE P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM (SELECT S.ID, S.NAME, D.NAME AS DEPARTMENT_NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID) A WHERE DEPARTMENT_NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM ( SELECT BUYER_ID, SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS S8_FLAG, SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS IPHONE_FLAG FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID GROUP BY BUYER_ID ) A WHERE S8_FLAG>=1 AND IPHONE_FLAG=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT CITY, FIRSTNAME, LASTNAME, STATE FROM PERSON LEFT JOIN ADDRESS ON PERSON.PERSONID=ADDRESS.PERSONID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T AS (SELECT S.BUYER_ID, P.PRODUCT_NAME FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM T WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT DISTINCT BUYER_ID FROM T WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT DISTINCT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION_DATE='2019-07-04' GROUP BY EXTRA HAVING SUM(CASE WHEN ACTION='REPORT' THEN 1 ELSE 0 END)>0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE (AREA) > 3000000 OR POPULATION > 25000000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT V.VISIT_ID FROM VISITS V INNER JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2)AS AVERAGE_YEARS FROM EMPLOYEE JOIN PROJECT ON EMPLOYEE.EMPLOYEE_ID = PROJECT.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID,NAME FROM (SELECT A.ID, A.NAME,A.DEPARTMENT_ID,B.NAME AS DEPART_NAME FROM STUDENTS A LEFT JOIN DEPARTMENTS B ON A.DEPARTMENT_ID=B.ID) C WHERE DEPART_NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISITS.VISIT_ID NOT IN (SELECT TRANSACTIONS.VISIT_ID FROM TRANSACTIONS) GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID, COUNT(VISITS .VISIT_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID= TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] WITH SALE_LEAD AS (SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME), SALE_PARTNER AS (SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME) SELECT L1.DATE_ID, L1.MAKE_NAME, L1.UNIQUE_LEADS, P1.UNIQUE_PARTNERS FROM SALE_LEAD L1 INNER JOIN SALE_PARTNER P1 ON L1.DATE_ID = P1.DATE_ID AND L1.MAKE_NAME = P1.MAKE_NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , COUNT(*) AS COUNT_NO_TRANS FROM ( SELECT V.* FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID=T.VISIT_ID WHERE T.VISIT_ID IS NULL) X GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH ALL_CUSTOMER AS ( SELECT I.INVOICE_ID, I.USER_ID AS CUSTOMER_ID, C.CUSTOMER_NAME, C.EMAIL AS CUSTOMER_EMAIL, I.PRICE FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID ), CONTACTS_CNT AS ( SELECT CUST.CUSTOMER_ID, COALESCE(COUNT(DISTINCT CON.CONTACT_EMAIL), 0) AS CONTACTS_CNT FROM ALL_CUSTOMER CUST LEFT JOIN CONTACTS CON ON CUST.CUSTOMER_ID = CON.USER_ID GROUP BY CUST.CUSTOMER_ID ), TRUSTED_CONTACTS AS ( SELECT CUST.CUSTOMER_ID, COALESCE(COUNT(DISTINCT CON.CONTACT_EMAIL), 0) AS TRUSTED_CONTACT_CNT FROM ALL_CUSTOMER CUST LEFT JOIN CONTACTS CON ON CUST.CUSTOMER_ID = CON.USER_ID WHERE CON.CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) GROUP BY CUST.CUSTOMER_ID ) SELECT CUST.INVOICE_ID, CUST.CUSTOMER_NAME, CUST.PRICE, COALESCE(CON.CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(T.TRUSTED_CONTACT_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM ALL_CUSTOMER CUST LEFT JOIN CONTACTS_CNT CON ON CUST.CUSTOMER_ID = CON.CUSTOMER_ID LEFT JOIN TRUSTED_CONTACTS T ON CUST.CUSTOMER_ID = T.CUSTOMER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AS AVERAGE_PRICE FROM (SELECT P.PRODUCT_ID, PRICE, UNITS FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ) A GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT * FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND NOT CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT(AUTHOR_ID) AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A JOIN LOGINFO B ON A.ACCOUNT_ID=B.ACCOUNT_ID AND B.LOGIN >= A.LOGIN AND B.LOGIN <= A.LOGOUT AND A.IP_ADDRESS != B.IP_ADDRESS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH T1 AS( SELECT CUSTOMER_ID,COUNT(C1.USER_ID) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CONTACTS C1 INNER JOIN CUSTOMERS C2 ON C1.USER_ID = C2.CUSTOMER_ID GROUP BY CUSTOMER_ID) SELECT INVOICE_ID,CUSTOMER_NAME,PRICE,COALESCE(CONTACTS_CNT,0) AS CONTACTS_CNT, COALESCE(TRUSTED_CONTACTS_CNT,0) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN T1 ON I.USER_ID = T1.CUSTOMER_ID INNER JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] WITH CTE1 AS (SELECT PLAYER_ID AS D1, MIN(EVENT_DATE) AS MEVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) , CTE2 AS (SELECT A1.PLAYER_ID AS S1 FROM CTE1 INNER JOIN ACTIVITY AS A1 ON D1=A1.PLAYER_ID AND CTE1.MEVENT_DATE+1=A1.EVENT_DATE) SELECT ROUND(COUNT(DISTINCT(S1))/COUNT(DISTINCT(D1)),2) AS FRACTION FROM CTE2,CTE1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CONTACT_CNT AS( SELECT USER_ID, COUNT(CONTACT_NAME) AS CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID ), TRUSTED_CONTACT_CNT AS ( SELECT USER_ID, COUNT(CONTACT_NAME) AS TRUSTED_CONTACTS_CNT FROM CONTACTS LEFT JOIN CUSTOMERS ON CONTACTS.CONTACT_NAME = CUSTOMERS.CUSTOMER_NAME WHERE CUSTOMER_NAME IS NOT NULL GROUP BY USER_ID ) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COALESCE(CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACT_CNT ON C.CUSTOMER_ID = CONTACT_CNT.USER_ID LEFT JOIN TRUSTED_CONTACT_CNT ON CONTACT_CNT.USER_ID = TRUSTED_CONTACT_CNT.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON ,COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE = CAST('2019-07-05' AS DATE) - INTERVAL 1 DAY AND EXTRA IS NOT NULL AND ACTION = 'REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM ( SELECT P.PROJECT_ID, E.EXPERIENCE_YEARS FROM PROJECT AS P LEFT JOIN EMPLOYEE AS E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID ) AS SUB GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH T AS ( SELECT U.PRODUCT_ID, U.PURCHASE_DATE, U.UNITS, P.PRICE, U.UNITS*P.PRICE REVENUE FROM UNITSSOLD U, PRICES P WHERE U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE >= P.START_DATE AND U.PURCHASE_DATE <= P.END_DATE ) SELECT T.PRODUCT_ID, ROUND(SUM(T.REVENUE)/SUM(T.UNITS),2) AVERAGE_PRICE FROM T GROUP BY T.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH TEMP AS (SELECT PRODUCT_ID ,SUM(CASE WHEN SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' THEN 1 ELSE 0 END) AS CASE1, SUM(CASE WHEN SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' THEN 1 ELSE 0 END) AS CASE2 FROM SALES GROUP BY PRODUCT_ID) SELECT T.PRODUCT_ID, P.PRODUCT_NAME FROM TEMP T LEFT JOIN PRODUCT P ON T.PRODUCT_ID = P.PRODUCT_ID WHERE T.CASE1 =0 AND T.CASE2 >=1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(P1.X - P2.X) AS SHORTEST FROM POINT P1 JOIN POINT P2 ON P1.X != P2.X ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH NOIPHONE AS(SELECT DISTINCT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE') SELECT DISTINCT BUYER_ID FROM SALES S1 LEFT JOIN PRODUCT P1 ON S1.PRODUCT_ID = P1.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM NOIPHONE);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID , ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON E.EMPLOYEE_ID = P.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH T AS ( SELECT VIEWER_ID, VIEW_DATE, COUNT(DISTINCT ARTICLE_ID) AS VIEW_COUNT FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID ) SELECT DISTINCT VIEWER_ID AS ID FROM T WHERE VIEW_COUNT>=2 ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT(POST_ID)) AS REPORT_COUNT FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' GROUP BY EXTRA ORDER BY REPORT_COUNT ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID AS PROJECT_ID, ROUND(AVG(E.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID=E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(CLASS) >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.AUTHOR_ID AS ID FROM VIEWS V1 JOIN VIEWS V2 ON V1.AUTHOR_ID = V2.VIEWER_ID AND V2.ARTICLE_ID = V1.ARTICLE_ID ORDER BY V1.AUTHOR_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COALESCE(CONTACTS_CNT, 0) CONTACTS_CNT, COALESCE(TRUSTED_CONTACTS_CNT,0) TRUSTED_CONTACTS_CNT FROM INVOICES LEFT JOIN (SELECT USER_ID, COUNT(CONTACT_EMAIL) CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID) A ON INVOICES.USER_ID = A.USER_ID LEFT JOIN (SELECT USER_ID, COUNT(CONTACT_NAME) TRUSTED_CONTACTS_CNT FROM CONTACTS WHERE CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) GROUP BY USER_ID) B ON INVOICES.USER_ID = B.USER_ID JOIN CUSTOMERS ON INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE (BUYER_ID IN (SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8')) AND (BUYER_ID NOT IN (SELECT DISTINCT BUYER_ID FROM SALES S2 JOIN PRODUCT P2 ON S2.PRODUCT_ID = P2.PRODUCT_ID WHERE P2.PRODUCT_NAME = 'IPHONE'));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM( SELECT * FROM INSURANCE WHERE (LAT,LON) NOT IN (SELECT LAT , LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)>1) AND TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) > 1)) TEMP;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT B.ID AS ID, B.NAME AS NAME FROM STUDENTS B LEFT JOIN DEPARTMENTS A ON A.ID=B.DEPARTMENT_ID WHERE A.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT X.BUYER_ID FROM (SELECT DISTINCT S.BUYER_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME='S8' ) AS X LEFT JOIN ( SELECT DISTINCT S.BUYER_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME='IPHONE' ) AS Y ON X.BUYER_ID=Y.BUYER_ID WHERE Y.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS ( SELECT * FROM PRODUCT AS P JOIN SALES AS S USING(PRODUCT_ID) ) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME='S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING MIN(ID) != MAX(ID);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN ( SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID=PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID=PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH PRODSALES AS( SELECT PROD.PRODUCT_ID ,PROD.PRODUCT_NAME ,BUYER_ID FROM PRODUCT PROD JOIN SALES SALES ON PROD.PRODUCT_ID = SALES.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM PRODSALES WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM PRODSALES WHERE PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT(VIEWER_ID) AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT(ARTICLE_ID)) > 1 ORDER BY ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM( CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END ) = 0 AND SUM( CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END ) >= 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, CASE WHEN MAX_SALARY < 1000 THEN SALARY WHEN MAX_SALARY >=1000 AND MAX_SALARY <= 10000 THEN ROUND(SALARY-SALARY*0.24, 0) WHEN MAX_SALARY >10000 THEN ROUND(SALARY-SALARY*0.49, 0) END AS SALARY FROM SALARIES S JOIN ( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID ) T ON S.COMPANY_ID = T.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*) = 1 ) AS T;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT DISTANCE AS SHORTEST FROM (SELECT ABS(P1.X-P2.X) AS DISTANCE FROM POINT P1 JOIN POINT P2 ON P1.X <>P2.X) TMP ORDER BY DISTANCE ASC LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH A AS( SELECT SALES.BUYER_ID FROM PRODUCT LEFT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE PRODUCT.PRODUCT_NAME = 'S8' ), B AS( SELECT SALES.BUYER_ID FROM PRODUCT LEFT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE PRODUCT.PRODUCT_NAME = 'IPHONE' ) SELECT DISTINCT A.BUYER_ID FROM A WHERE BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT LEFT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE PRODUCT.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P, SALES S WHERE P.PRODUCT_ID = S.PRODUCT_ID GROUP BY P.PRODUCT_ID, P.PRODUCT_NAME HAVING MIN(S.SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT (CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE 0 END) AS FRIEND FROM FRIENDSHIP) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT SUM(CASE WHEN DURATION < 300 THEN 1 ELSE 0 END) AS TOTAL, '[0-5>' BIN FROM SESSIONS UNION SELECT SUM(CASE WHEN DURATION >= 300 AND DURATION < 600 THEN 1 ELSE 0 END) AS TOTAL, '[5-10>' BIN FROM SESSIONS UNION SELECT SUM(CASE WHEN DURATION >= 600 AND DURATION < 900 THEN 1 ELSE 0 END) AS TOTAL, '[10-15>' BIN FROM SESSIONS UNION SELECT SUM(CASE WHEN DURATION >= 900 THEN 1 ELSE 0 END) AS TOTAL, '15 OR MORE' BIN FROM SESSIONS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES A LEFT JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT DISTINCT BUYER_ID FROM SALES A LEFT JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.PRODUCT_NAME ='IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT CUSTOMERS.CUSTOMER_ID, CUSTOMERS.CUSTOMER_NAME FROM (SELECT T.CUSTOMER_ID FROM (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B')) T LEFT JOIN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ) W ON T.CUSTOMER_ID = W.CUSTOMER_ID WHERE W.CUSTOMER_ID IS NULL) X INNER JOIN CUSTOMERS ON X.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-04-01' ) ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID AS CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] WITH D1 AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS INSTALL_DT FROM ACTIVITY GROUP BY PLAYER_ID ), D2 AS ( SELECT INSTALL_DT, COUNT(*) AS INSTALLS FROM D1 GROUP BY INSTALL_DT), D3 AS (SELECT D1.INSTALL_DT, COUNT(A1.PLAYER_ID) AS DAY1_RETENTION FROM ACTIVITY AS A1 INNER JOIN D1 ON A1.PLAYER_ID = D1.PLAYER_ID AND A1.EVENT_DATE = D1.INSTALL_DT + 1 GROUP BY INSTALL_DT) SELECT D2.INSTALL_DT, D2.INSTALLS, ROUND(COALESCE(D3.DAY1_RETENTION,0)/D2.INSTALLS,2) AS DAY1_RETENTION FROM D2 LEFT JOIN D3 ON D3.INSTALL_DT = D2.INSTALL_DT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEES AS E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES LEFT JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME='S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, CU.CUSTOMER_NAME, I.PRICE, COALESCE(B.CONTACTS_CNT,0)CONTACTS_CNT, COALESCE(A.TRUSTED_CONTACTS_CNT,0)TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS CU ON CU.CUSTOMER_ID=I. USER_ID LEFT JOIN(SELECT USER_ID, COUNT(CONTACT_NAME)TRUSTED_CONTACTS_CNT FROM CONTACTS WHERE CONTACT_NAME IN(SELECT CUSTOMER_NAME FROM CUSTOMERS) GROUP BY USER_ID)A ON I.USER_ID=A.USER_ID LEFT JOIN(SELECT USER_ID, COUNT(CONTACT_NAME)CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID)B ON B.USER_ID=I.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH A AS( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME ='A' AND CUSTOMER_ID IN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME ='B') AND CUSTOMER_ID NOT IN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME ='C' ) ) SELECT DISTINCT A.CUSTOMER_ID, C.CUSTOMER_NAME FROM A LEFT JOIN CUSTOMERS C ON A.CUSTOMER_ID=C.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(I1.TIV_2016) AS TIV_2016 FROM INSURANCE AS I1 WHERE (I1.LAT,I1.LON) NOT IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*) >1 ) AND I1.TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) > 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE AS( SELECT USER2_ID ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION ALL SELECT USER1_ID ID FROM FRIENDSHIP WHERE USER2_ID = 1 ) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES L INNER JOIN CTE ON CTE.ID = L.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM (SELECT A.BUYER_ID, SUM(CASE WHEN B.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS S8, SUM(CASE WHEN B.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS IOS FROM SALES AS A JOIN PRODUCT AS B ON A.PRODUCT_ID = B.PRODUCT_ID GROUP BY BUYER_ID) A WHERE S8 >= 1 AND IOS = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EU.UNIQUE_ID, E.NAME FROM EMPLOYEEUNI EU RIGHT JOIN EMPLOYEES E ON E.ID = EU.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT T2.ACCOUNT_ID FROM LOGINFO T1 JOIN LOGINFO T2 ON T1.ACCOUNT_ID = T2.ACCOUNT_ID AND T1.IP_ADDRESS <> T2.IP_ADDRESS AND T2.LOGIN BETWEEN T1.LOGIN AND T1.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E_UNI.UNIQUE_ID, E.NAME FROM EMPLOYEEUNI AS E_UNI RIGHT JOIN EMPLOYEES AS E ON E_UNI.ID = E.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T AS( SELECT S.BUYER_ID, P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S USING(PRODUCT_ID) ) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM T WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM T WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH A AS (SELECT O.CUSTOMER_ID, C.CUSTOMER_NAME, O.PRODUCT_NAME FROM CUSTOMERS C RIGHT JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE PRODUCT_NAME = 'A'), B AS (SELECT O.CUSTOMER_ID, C.CUSTOMER_NAME, O.PRODUCT_NAME FROM CUSTOMERS C RIGHT JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE PRODUCT_NAME = 'B'), C AS (SELECT O.CUSTOMER_ID, C.CUSTOMER_NAME, O.PRODUCT_NAME FROM CUSTOMERS C RIGHT JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE C.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C')) SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM A JOIN B ON A.CUSTOMER_ID = B.CUSTOMER_ID JOIN C ON B.CUSTOMER_ID = C.CUSTOMER_ID GROUP BY C.CUSTOMER_ID, C.CUSTOMER_NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] WITH TEMP AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS INSTALL_DT FROM ACTIVITY GROUP BY PLAYER_ID) SELECT INSTALL_DT, COUNT(DISTINCT PLAYER_ID) AS INSTALLS, ROUND(SUM(RET_PLAYER)/ COUNT(DISTINCT PLAYER_ID), 2) AS DAY1_RETENTION FROM (SELECT T.PLAYER_ID, T.INSTALL_DT, CASE WHEN A.EVENT_DATE = T.INSTALL_DT +1 THEN 1 ELSE 0 END AS RET_PLAYER FROM TEMP T JOIN ACTIVITY A ON T.PLAYER_ID = A.PLAYER_ID) MAIN GROUP BY INSTALL_DT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(DISTINCT A.TIV_2016),2) AS TIV_2016 FROM INSURANCE AS A JOIN INSURANCE AS B ON A.TIV_2015 = B.TIV_2015 WHERE A.PID != B.PID AND A.PID IN (SELECT DISTINCT I.PID FROM INSURANCE AS I JOIN INSURANCE AS J ON I.LAT = J.LAT AND I.LON = J.LON GROUP BY I.PID HAVING COUNT(DISTINCT J.PID) = 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID , S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON (S.DEPARTMENT_ID = D.ID) WHERE D.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM ( SELECT PRODUCT_ID, 'STORE1' STORE, STORE1 PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' STORE, STORE2 PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' STORE, STORE2 PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' STORE, STORE3 PRICE FROM PRODUCTS )T WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT S.* , P.PRODUCT_NAME FROM SALES AS S INNER JOIN PRODUCT AS P ON P.PRODUCT_ID = S.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM CTE WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE') AND BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE AS (SELECT DISTINCT USER2_ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION ALL SELECT DISTINCT USER1_ID FROM FRIENDSHIP WHERE USER2_ID = 1) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT * FROM CTE) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN ( SELECT ID2 FROM ( SELECT USER1_ID AS ID1,USER2_ID AS ID2 FROM FRIENDSHIP UNION ALL SELECT USER2_ID,USER1_ID FROM FRIENDSHIP) T WHERE ID1=1) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN (SELECT TT.VISIT_ID FROM TRANSACTIONS TT) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH MUL AS (SELECT COMPANY_ID, CASE WHEN MAX(SALARY) < 1000 THEN 1 WHEN 1000 <= MAX(SALARY) AND MAX(SALARY) <= 10000 THEN 0.76 ELSE 0.51 END MULTIPLIER FROM SALARIES GROUP BY COMPANY_ID) SELECT S.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY*M.MULTIPLIER) SALARY FROM SALARIES S LEFT JOIN MUL M ON S.COMPANY_ID = M.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME ORDER BY DATE_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT T.PRODUCT_ID AS PRODUCT_ID, T.STORE AS STORE, T.PRICE AS PRICE FROM ( SELECT PRODUCT_ID, 'STORE1'AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE2'AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE3'AS STORE, STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL ) AS T;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] WITH INSTALL_DATES AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS INSTALL_DT FROM ACTIVITY GROUP BY PLAYER_ID ) ,DAY_ONE AS ( SELECT A.PLAYER_ID FROM ACTIVITY A JOIN INSTALL_DATES I ON A.PLAYER_ID = I.PLAYER_ID AND A.EVENT_DATE = I.INSTALL_DT + 1 ) SELECT INSTALL_DT, COUNT(*) AS INSTALLS, ROUND(COUNT(D.PLAYER_ID)/COUNT(*),2) AS DAY1_RETENTION FROM INSTALL_DATES I LEFT OUTER JOIN DAY_ONE D ON I.PLAYER_ID = D.PLAYER_ID GROUP BY INSTALL_DT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM INSURANCE WHERE PID IN (SELECT DISTINCT(A.PID) FROM INSURANCE A JOIN INSURANCE B ON A.PID <> B.PID WHERE (A.TIV_2015) = (B.TIV_2015) AND A.PID NOT IN ( SELECT DISTINCT(A.PID) FROM INSURANCE A JOIN INSURANCE B ON A.PID <> B.PID WHERE (A.LAT, A.LON) = (B.LAT, B.LON) ) );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH TEMP AS ( SELECT CUSTOMER_ID, SUM(CASE WHEN PRODUCT_NAME = 'A' THEN 1 ELSE 0 END) AS A_CNT, SUM(CASE WHEN PRODUCT_NAME = 'B' THEN 1 ELSE 0 END) AS B_CNT, SUM(CASE WHEN PRODUCT_NAME = 'C' THEN 1 ELSE 0 END) AS C_CNT FROM ORDERS GROUP BY CUSTOMER_ID) SELECT C.* FROM CUSTOMERS C JOIN TEMP T ON C.CUSTOMER_ID = T.CUSTOMER_ID WHERE A_CNT>0 AND B_CNT>0 AND C_CNT = 0 ORDER BY C.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER1_ID FROM FRIENDSHIP WHERE USER2_ID = 1) F JOIN LIKES L ON F.USER2_ID = L.USER_ID WHERE L.PAGE_ID NOT IN ( SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE AS ( SELECT DISTINCT (CASE WHEN A.USER1_ID <= A.USER2_ID THEN A.USER1_ID ELSE A.USER2_ID END) AS USER1, (CASE WHEN A.USER1_ID > A.USER2_ID THEN A.USER1_ID ELSE A.USER2_ID END) AS USER2 FROM FRIENDSHIP A ) SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT * FROM CTE WHERE USER1 = 1 AND USER1 != USER2) AS C INNER JOIN LIKES L ON C.USER2 = L.USER_ID WHERE L.PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID IN( SELECT DISTINCT A.DEPARTMENT_ID FROM STUDENTS A LEFT JOIN DEPARTMENTS B ON A.DEPARTMENT_ID = B.ID WHERE B.ID IS NULL );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM( SELECT PRODUCT_ID, STORE1 AS PRICE, 'STORE1' AS STORE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, STORE2 AS PRICE, 'STORE2' AS STORE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, STORE3 AS PRICE, 'STORE3' AS STORE FROM PRODUCTS ) A WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM PRODUCT JOIN SALES USING (PRODUCT_ID) WHERE PRODUCT_NAME ='S8' AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM PRODUCT JOIN SALES USING (PRODUCT_ID) WHERE PRODUCT_NAME ='IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] WITH SUB AS (SELECT P.PROJECT_ID PROJECT_ID1,E.EMPLOYEE_ID,E.EXPERIENCE_YEARS EY FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID= E.EMPLOYEE_ID) SELECT PROJECT_ID1 PROJECT_ID,ROUND(SUM(EY)/COUNT(PROJECT_ID1),2) AVERAGE_YEARS FROM SUB GROUP BY PROJECT_ID1 ORDER BY PROJECT_ID1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID,ROUND(SUM(P.PRICE * US.UNITS) / SUM(US.UNITS),2) AS AVERAGE_PRICE FROM PRICES P INNER JOIN UNITSSOLD US ON P.PRODUCT_ID = US.PRODUCT_ID AND US.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE AND US.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH ORDERS AS ( SELECT U.PRODUCT_ID, UNITS, PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ) SELECT PRODUCT_ID, ROUND(SUM(UNITS*PRICE)/ SUM(UNITS),2) AS AVERAGE_PRICE FROM ORDERS GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(DISTINCT A.PLAYER_ID) / COUNT(DISTINCT B.PLAYER_ID), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRSTLOGIN FROM ACTIVITY GROUP BY PLAYER_ID) B LEFT JOIN ACTIVITY A ON B.FIRSTLOGIN + 1 = A.EVENT_DATE AND A.PLAYER_ID = B.PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE1 AS ( SELECT S.BUYER_ID AS BOUGHTS8 FROM SALES S WHERE S.PRODUCT_ID = (SELECT P.PRODUCT_ID FROM PRODUCT P WHERE P.PRODUCT_NAME = 'S8') ), CTE2 AS ( SELECT S.BUYER_ID AS BOUGHTIPHONE FROM SALES S WHERE S.PRODUCT_ID = (SELECT P.PRODUCT_ID FROM PRODUCT P WHERE P.PRODUCT_NAME = 'IPHONE') ) SELECT DISTINCT S.BUYER_ID FROM SALES S WHERE S.BUYER_ID IN (SELECT BOUGHTS8 FROM CTE1) AND S.BUYER_ID NOT IN (SELECT BOUGHTIPHONE FROM CTE2);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN (SELECT A.* FROM (SELECT T1.VISIT_ID FROM TRANSACTIONS T1) A) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS (SELECT BUYER_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8') SELECT DISTINCT S.BUYER_ID FROM CTE AS S WHERE S.BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS ) GROUP BY CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID=T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT USER2_ID AS ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER1_ID AS ID FROM FRIENDSHIP WHERE USER2_ID = 1) AS FRIEND_ID INNER JOIN LIKES L ON FRIEND_ID.ID = L.USER_ID LEFT JOIN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1) AS T ON L.PAGE_ID = T.PAGE_ID WHERE T.PAGE_ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM ( SELECT BUYER_ID, CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END AS S8, CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END AS IPHONE FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID) AS SUB GROUP BY BUYER_ID HAVING SUM(S8) >0 AND SUM(IPHONE) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 NOT IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)=1) AND (LAT,LON) NOT IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)>1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH MINDATE AS (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_EVENTDATE FROM ACTIVITY GROUP BY PLAYER_ID) SELECT A1.PLAYER_ID, A1.DEVICE_ID FROM ACTIVITY AS A1 JOIN MINDATE AS T1 ON A1.PLAYER_ID = T1.PLAYER_ID AND A1.EVENT_DATE = T1.MIN_EVENTDATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(DISTINCT B.PLAYER_ID)/COUNT(DISTINCT A.PLAYER_ID),2) AS FRACTION FROM ACTIVITY A LEFT JOIN ( SELECT DISTINCT A2.PLAYER_ID FROM ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN_DT FROM ACTIVITY GROUP BY PLAYER_ID ) AS A1 INNER JOIN ACTIVITY A2 ON A1.PLAYER_ID = A2.PLAYER_ID AND A1.FIRST_LOGIN_DT = A2.EVENT_DATE - 1 ) B ON A.PLAYER_ID = B.PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE' GROUP BY BUYER_ID ) SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN ( SELECT * FROM CTE ) GROUP BY BUYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT T1.EMAIL FROM PERSON T1 INNER JOIN PERSON T2 ON T1.EMAIL = T2.EMAIL AND T1.ID != T2.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT SALES.PRODUCT_ID, PRODUCT_NAME FROM PRODUCT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE SALES.PRODUCT_ID IN ( SELECT SALES.PRODUCT_ID FROM PRODUCT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' ) AND SALES.PRODUCT_ID NOT IN ( SELECT SALES.PRODUCT_ID FROM PRODUCT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE NOT SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT PRODUCT_ID , PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT DISTINCT B.PRODUCT_ID FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE SALE_DATE < '2019-01-01' OR SALE_DATE >'2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND(SUM(E.EXPERIENCE_YEARS)/COUNT(P.EMPLOYEE_ID),2) AS AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON E.EMPLOYEE_ID = P.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM (SELECT EMAIL, COUNT(EMAIL) AS NUM FROM PERSON GROUP BY EMAIL) AS LIST WHERE NUM > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID,P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN( SELECT P.PRODUCT_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID=S.PRODUCT_ID WHERE NOT S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] WITH TEMP AS ( SELECT E.EMPLOYEE_ID, EXPERIENCE_YEARS, PROJECT_ID FROM EMPLOYEE E JOIN PROJECT P ON E.EMPLOYEE_ID = P.EMPLOYEE_ID ) SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM TEMP GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE * U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE <= P.END_DATE AND U.PURCHASE_DATE >= P.START_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E1.UNIQUE_ID, NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI E1 USING(ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT A.PRODUCT_ID, ROUND(SUM(B.UNITS * A.PRICE) / SUM(B.UNITS), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE GROUP BY A.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT A.SELLER_ID, A.PRODUCT_ID, B.PRODUCT_NAME, B.UNIT_PRICE, A.BUYER_ID, A.SALE_DATE, A.QUANTITY, A.PRICE FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM CTE WHERE BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID,'STORE1' AS STORE,STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 > 0 UNION SELECT PRODUCT_ID,'STORE2' AS STORE,STORE2 PRICE FROM PRODUCTS WHERE STORE2 > 0 UNION SELECT PRODUCT_ID,'STORE3' AS STORE, STORE3 PRICE FROM PRODUCTS WHERE STORE3 > 0 ORDER BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT(POST_ID)) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' AND EXTRA IS NOT NULL GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016), 2) TIV_2016 FROM INSURANCE WHERE ( (LAT, LON) NOT IN ( SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) > 1 ) ) AND ( TIV_2015 IN ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) > 1 ) );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT DISTINCT P.PROJECT_ID, ROUND(AVG(E.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT P LEFT JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN (SELECT DISTINCT S.PRODUCT_ID FROM SALES S WHERE S.SALE_DATE < '2019-01-01' OR S.SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] WITH CTE AS (SELECT * FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND EXTRA != 'NULL' AND ACTION = 'REPORT' ) SELECT EXTRA AS REPORT_REASON,COUNT(DISTINCT(POST_ID)) AS REPORT_COUNT FROM CTE GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, CASE WHEN CONTACTS_CNT IS NULL THEN 0 ELSE CONTACTS_CNT END CONTACTS_CNT, CASE WHEN TRUSTED_CONTACTS_CNT IS NULL THEN 0 ELSE TRUSTED_CONTACTS_CNT END TRUSTED_CONTACTS_CNT FROM INVOICES LEFT JOIN (SELECT USER_ID, COUNT(CONTACT_EMAIL) CONTACTS_CNT, SUM(IS_TRUSTED) TRUSTED_CONTACTS_CNT FROM (SELECT * , CASE WHEN EMAIL IS NULL THEN 0 ELSE 1 END AS IS_TRUSTED FROM CONTACTS CO LEFT JOIN CUSTOMERS CU ON CO.CONTACT_EMAIL=CU.EMAIL) CO GROUP BY USER_ID) TAMPA ON TAMPA.USER_ID=INVOICES.USER_ID INNER JOIN CUSTOMERS ON INVOICES.USER_ID=CUSTOMER_ID ORDER BY INVOICES.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT A.PRODUCT_ID, ROUND(SUM(A.UNITS*B.PRICE)/SUM(A.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD AS A LEFT JOIN PRICES AS B ON A.PRODUCT_ID=B.PRODUCT_ID AND START_DATE <= A.PURCHASE_DATE AND END_DATE >= A.PURCHASE_DATE GROUP BY A.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE_FRIENDS AS ( SELECT DISTINCT CASE WHEN USER1_ID = 1 THEN USER2_ID WHEN USER2_ID = 1 THEN USER1_ID END AS USER_ID FROM FRIENDSHIP WHERE USER1_ID = 1 OR USER2_ID = 1 ), CTE_FINAL AS ( SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN ( SELECT USER_ID FROM CTE_FRIENDS ) AND PAGE_ID NOT IN ( SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1 ) ) SELECT * FROM CTE_FINAL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT X.CUSTOMER_ID,X.CUSTOMER_NAME FROM (SELECT ORDERS.CUSTOMER_ID,CUSTOMER_NAME FROM ORDERS LEFT JOIN CUSTOMERS ON ORDERS.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID WHERE PRODUCT_NAME = 'A' AND ORDERS.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B')) AS X LEFT JOIN (SELECT CUSTOMER_ID,PRODUCT_NAME FROM ORDERS WHERE PRODUCT_NAME = 'C') AS Y ON X.CUSTOMER_ID = Y.CUSTOMER_ID WHERE Y.PRODUCT_NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT SALES.PRODUCT_ID, PRODUCT_NAME FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE SALES.PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM (SELECT EMAIL, COUNT(*) AS CNT FROM PERSON GROUP BY EMAIL) AS A WHERE CNT > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 USING(ACCOUNT_ID) WHERE L1.IP_ADDRESS != L2.IP_ADDRESS AND ((L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT) OR (L2.LOGIN BETWEEN L1.LOGIN AND L1.LOGOUT));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT A.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(CASE WHEN NUM < 1000 THEN SALARY WHEN NUM >= 1000 AND NUM <= 10000 THEN SALARY * (1-0.24) WHEN NUM > 10000 THEN SALARY * (1-0.49) END,0) AS SALARY FROM SALARIES A JOIN (SELECT COMPANY_ID, MAX(SALARY) AS NUM FROM SALARIES GROUP BY COMPANY_ID) B ON A.COMPANY_ID = B.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH BOUGHTAB AS ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME IN ('A','B') GROUP BY CUSTOMER_ID HAVING COUNT(DISTINCT PRODUCT_NAME) =2 ), BOUGHTC AS ( SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME IN ('C') ) SELECT * FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT * FROM BOUGHTAB) AND CUSTOMER_ID NOT IN (SELECT * FROM BOUGHTC);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH LOCATION_COUNTS_1 AS ( SELECT LAT, LON, COUNT(DISTINCT PID) AS LATLON_COUNT FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*) = 1 ) , PIDS_WITH_UNIQUE_LOCATION AS ( SELECT DISTINCT I.PID, L.LATLON_COUNT FROM INSURANCE I INNER JOIN LOCATION_COUNTS_1 L ON I.LAT = L.LAT AND I.LON = L.LON ) , PIDS_WITH_NONUNIQUE_TIV2015S AS ( SELECT DISTINCT I.PID FROM INSURANCE I INNER JOIN INSURANCE I2 ON I.PID != I2.PID AND I.TIV_2015 = I2.TIV_2015 ) SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE I INNER JOIN PIDS_WITH_UNIQUE_LOCATION U ON U.PID = I.PID INNER JOIN PIDS_WITH_NONUNIQUE_TIV2015S N ON N.PID = I.PID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] WITH CTE1 AS ( SELECT DISTINCT * FROM LOGINFO ORDER BY LOGIN, LOGOUT) SELECT DISTINCT A.ACCOUNT_ID FROM CTE1 AS A, CTE1 AS B WHERE A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS != B.IP_ADDRESS AND A.LOGIN<=B.LOGIN AND B.LOGIN<=A.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT REPORT_REASON, REPORT_COUNT FROM( SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT, ACTION_DATE FROM ACTIONS GROUP BY EXTRA,ACTION_DATE HAVING ACTION_DATE = '2019-07-04' AND EXTRA IN ('SPAM','RACISM','FAKE','NUDITY', 'FORGERY','PORN','SCAM','OFFENSIVE', 'DRUGS','INSULT') ) T;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT VIEW.PRODUCT_ID, VIEW.STORE, VIEW.PRICE FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS VIEW WHERE VIEW.PRICE IS NOT NULL ORDER BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRO1.PRODUCT_ID AS PRODUCT_ID, 'STORE1' AS STORE, PRO1.STORE1 AS PRICE FROM PRODUCTS AS PRO1 WHERE PRO1.STORE1 IS NOT NULL UNION SELECT PRO2.PRODUCT_ID AS PRODUCT_ID, 'STORE2' AS STORE,PRO2.STORE2 AS PRICE FROM PRODUCTS AS PRO2 WHERE PRO2.STORE2 IS NOT NULL UNION SELECT PRO3.PRODUCT_ID AS PRODUCT_ID, 'STORE3' AS STORE, PRO3.STORE3 AS PRICE FROM PRODUCTS AS PRO3 WHERE PRO3.STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE (CASE WHEN AUTHOR_ID=VIEWER_ID THEN 1 ELSE NULL END ) =1 ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE AS (SELECT SALARIES.COMPANY_ID,EMPLOYEE_ID,EMPLOYEE_NAME,SALARY, MAX_SALARY FROM SALARIES JOIN (SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID) AS B ON SALARIES.COMPANY_ID=B.COMPANY_ID) SELECT COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND((CASE WHEN MAX_SALARY<1000 THEN SALARY WHEN MAX_SALARY BETWEEN 1000 AND 10000 THEN SALARY*0.76 WHEN MAX_SALARY >10000 THEN SALARY*0.51 END),0) AS SALARY FROM CTE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID WHERE D.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT(S.PRODUCT_ID), P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P. PRODUCT_ID WHERE S.PRODUCT_ID NOT IN (SELECT DISTINCT(S.PRODUCT_ID) FROM SALES S WHERE NOT (S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31') );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A1.PLAYER_ID, A1.DEVICE_ID FROM ACTIVITY A1 WHERE (A1.PLAYER_ID, A1.EVENT_DATE) IN (SELECT A2.PLAYER_ID, MIN(A2.EVENT_DATE) FROM ACTIVITY A2 GROUP BY A2.PLAYER_ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH TEMP AS ( SELECT CUSTOMER_ID, CASE WHEN PRODUCT_NAME = 'A' THEN 1 ELSE 0 END AS PA, CASE WHEN PRODUCT_NAME = 'B' THEN 1 ELSE 0 END AS PB, CASE WHEN PRODUCT_NAME = 'C' THEN 1 ELSE 0 END AS PC FROM ORDERS ), TEMP2 AS ( SELECT CUSTOMER_ID FROM TEMP GROUP BY CUSTOMER_ID HAVING SUM(PA) > 0 AND SUM(PB) > 0 AND SUM(PC) = 0) SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT * FROM TEMP2) ORDER BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID GROUP BY AUTHOR_ID ORDER BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM STUDENTS S WHERE S.DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS D);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE * U.UNITS) / SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS (SELECT S.BUYER_ID, P.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L.ACCOUNT_ID FROM LOGINFO L JOIN LOGINFO X ON X.ACCOUNT_ID=L.ACCOUNT_ID AND L.IP_ADDRESS!=X.IP_ADDRESS AND (L.LOGIN BETWEEN X.LOGIN AND X.LOGOUT OR (X.LOGIN BETWEEN L.LOGIN AND L.LOGOUT));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] WITH T AS ( SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*) = 1 ) SELECT MAX(NUM) AS NUM FROM T;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM (SELECT COUNT(DISTINCT STUDENT) AS STUDENT_COUNT , CLASS FROM COURSES GROUP BY CLASS ) A WHERE STUDENT_COUNT >= 5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH BUYERS AS ( SELECT S.*, P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME IN ('S8','IPHONE') ) SELECT DISTINCT BUYER_ID FROM BUYERS WHERE PRODUCT_NAME = 'S8' GROUP BY BUYER_ID HAVING BUYER_ID NOT IN (SELECT BUYER_ID FROM BUYERS GROUP BY BUYER_ID HAVING COUNT(DISTINCT PRODUCT_NAME) = 2);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT(S.PRODUCT_ID), P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN ( SELECT S.PRODUCT_ID FROM SALES S WHERE NOT (S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31') );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM ( SELECT CLASS, COUNT(CLASS) AS NUM FROM COURSES GROUP BY CLASS ) AS TEMP WHERE NUM >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT CASE WHEN USER1_ID = 1 THEN USER2_ID WHEN USER2_ID = 1 THEN USER1_ID END AS USERID FROM FRIENDSHIP) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT VIEW.PRODUCT_ID, VIEW.STORE, VIEW.PRICE FROM ( SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS ) AS VIEW WHERE VIEW.PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM ( SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS ) AS ORDERS WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID,MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID;\n[SQL_2] SELECT A.PLAYER_ID,MIN(A.EVENT_DATE) FIRST_LOGIN FROM ACTIVITY A GROUP BY A.PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME, B.BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE (B.BONUS < 1000) OR (B.BONUS IS NULL);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT(TIV_2015) FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1, LOGINFO L2 WHERE L1.LOGIN BETWEEN (L2.LOGIN) AND (L2.LOGOUT) AND L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS != L2.IP_ADDRESS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, STORE1 AS STORE, 'STORE1' AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID, STORE2 AS STORE, 'STORE2' AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION SELECT PRODUCT_ID, STORE3 AS STORE, 'STORE3' AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(DISTINCT V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AS AVERAGE_PRICE FROM PRICES P INNER JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID WHERE U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT(A.EMAIL) FROM PERSON A, PERSON B WHERE A.EMAIL = B.EMAIL AND A.ID > B.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND((SUM(U.UNITS * P.PRICE) / SUM(U.UNITS)), 2) AS AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT CUST.NAME AS CUSTOMERS FROM CUSTOMERS CUST LEFT JOIN ORDERS ORD ON CUST.ID = ORD.CUSTOMERID WHERE ORD.CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM (SELECT V.CUSTOMER_ID FROM VISITS V WHERE V.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS)) T GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH CTE AS ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31') SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM CTE);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID,A.CUSTOMER_NAME FROM CUSTOMERS A WHERE A.CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A' AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C'));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE * US.UNITS) / SUM(US.UNITS),2) AS AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD US ON P.PRODUCT_ID=US.PRODUCT_ID AND (US.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID=T.VISIT_ID WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID AS ACCOUNT_ID FROM LOGINFO L1, LOGINFO L2 WHERE L1.ACCOUNT_ID=L2.ACCOUNT_ID AND L1.IP_ADDRESS<>L2.IP_ADDRESS AND L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E1.UNIQUE_ID, E2.NAME FROM EMPLOYEEUNI E1 RIGHT JOIN EMPLOYEES E2 ON E1.ID = E2.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT USING(PRODUCT_ID) GROUP BY BUYER_ID HAVING (MAX( CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) = 1) AND (MAX(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM STUDENTS AS S WHERE S.DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES JOIN PRODUCT USING(PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT MAX(CUSTOMERS.NAME) AS CUSTOMERS FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMERID WHERE ORDERS.ID IS NULL GROUP BY CUSTOMERS.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH A AS( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='A' ), B AS (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='B'), C AS (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='C'), RES AS (SELECT A.CUSTOMER_ID FROM A INNER JOIN B ON A.CUSTOMER_ID=B.CUSTOMER_ID), ORD AS (SELECT RES.CUSTOMER_ID FROM RES LEFT JOIN C ON RES.CUSTOMER_ID=C.CUSTOMER_ID WHERE C.CUSTOMER_ID IS NULL) SELECT * FROM CUSTOMERS WHERE CUSTOMER_ID IN(SELECT DISTINCT CUSTOMER_ID FROM ORD);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT B.BUYER_ID FROM PRODUCT A RIGHT JOIN SALES B ON A.PRODUCT_ID = B.PRODUCT_ID GROUP BY B.BUYER_ID HAVING SUM(CASE WHEN A.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) >=1 AND SUM(CASE WHEN A.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] WITH CT1 AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID ), CT2 AS ( SELECT A.PLAYER_ID FROM ACTIVITY A JOIN CT1 C ON A.PLAYER_ID = C.PLAYER_ID AND A.EVENT_DATE = C.MIN_DATE + 1 ) SELECT C1.MIN_DATE AS INSTALL_DT, COUNT(*) AS INSTALLS, ROUND(COUNT(C2.PLAYER_ID) * 1.0 / COUNT(*), 2) AS DAY1_RETENTION FROM CT1 C1 LEFT JOIN CT2 C2 ON C1.PLAYER_ID = C2.PLAYER_ID GROUP BY C1.MIN_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' GROUP BY PRODUCT_ID);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID GROUP BY AUTHOR_ID HAVING COUNT(VIEWER_ID) >= 1 ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A JOIN LOGINFO B ON A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS != B.IP_ADDRESS AND A.LOGIN <= B.LOGOUT AND B.LOGIN <= A.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT A.PRODUCT_ID, ROUND(SUM(A.PRICE * B.UNITS)/SUM(B.UNITS),2) AS AVERAGE_PRICE FROM PRICES A JOIN UNITSSOLD B ON A.PRODUCT_ID = B.PRODUCT_ID AND A.START_DATE <= B.PURCHASE_DATE AND A.END_DATE >= B.PURCHASE_DATE GROUP BY A.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE * U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES AS P INNER JOIN UNITSSOLD AS U ON U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE AND P.PRODUCT_ID = U.PRODUCT_ID GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM ( SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*) < 2) A;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] WITH TB1 AS (SELECT PRODUCT_ID, 'STORE1' AS STORE,STORE1 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) SELECT PRODUCT_ID, STORE, PRICE FROM TB1 WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(T1.X-T2.X)) AS SHORTEST FROM POINT AS T1 JOIN POINT AS T2 ON T1.X != T2.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(UNITS*PRICE) / SUM(UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD U JOIN PRICES P ON START_DATE <= PURCHASE_DATE AND END_DATE >= PURCHASE_DATE AND U.PRODUCT_ID = P.PRODUCT_ID GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] WITH INSTALLDATE AS ( SELECT PLAYER_ID,MIN(EVENT_DATE) AS INSTALL_DT ,COUNT(DISTINCT PLAYER_ID) FROM ACTIVITY A GROUP BY PLAYER_ID ), NEXTDAY AS ( SELECT A.PLAYER_ID, A.INSTALL_DT, B.EVENT_DATE AS NEXT_DAY FROM INSTALLDATE A LEFT JOIN ACTIVITY B ON A.PLAYER_ID=B.PLAYER_ID AND B.EVENT_DATE=A.INSTALL_DT+1 ) SELECT INSTALL_DT ,COUNT(PLAYER_ID) AS INSTALLS ,ROUND(COUNT(NEXT_DAY)/COUNT(PLAYER_ID),2) AS DAY1_RETENTION FROM NEXTDAY GROUP BY INSTALL_DT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P RIGHT JOIN SALES S ON P.PRODUCT_ID=S.PRODUCT_ID WHERE P.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL AND T.AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] WITH T AS (SELECT * FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' AND EXTRA IS NOT NULL ) SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM T GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID WHERE D.NAME IS NULL ORDER BY 1,2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM (SELECT NAME, BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID=B.EMPID) A WHERE BONUS<1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT_NO_TRANS FROM ( SELECT CUSTOMER_ID, COUNT(DISTINCT V.VISIT_ID) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID ) A WHERE COUNT_NO_TRANS >= 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID , P.PRODUCT_NAME FROM PRODUCT P LEFT JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE SALE_DATE >= '2019-01-01' AND SALE_DATE <= '2019-03-31' AND P.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE <'2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH _CONTACTS AS ( SELECT USER_ID, COUNT(1) AS CNT FROM CONTACTS GROUP BY USER_ID ), _TRUSTED_CONTACTS AS ( SELECT USER_ID, COUNT(1) AS CNT FROM CONTACTS WHERE CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) GROUP BY USER_ID ) SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COALESCE(_C.CNT, 0) AS CONTACTS_CNT, COALESCE(_TC.CNT, 0) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON C.CUSTOMER_ID = I.USER_ID LEFT JOIN _CONTACTS _C ON _C.USER_ID = I.USER_ID LEFT JOIN _TRUSTED_CONTACTS _TC ON _TC.USER_ID = I.USER_ID ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM (SELECT STUDENTS.ID AS ID, STUDENTS.NAME AS NAME, DEPARTMENTS.NAME AS DEPTNAME FROM STUDENTS LEFT JOIN DEPARTMENTS ON DEPARTMENTS.ID = STUDENTS.DEPARTMENT_ID) A WHERE DEPTNAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(A.X-B.X)) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X != B.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME ,BONUS FROM EMPLOYEE A LEFT JOIN BONUS B ON A.EMPID=B.EMPID WHERE BONUS <1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT A.PRODUCT_ID, ROUND(SUM(A.PRICE*B.UNITS)/SUM(B.UNITS),2) AS AVERAGE_PRICE FROM PRICES AS A INNER JOIN UNITSSOLD AS B ON B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE AND A.PRODUCT_ID =B.PRODUCT_ID GROUP BY A.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT(ARTICLE_ID)) > 1 ORDER BY VIEWER_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT NAME, UNIQUE_ID FROM EMPLOYEES LEFT JOIN EMPLOYEEUNI ON EMPLOYEES.ID = EMPLOYEEUNI.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT DISTINCT P.PRODUCT_ID FROM PRODUCT P INNER JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE < '2019-01-01' OR S.SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM( SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*)=1 )AS A;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH T1 AS ( (SELECT USER1_ID FREIND1, USER2_ID FREIND2 FROM FRIENDSHIP WHERE USER1_ID < USER2_ID) UNION (SELECT USER2_ID FREIND1, USER1_ID FREIND2 FROM FRIENDSHIP WHERE USER2_ID < USER1_ID) ) SELECT DISTINCT PAGE_ID RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN ( SELECT FREIND2 FROM T1 WHERE FREIND1 = 1 ) AND PAGE_ID NOT IN ( SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1 );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH MAXIMUM AS (SELECT COMPANY_ID , MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID) SELECT S1.COMPANY_ID , S1.EMPLOYEE_ID , S1.EMPLOYEE_NAME , ROUND(CASE WHEN M1.MAX_SALARY >10000 THEN S1.SALARY - (0.49)*S1.SALARY WHEN M1.MAX_SALARY >=1000 AND M1.MAX_SALARY <= 10000 THEN S1.SALARY - (0.24)*S1.SALARY ELSE S1.SALARY END , 0 ) AS SALARY FROM SALARIES S1 INNER JOIN MAXIMUM M1 ON S1.COMPANY_ID = M1.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT T1.ACCOUNT_ID FROM LOGINFO T1 JOIN LOGINFO T2 ON T1.ACCOUNT_ID = T2.ACCOUNT_ID WHERE T1.IP_ADDRESS <> T2.IP_ADDRESS AND T2.LOGIN BETWEEN T1.LOGIN AND T1.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(U.UNITS*P.PRICE)/ SUM(U.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD U JOIN PRICES P ON (U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) AND P.PRODUCT_ID = U.PRODUCT_ID GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON D.ID = S.DEPARTMENT_ID WHERE D.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T AS ( SELECT BUYER_ID, PRODUCT_NAME FROM SALES T1 JOIN PRODUCT T2 ON T1.PRODUCT_ID = T2.PRODUCT_ID WHERE PRODUCT_NAME IN ('S8', 'IPHONE') ) SELECT DISTINCT BUYER_ID FROM T WHERE BUYER_ID IN (SELECT BUYER_ID FROM T WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM T WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*) = 1) AS NUMS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH TEMP AS ( SELECT MAX(SALARY) AS MAX_SALARY ,COMPANY_ID FROM SALARIES GROUP BY COMPANY_ID ) SELECT SAL.COMPANY_ID ,SAL.EMPLOYEE_ID ,SAL.EMPLOYEE_NAME ,(CASE WHEN T.MAX_SALARY < 1000 THEN SAL.SALARY WHEN T.MAX_SALARY BETWEEN 1000 AND 10000 THEN ROUND((SAL.SALARY - (SAL.SALARY * 0.24)), 0) WHEN T.MAX_SALARY > 10000 THEN ROUND((SAL.SALARY - (SAL.SALARY * 0.49)), 0) END) AS SALARY FROM SALARIES SAL JOIN TEMP T ON SAL.COMPANY_ID = T.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT P.EMAIL FROM (SELECT PERSON.EMAIL ,COUNT(*) AS DUP FROM PERSON GROUP BY EMAIL) P WHERE P.DUP > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE_CONTACTS AS ( SELECT USER_ID , COUNT(CONTACT_EMAIL) AS CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID ), CTE_INVOICE AS (SELECT INVOICE_ID,PRICE,I.USER_ID, COALESCE(CONTACTS_CNT,0) AS CONTACTS_CNT FROM INVOICES I LEFT JOIN CTE_CONTACTS C ON I.USER_ID = C.USER_ID), CTE_TRUSTED AS ( SELECT USER_ID,COUNT(CONTACT_EMAIL) AS TRUSTED_CONTACTS_CNT FROM CONTACTS C WHERE CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) GROUP BY USER_ID ) SELECT INVOICE_ID, C.CUSTOMER_NAME,PRICE,COALESCE(CONTACTS_CNT,0) AS CONTACTS_CNT ,COALESCE(TRUSTED_CONTACTS_CNT,0) AS TRUSTED_CONTACTS_CNT FROM CTE_INVOICE CI LEFT JOIN CUSTOMERS C ON CI.USER_ID = C.CUSTOMER_ID LEFT JOIN CTE_TRUSTED CT ON CT.USER_ID = CI.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID AS ID , S.NAME AS NAME FROM STUDENTS AS S LEFT JOIN DEPARTMENTS AS D ON S.DEPARTMENT_ID=D.ID WHERE D.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM LIKES L INNER JOIN (SELECT USER1_ID AS USER1, USER2_ID AS FRIEND FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER2_ID AS USER1, USER1_ID AS FRIEND FROM FRIENDSHIP WHERE USER2_ID = 1) TEMP ON L.USER_ID = TEMP.FRIEND WHERE L.PAGE_ID NOT IN (SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS (SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8') SELECT DISTINCT BUYER_ID FROM CTE WHERE CTE.BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P1.PRODUCT_ID,P1.PRODUCT_NAME FROM PRODUCT P1 WHERE P1.PRODUCT_ID NOT IN ( SELECT P.PRODUCT_ID FROM PRODUCT P INNER JOIN SALES S ON P.PRODUCT_ID=S.PRODUCT_ID WHERE S.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.VIEWER_ID AS ID FROM VIEWS AS V1, VIEWS AS V2 WHERE V1.VIEWER_ID = V2.VIEWER_ID AND V1.ARTICLE_ID <> V2.ARTICLE_ID AND V1.VIEW_DATE = V2.VIEW_DATE ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT AUTHOR_ID ID FROM VIEWS V WHERE AUTHOR_ID = VIEWER_ID GROUP BY AUTHOR_ID HAVING COUNT(ARTICLE_ID) >= 1 ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE CUSTOMERS.ID NOT IN (SELECT CUSTOMERS.ID FROM CUSTOMERS INNER JOIN ORDERS ON(CUSTOMERS.ID = ORDERS.CUSTOMERID));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 INNER JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS != L2.IP_ADDRESS WHERE (L1.LOGOUT >= L2.LOGIN AND L1.LOGIN < L2.LOGIN);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM (SELECT CLASS,COUNT(CLASS) AS NUMBER FROM COURSES GROUP BY CLASS ) AS A WHERE NUMBER >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT DISTINCT(BUYER_ID) FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID AND P.PRODUCT_NAME = 'IPHONE'), TEMP AS ( SELECT DISTINCT(BUYER_ID) FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID AND P.PRODUCT_NAME = 'S8') SELECT T.BUYER_ID FROM TEMP T LEFT JOIN CTE C ON T.BUYER_ID = C.BUYER_ID WHERE C.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CNT AS ( SELECT T.USER_ID, COUNT(*) CONTACTS_CNT, SUM(TRUSTED) TRUSTED_CONTACTS_CNT FROM ( SELECT CT.*, CASE WHEN CM.EMAIL IS NULL THEN 0 ELSE 1 END TRUSTED FROM CONTACTS CT LEFT JOIN CUSTOMERS CM ON CT.CONTACT_EMAIL = CM.EMAIL ) T GROUP BY T.USER_ID ) SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE , COALESCE(CONTACTS_CNT, 0) CONTACTS_CNT, COALESCE(TRUSTED_CONTACTS_CNT, 0) TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CNT ON I.USER_ID = CNT.USER_ID ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH FULL_TABLE AS ( SELECT VISITS.VISIT_ID, VISITS.CUSTOMER_ID, TRANSACTIONS.TRANSACTION_ID, TRANSACTIONS.AMOUNT FROM VISITS LEFT OUTER JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID UNION SELECT VISITS.VISIT_ID, VISITS.CUSTOMER_ID, TRANSACTIONS.TRANSACTION_ID, TRANSACTIONS.AMOUNT FROM VISITS RIGHT OUTER JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID ) SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM ( SELECT CUSTOMER_ID FROM FULL_TABLE WHERE AMOUNT IS NULL ) AS SUBQUERY GROUP BY CUSTOMER_ID ORDER BY COUNT(*) DESC, CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT B.PLAYER_ID, B.DEVICE_ID FROM ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENTT FROM ACTIVITY GROUP BY PLAYER_ID ) A JOIN ACTIVITY B ON A.PLAYER_ID = B.PLAYER_ID AND A.EVENTT = B.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT T1.PRODUCT_ID, T1.PRODUCT_NAME FROM PRODUCT AS T1 INNER JOIN SALES AS T2 USING(PRODUCT_ID) GROUP BY T1.PRODUCT_ID, T1.PRODUCT_NAME HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT CASE WHEN USER1_ID = 1 THEN USER2_ID WHEN USER2_ID = 1 THEN USER1_ID END AS USER_ID FROM FRIENDSHIP WHERE USER1_ID = 1 OR USER2_ID = 1) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME,POPULATION,AREA FROM WORLD WHERE AREA > 3000000 OR POPULATION > 25000000 ORDER BY AREA ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, (ROUND(SUM(E.EXPERIENCE_YEARS)/COUNT(E.NAME), 2)) AS AVERAGE_YEARS FROM PROJECT AS P JOIN EMPLOYEE AS E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH CTE AS ( SELECT P.PRODUCT_ID, PRICE, UNITS, PRICE*UNITS AS TOTAL FROM PRICES P INNER JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID WHERE U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ) SELECT PRODUCT_ID, ROUND(SUM(TOTAL)/ SUM(UNITS),2) AS AVERAGE_PRICE FROM CTE GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE AS( SELECT C.CUSTOMER_ID,COUNT(*) AS CONTACTS_CNT FROM CUSTOMERS C INNER JOIN CONTACTS CO ON C.CUSTOMER_ID = CO.USER_ID GROUP BY C.CUSTOMER_ID), OUTERCTE AS ( SELECT C.CUSTOMER_ID ,COUNT(*) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS C INNER JOIN CONTACTS CO ON C.CUSTOMER_ID = CO.USER_ID WHERE CO.CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS C1) GROUP BY CUSTOMER_ID) SELECT I.INVOICE_ID,C.CUSTOMER_NAME,PRICE ,CASE WHEN CONTACTS_CNT IS NULL THEN 0 ELSE CONTACTS_CNT END AS CONTACTS_CNT ,CASE WHEN TRUSTED_CONTACTS_CNT IS NULL THEN 0 ELSE TRUSTED_CONTACTS_CNT END AS TRUSTED_CONTACTS_CNT FROM INVOICES I INNER JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CTE CT ON CT.CUSTOMER_ID = C.CUSTOMER_ID LEFT JOIN OUTERCTE OT ON OT.CUSTOMER_ID = C.CUSTOMER_ID ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM PRODUCT WHERE PRODUCT.PRODUCT_ID NOT IN ( SELECT P.PRODUCT_ID FROM PRODUCT AS P LEFT JOIN SALES AS S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM EMPLOYEE E LEFT OUTER JOIN BONUS B ON E.EMPID=B.EMPID WHERE B.BONUS<1000 OR B.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID =P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND S.BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM (SELECT S.BUYER_ID FROM SALES AS S LEFT OUTER JOIN PRODUCT AS P USING (PRODUCT_ID) WHERE P.PRODUCT_NAME = 'S8' ) AS SAMSUNG LEFT OUTER JOIN (SELECT S.BUYER_ID FROM SALES AS S LEFT OUTER JOIN PRODUCT AS P USING (PRODUCT_ID) WHERE P.PRODUCT_NAME = 'IPHONE') AS APPLE USING (BUYER_ID) WHERE APPLE.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH FRIENDS AS ( SELECT DISTINCT USER2_ID AS USER_ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT DISTINCT USER1_ID AS USER_ID FROM FRIENDSHIP WHERE USER2_ID = 1 ) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT DISTINCT USER_ID FROM FRIENDS) AND PAGE_ID NOT IN ( SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID = 1) ORDER BY PAGE_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] WITH T1 AS (SELECT ACTOR_ID, DIRECTOR_ID, ACTOR_ID + ',' + DIRECTOR_ID AS PAIR FROM ACTORDIRECTOR) SELECT ACTOR_ID, DIRECTOR_ID FROM T1 GROUP BY PAIR,ACTOR_ID, DIRECTOR_ID HAVING COUNT(*) >=3;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EMPLOYEES.NAME, EMPLOYEEUNI.UNIQUE_ID FROM EMPLOYEES LEFT JOIN EMPLOYEEUNI ON EMPLOYEES.ID = EMPLOYEEUNI.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS, DATE_ID, MAKE_NAME FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT T.PRODUCT_ID, ROUND(SUM(T.PRICE) / SUM(T.UNITS), 2) AS AVERAGE_PRICE FROM ( SELECT U.PRODUCT_ID, U.UNITS, U.UNITS * P.PRICE AS PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PURCHASE_DATE >= P.START_DATE AND U.PURCHASE_DATE <= P.END_DATE AND U.PRODUCT_ID = P.PRODUCT_ID ) AS T GROUP BY T.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CNT AS (SELECT USER_ID, COUNT(DISTINCT CONTACTS.CONTACT_EMAIL) AS CONTACTS_CNT, COUNT(CUSTOMERS.EMAIL) AS TRUSTED_CONTACTS_CNT FROM CONTACTS LEFT JOIN CUSTOMERS ON CUSTOMERS.EMAIL = CONTACTS.CONTACT_EMAIL GROUP BY CONTACTS.USER_ID ) SELECT INVOICES.INVOICE_ID, CUSTOMERS.CUSTOMER_NAME, INVOICES.PRICE, COALESCE(CNT.CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(CNT.TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM INVOICES JOIN CUSTOMERS ON INVOICES.USER_ID = CUSTOMERS.CUSTOMER_ID LEFT JOIN CNT ON INVOICES.USER_ID = CNT.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA REPORT_REASON, COUNT(DISTINCT POST_ID) REPORT_COUNT FROM ACTIONS A WHERE ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM SALES WHERE BUYER_ID IN ( SELECT BUYER_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' ) AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM (SELECT DISTINCT I1.* FROM INSURANCE I1 JOIN INSURANCE I2 ON I1.TIV_2015 = I2.TIV_2015 AND I1.PID <> I2.PID AND (I1.LAT <> I2.LAT OR I1.LON <> I2.LON) AND (I1.LAT,I1.LON) NOT IN (SELECT DISTINCT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*) > 1))A;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(CLASS)>4;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS LEFT OUTER JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMERID WHERE CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID,C.CUSTOMER_NAME FROM CUSTOMERS C WHERE C.CUSTOMER_ID IN (SELECT O.CUSTOMER_ID FROM ORDERS O WHERE O.PRODUCT_NAME='A') AND C.CUSTOMER_ID IN (SELECT O.CUSTOMER_ID FROM ORDERS O WHERE O.PRODUCT_NAME='B') AND C.CUSTOMER_ID NOT IN (SELECT O.CUSTOMER_ID FROM ORDERS O WHERE O.PRODUCT_NAME='C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(CON.USER_ID) AS CONTACTS_CNT, COUNT(C2.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON C.CUSTOMER_ID = I.USER_ID LEFT JOIN CONTACTS CON ON CON.USER_ID = C.CUSTOMER_ID LEFT JOIN CUSTOMERS C2 ON C2.EMAIL = CON.CONTACT_EMAIL GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT P.LASTNAME, P.FIRSTNAME, A.CITY, A.STATE FROM PERSON P LEFT JOIN ADDRESS A ON P.PERSONID = A.PERSONID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(DISTINCT(STUDENT)) >=5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT T1.PROJECT_ID, ROUND(AVG(T2.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT AS T1 LEFT JOIN EMPLOYEE AS T2 ON T1.EMPLOYEE_ID =T2.EMPLOYEE_ID GROUP BY T1.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] WITH T AS (SELECT A.ACCOUNT_ID, A.LOGIN AS LOGIN1, A.LOGOUT AS LOGOUT1, B.LOGIN AS LOGIN2, B.LOGOUT AS LOGOUT2 FROM LOGINFO A JOIN LOGINFO B ON A.ACCOUNT_ID=B.ACCOUNT_ID WHERE A.IP_ADDRESS<>B.IP_ADDRESS) SELECT DISTINCT (ACCOUNT_ID) FROM T WHERE LOGIN1 BETWEEN LOGIN2 AND LOGOUT2;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM ( SELECT A.NAME, B.BONUS FROM EMPLOYEE A LEFT JOIN BONUS B ON A.EMPID = B.EMPID ) C WHERE C.BONUS <1000 OR C.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH TA AS (SELECT V.*, T.VISIT_ID AS T_VISIT, T.TRANSACTION_ID FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL) SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM TA GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH T1 AS ( SELECT C.CUSTOMER_ID FROM CUSTOMERS C JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE PRODUCT_NAME = 'C' ), T2 AS ( SELECT C.CUSTOMER_ID FROM CUSTOMERS C JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE PRODUCT_NAME = 'A' ), T3 AS ( SELECT C.CUSTOMER_ID FROM CUSTOMERS C JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE PRODUCT_NAME = 'B' ) SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID NOT IN (SELECT T1.CUSTOMER_ID FROM T1) AND CUSTOMER_ID IN (SELECT DISTINCT T2.CUSTOMER_ID FROM T2) AND CUSTOMER_ID IN (SELECT DISTINCT T3.CUSTOMER_ID FROM T3);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH A AS (SELECT P.PRODUCT_ID,PRICE*UNITS AS PC,UNITS FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID=U.PRODUCT_ID WHERE PURCHASE_DATE BETWEEN START_DATE AND END_DATE) SELECT PRODUCT_ID,ROUND(SUM(PC)/SUM(UNITS),2) AS AVERAGE_PRICE FROM A GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LON, LAT) IN (SELECT LON, LAT FROM INSURANCE GROUP BY LON, LAT HAVING COUNT(LAT)=1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(X1.X-X2.X)) AS SHORTEST FROM POINT X1 JOIN POINT X2 ON X1.X!=X2.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.NAME, U.UNIQUE_ID FROM EMPLOYEES AS E LEFT JOIN EMPLOYEEUNI AS U ON E.ID = U.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' GROUP BY EXTRA ORDER BY REPORT_REASON;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES WHERE PRODUCT_ID IN ( SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME='IPHONE' ) ) AND BUYER_ID IN ( SELECT BUYER_ID FROM SALES WHERE PRODUCT_ID IN ( SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME='S8' ) );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID NOT IN (SELECT DISTINCT(CUSTOMER_ID) FROM ORDERS WHERE PRODUCT_NAME = 'C' ) AND CUSTOMER_ID IN (SELECT DISTINCT(CUSTOMER_ID) FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT(CUSTOMER_ID) FROM ORDERS WHERE PRODUCT_NAME = 'B') ORDER BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] WITH T1 AS (SELECT S.ID AS ID, S.NAME AS NAME, D.NAME AS DEP_NAME FROM STUDENTS AS S LEFT JOIN DEPARTMENTS AS D ON S.DEPARTMENT_ID = D.ID) SELECT ID, NAME FROM T1 WHERE DEP_NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM (SELECT P.PROJECT_ID, P.EMPLOYEE_ID, E.EXPERIENCE_YEARS FROM PROJECT AS P LEFT JOIN EMPLOYEE AS E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID) AS JT GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS( SELECT S.*, CASE WHEN P.PRODUCT_NAME='S8' THEN 0 WHEN P.PRODUCT_NAME='IPHONE' THEN 1 ELSE NULL END AS N_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID=P.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM CTE WHERE N_ID IS NOT NULL GROUP BY BUYER_ID HAVING SUM(N_ID)=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALES.SALE_DATE < '2019-01-01' OR SALES.SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(DISTINCT B.PLAYER_ID)/COUNT(DISTINCT A.PLAYER_ID),2) AS FRACTION FROM ACTIVITY A LEFT JOIN (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_DATE FROM ACTIVITY GROUP BY PLAYER_ID) B ON A.PLAYER_ID=B.PLAYER_ID AND A.EVENT_DATE= B.FIRST_DATE+1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(N.NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*) = 1) N;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN( SELECT DISTINCT S.PRODUCT_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH S8 AS (SELECT DISTINCT BUYER_ID FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID=PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME='S8' ), IPHONE AS (SELECT DISTINCT BUYER_ID FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID=PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME='IPHONE' ) SELECT S8.BUYER_ID FROM S8 LEFT JOIN IPHONE ON S8.BUYER_ID=IPHONE.BUYER_ID WHERE IPHONE.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID=TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.AMOUNT IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT T1.NAME, T2.BONUS FROM EMPLOYEE T1 LEFT OUTER JOIN BONUS T2 ON T1.EMPID = T2.EMPID WHERE COALESCE(T2.BONUS, 0) < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH FRND AS( SELECT USER2_ID AS USERS FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER1_ID AS USERS FROM FRIENDSHIP WHERE USER2_ID = 1 ) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT USERS FROM FRND) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(A.X-B.X) AS SHORTEST FROM POINT AS A JOIN POINT AS B ON A.X <>B.X ORDER BY 1 LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH F AS ( SELECT USER2_ID ID FROM FRIENDSHIP WHERE USER1_ID=1 UNION SELECT USER1_ID ID FROM FRIENDSHIP WHERE USER2_ID=1 ) SELECT DISTINCT PAGE_ID RECOMMENDED_PAGE FROM LIKES JOIN F ON USER_ID=F.ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH TAX AS (SELECT COMPANY_ID, CASE WHEN MAX_SALARY <=1000 THEN 0 WHEN MAX_SALARY <=10000 THEN 0.24 ELSE 0.49 END AS TAX_RATE FROM (SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID)AS TEMP) SELECT SALARIES.COMPANY_ID,SALARIES.EMPLOYEE_ID,SALARIES.EMPLOYEE_NAME,ROUND(SALARY*(1-TAX_RATE),0) AS SALARY FROM SALARIES LEFT JOIN TAX ON SALARIES.COMPANY_ID = TAX.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(U.UNITS*P.PRICE)/SUM(U.UNITS),2)AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON U.PRODUCT_ID =P.PRODUCT_ID AND PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME AS CUSTOMERS FROM CUSTOMERS AS C LEFT JOIN ORDERS AS O ON C.ID = O.CUSTOMERID WHERE O.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH RE AS (SELECT * FROM LIKES WHERE USER_ID IN (SELECT * FROM( SELECT USER2_ID AS USER_ID FROM FRIENDSHIP WHERE USER1_ID =1 UNION SELECT USER1_ID FROM FRIENDSHIP WHERE USER2_ID=1) A)) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM RE WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(*)!=1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' AND EXTRA IS NOT NULL GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM PRODUCT WHERE PRODUCT.PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE <'2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT NAME,UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI U ON E.ID=U.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT DISTINCT USER2_ID AS ID FROM FRIENDSHIP WHERE USER1_ID = 1) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1) UNION SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT DISTINCT USER1_ID AS ID FROM FRIENDSHIP WHERE USER2_ID = 1) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH CTE AS (SELECT V.CUSTOMER_ID, T.VISIT_ID, T.TRANSACTION_ID FROM TRANSACTIONS T RIGHT JOIN VISITS V ON V.VISIT_ID = T.VISIT_ID) SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM CTE WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH PRODUCT_SALE AS ( SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE>'2019-03-31' OR SALE_DATE<'2019-01-01' ) SELECT DISTINCT SALES.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE SALES.PRODUCT_ID NOT IN (SELECT * FROM PRODUCT_SALE);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] WITH INSTALL_DATE AS (SELECT PLAYER_ID, MIN(EVENT_DATE) INSTALL_DT FROM ACTIVITY GROUP BY PLAYER_ID) SELECT T1.INSTALL_DT, ROUND(COUNT(T1.PLAYER_ID),2) INSTALLS, ROUND(COUNT(T2.EVENT_DATE)/COUNT(INSTALL_DT),2) DAY1_RETENTION FROM INSTALL_DATE T1 LEFT JOIN ACTIVITY T2 ON T1.PLAYER_ID = T2.PLAYER_ID AND T1.INSTALL_DT + 1 = T2.EVENT_DATE GROUP BY T1.INSTALL_DT ORDER BY T1.INSTALL_DT;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT A.NAME, B.BONUS FROM EMPLOYEE AS A LEFT JOIN BONUS AS B ON A.EMPID=B.EMPID WHERE (B.BONUS<1000) OR (B.BONUS IS NULL);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID AS CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS C RIGHT JOIN (SELECT CUSTOMER_ID FROM (SELECT CUSTOMER_ID, SUM(CASE WHEN PRODUCT_NAME = 'A' THEN 1 WHEN PRODUCT_NAME = 'B' THEN 2 WHEN PRODUCT_NAME = 'C' THEN -3 ELSE 0 END) AS F FROM ORDERS GROUP BY CUSTOMER_ID) T WHERE F >= 3) P ON C.CUSTOMER_ID = P.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID, MAX(CUSTOMER_NAME) AS CUSTOMER_NAME, MIN(PRICE) AS PRICE, COUNT( CN.CONTACT_EMAIL) AS CONTACTS_CNT, COUNT(CASE WHEN CN.CONTACT_EMAIL IN(SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE NULL END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS C LEFT JOIN CONTACTS CN ON C.CUSTOMER_ID=CN.USER_ID JOIN INVOICES I ON I.USER_ID=C.CUSTOMER_ID GROUP BY INVOICE_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.VIEWER_ID AS ID FROM VIEWS V1 JOIN VIEWS V2 ON V1.VIEW_DATE = V2.VIEW_DATE AND V1.VIEWER_ID = V2.VIEWER_ID AND V1.ARTICLE_ID != V2.ARTICLE_ID ORDER BY V1.VIEWER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE AS( SELECT COMPANY_ID,MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID) SELECT E.COMPANY_ID, E.EMPLOYEE_ID, E.EMPLOYEE_NAME, ROUND((CASE WHEN J.MAX_SALARY <1000 THEN SALARY WHEN J.MAX_SALARY BETWEEN 1000 AND 10000 THEN SALARY-SALARY*0.24 ELSE SALARY-SALARY*0.49 END),0) AS SALARY FROM SALARIES E LEFT JOIN CTE J ON E.COMPANY_ID=J.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, PRODUCT_NAME FROM PRODUCT P JOIN (SELECT PRODUCT_ID, SUM(FLAG) FROM (SELECT PRODUCT_ID, SALE_DATE, CASE WHEN SALE_DATE < '2019-01-01' THEN 1 WHEN SALE_DATE > '2019-03-31' THEN 1 ELSE 0 END AS FLAG FROM SALES) X GROUP BY PRODUCT_ID HAVING SUM(FLAG) = 0) Y ON P.PRODUCT_ID = Y.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID AND PRODUCT_NAME = 'S8' WHERE BUYER_ID NOT IN (SELECT DISTINCT BUYER_ID FROM SALES JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT CASE WHEN B.UNIQUE_ID IS NOT NULL THEN B.UNIQUE_ID ELSE NULL END AS UNIQUE_ID, NAME FROM EMPLOYEES AS A LEFT JOIN EMPLOYEEUNI AS B ON A.ID = B.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID,ROUND((SUM(PRICE*UNITS)/SUM(UNITS)),2) AS AVERAGE_PRICE FROM PRICES P INNER JOIN UNITSSOLD U ON P.PRODUCT_ID=U.PRODUCT_ID WHERE PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID ORDER BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH CTE AS (SELECT VIEW_DATE, VIEWER_ID, COUNT(ARTICLE_ID) FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID)>1 ) SELECT DISTINCT VIEWER_ID AS ID FROM CTE ORDER BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON , COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION= 'REPORT' AND ACTION_DATE ='2019-07-04' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A INNER JOIN LOGINFO B ON A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS != B.IP_ADDRESS AND ((A.LOGOUT BETWEEN B.LOGIN AND B.LOGOUT) OR (B.LOGOUT BETWEEN A.LOGIN AND A.LOGOUT));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID AS CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID,P.PRODUCT_NAME FROM PRODUCT AS P JOIN SALES AS S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND S.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE<'2019-01-01' OR SALE_DATE>'2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) COUNT_NO_TRANS FROM VISITS A LEFT JOIN TRANSACTIONS B ON A.VISIT_ID = B.VISIT_ID WHERE B.TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE * U.UNITS) / SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON U.PURCHASE_DATE >= P.START_DATE AND U.PURCHASE_DATE <= P.END_DATE AND P.PRODUCT_ID = U.PRODUCT_ID GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT SALES.BUYER_ID,PRODUCT.* FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS ( SELECT S.BUYER_ID, SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS S8_FLAG, SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS IPHONE_FLAG FROM SALES S JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY S.BUYER_ID ) SELECT DISTINCT BUYER_ID FROM TEMP WHERE S8_FLAG > 0 AND IPHONE_FLAG = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH CTE AS ( SELECT DISTINCT O1.CUSTOMER_ID FROM ORDERS O1 LEFT JOIN ORDERS O2 ON O1.CUSTOMER_ID=O2.CUSTOMER_ID WHERE O1.PRODUCT_NAME='A' AND O2.PRODUCT_NAME='B' ) SELECT C2.CUSTOMER_ID, C2.CUSTOMER_NAME FROM CTE C1 JOIN CUSTOMERS C2 ON C1.CUSTOMER_ID=C2.CUSTOMER_ID AND C1.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID AS CUSTOMER_ID ,CUSTOMER_NAME FROM( SELECT CUSTOMER_ID ,SUM(CASE WHEN PRODUCT_NAME = 'A' OR PRODUCT_NAME = 'B' THEN 1 ELSE 0 END) ABCNT ,COALESCE(SUM(CASE WHEN PRODUCT_NAME = 'C' THEN 1 END),0) AS CCNT FROM ORDERS ORDERS GROUP BY CUSTOMER_ID ) A JOIN CUSTOMERS CUSTOMERS ON A.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID WHERE ABCNT >= 2 AND CCNT = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH TEMP AS ( (SELECT PAGE_ID FROM LIKES WHERE USER_ID IN (SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID=1 AND USER2_ID != 1)) UNION (SELECT PAGE_ID FROM LIKES WHERE USER_ID IN (SELECT USER1_ID FROM FRIENDSHIP WHERE USER1_ID!=1 AND USER2_ID = 1)) ) SELECT PAGE_ID AS RECOMMENDED_PAGE FROM TEMP WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID =1 );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM (SELECT CLASS, COUNT(DISTINCT STUDENT) AS INNER_NUMBER_OF_VALUES FROM COURSES GROUP BY CLASS) AS INNER_QUERY WHERE INNER_NUMBER_OF_VALUES >= 5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEES LEFT JOIN EMPLOYEEUNI USING (ID) ORDER BY NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH RATES AS ( SELECT COMPANY_ID, CASE WHEN MAX(SALARY) < 1000 THEN 0 WHEN MAX(SALARY) >= 1000 AND MAX(SALARY) < 10000 THEN 24 ELSE 49 END AS RATE FROM SALARIES GROUP BY COMPANY_ID ) SELECT SALARIES.COMPANY_ID, SALARIES.EMPLOYEE_ID, SALARIES.EMPLOYEE_NAME, ROUND(SALARIES.SALARY - ((RATES.RATE * SALARIES.SALARY) / 100), 0) AS SALARY FROM SALARIES JOIN RATES ON SALARIES.COMPANY_ID = RATES.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN( SELECT S.PRODUCT_ID FROM SALES S WHERE S.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT NAME, UNIQUE_ID FROM EMPLOYEEUNI UNI RIGHT JOIN EMPLOYEES E ON UNI.ID=E.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(P1.X - P2.X)) AS SHORTEST FROM POINT AS P1 CROSS JOIN POINT AS P2 WHERE P1.X > P2.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] WITH TMP2 AS ( SELECT T1.ACCOUNT_ID, T1.IP_ADDRESS, T1.LOGOUT, T2.LOGIN, CASE WHEN T1.LOGIN < T2.LOGIN AND T1.LOGOUT < T2.LOGIN THEN 'NOT BANNED ELSE BANNED' END AS LABEL FROM LOGINFO T1 LEFT JOIN LOGINFO T2 ON T1.ACCOUNT_ID = T2.ACCOUNT_ID AND T1.IP_ADDRESS <> T2.IP_ADDRESS AND T1.LOGIN < T2.LOGIN WHERE T2.LOGIN <= T1.LOGOUT ) SELECT DISTINCT ACCOUNT_ID FROM TMP2 WHERE LABEL = 'BANNED';\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY*(1-TAX)) AS SALARY FROM SALARIES S JOIN ( SELECT COMPANY_ID, (CASE WHEN MAX(SALARY) <=1000 THEN 0 WHEN MAX(SALARY) >=10000 THEN 0.49 ELSE 0.24 END) AS TAX FROM SALARIES GROUP BY COMPANY_ID)T ON T.COMPANY_ID = S.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] WITH CTE AS (SELECT E.NAME,B.BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID ) SELECT NAME,BONUS FROM CTE WHERE BONUS<1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEEUNI E1 RIGHT JOIN EMPLOYEES E2 ON E1.ID = E2.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT C.CLASS FROM (SELECT CLASS, COUNT(STUDENT) AS COUNTER FROM COURSES GROUP BY CLASS) C WHERE C.COUNTER >=5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.AUTHOR_ID AS ID FROM VIEWS V1 INNER JOIN VIEWS V2 ON V1.AUTHOR_ID = V2.VIEWER_ID AND V1.ARTICLE_ID = V2.ARTICLE_ID ORDER BY 1 ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES JOIN PRODUCT USING (PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) >= 1 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT A.*,B.PRODUCT_NAME FROM SALES A LEFT JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM CTE WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME ='IPHONE') AND BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME ='S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE IN ('2019-07-04') AND EXTRA IS NOT NULL AND ACTION = 'REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM (SELECT EXTRA, POST_ID FROM ACTIONS WHERE ACTION = 'REPORT' AND EXTRA IS NOT NULL AND ACTION_DATE = '2019-07-04') AS TEMP GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P USING (PRODUCT_ID) GROUP BY S.PRODUCT_ID, P.PRODUCT_NAME HAVING SUM(CASE WHEN S.SALE_DATE >= '2019-01-01' AND S.SALE_DATE <= '2019-03-31' THEN 0 ELSE 1 END)=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH T1 AS ( SELECT DISTINCT A.PID FROM INSURANCE A JOIN INSURANCE B ON A.TIV_2015 = B.TIV_2015 AND (A.LAT, A.LON) != (B.LAT, B.LON) ), T2 AS ( SELECT DISTINCT A.PID FROM INSURANCE A JOIN INSURANCE B ON A.PID != B.PID AND (A.LAT, A.LON) = (B.LAT, B.LON) ) SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE PID IN (SELECT PID FROM T1) AND PID NOT IN (SELECT PID FROM T2);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM FRIENDSHIP F INNER JOIN LIKES L ON (F.USER2_ID = L.USER_ID OR F.USER1_ID = L.USER_ID) WHERE (F.USER1_ID = 1 OR F.USER2_ID = 1) AND L.USER_ID != 1 AND L.PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM ( SELECT CUSTOMER_ID FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTION_ID IS NULL ) AS A GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID, DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID HAVING COUNT(1) >= 3 ORDER BY NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN ( SELECT USER1_ID AS USER_ID FROM FRIENDSHIP WHERE USER2_ID=1 UNION SELECT USER2_ID AS USER_ID FROM FRIENDSHIP WHERE USER1_ID=1 ) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT A.NAME, B.BONUS FROM EMPLOYEE A LEFT JOIN BONUS B ON A.EMPID=B.EMPID WHERE (B.BONUS <1000 OR B.BONUS IS NULL);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] (SELECT '[0-5>' AS BIN, SUM(CASE WHEN DURATION/60 < 5 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION (SELECT '[5-10>' AS BIN, SUM(CASE WHEN DURATION/60 BETWEEN 5 AND 10 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION (SELECT '[10-15>' AS BIN, SUM(CASE WHEN DURATION/60 BETWEEN 10 AND 15 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION (SELECT '15 OR MORE' AS BIN, SUM(CASE WHEN DURATION/60 > 15 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL ) UNION (SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL ) UNION (SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL ) ORDER BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH SALES_WITH_PRODUCT_NAME AS( SELECT S.BUYER_ID,S.PRODUCT_ID,P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID) SELECT DISTINCT(BUYER_ID) FROM SALES_WITH_PRODUCT_NAME WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES_WITH_PRODUCT_NAME WHERE PRODUCT_NAME='IPHONE') AND BUYER_ID IN (SELECT BUYER_ID FROM SALES_WITH_PRODUCT_NAME WHERE PRODUCT_NAME='S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S WHERE BUYER_ID IN (SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME ='S8') AND BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME ='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND P.PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE >= '2019-04-01' OR SALE_DATE <= '2018-12-31') ORDER BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN (SELECT DISTINCT S.PRODUCT_ID FROM SALES S WHERE S.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID,MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID;\n[SQL_2] SELECT DISTINCT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT PLAYER_ID,DEVICE_ID FROM ACTIVITY WHERE (EVENT_DATE,PLAYER_ID) IN (SELECT MIN(EVENT_DATE) AS EVENT_DT,PLAYER_ID FROM ACTIVITY GROUP BY PLAYER_ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] SELECT NAME FROM CUSTOMER C1 WHERE (C1.REFEREE_ID != 2) OR (C1.REFEREE_ID IS NULL);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH AB AS ( SELECT CUSTOMER_ID FROM ORDERS WHERE CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND PRODUCT_NAME = 'B' ) SELECT A.CUSTOMER_ID, CUSTOMER_NAME FROM AB A JOIN CUSTOMERS C USING(CUSTOMER_ID) WHERE A.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID, COUNT(A.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS AS A LEFT JOIN TRANSACTIONS AS B USING(VISIT_ID) WHERE B.AMOUNT IS NULL GROUP BY A.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT OUTER JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY MAKE_NAME, DATE_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT P.FIRSTNAME, P.LASTNAME, A.CITY, A.STATE FROM PERSON P LEFT JOIN ADDRESS A ON P.PERSONID = A.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID WHERE TRANSACTIONS.TRANSACTION_ID IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT T.PRODUCT_ID, ROUND(T.TOTAL_SUM / T.COUNTS, 2) AVERAGE_PRICE FROM ( SELECT P.PRODUCT_ID, SUM(U.UNITS * P.PRICE) TOTAL_SUM, SUM(U.UNITS) COUNTS FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID) T;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME AS NAME, B.BONUS AS BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE B.BONUS < 1000 OR B.EMPID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM (SELECT VIEWER_ID, VIEW_DATE, COUNT(DISTINCT ARTICLE_ID) AS CNT FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE) A WHERE A.CNT > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID ,COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT X.COMPANY_ID,X.EMPLOYEE_ID,X.EMPLOYEE_NAME,ROUND(X.SALARY - 0.01*X.PCT*X.SALARY) AS SALARY FROM (SELECT A.*,CASE WHEN B.MAXIMUM <= 1000 THEN 0 WHEN B.MAXIMUM <= 10000 THEN 24 ELSE 49 END AS PCT FROM SALARIES A JOIN ( SELECT COMPANY_ID,MAX(SALARY) AS MAXIMUM FROM SALARIES GROUP BY COMPANY_ID) B ON A.COMPANY_ID = B.COMPANY_ID)X;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH TEMP_PRICE AS ( SELECT U.PRODUCT_ID, P.PRICE*U.UNITS AS T_PRICE, U.UNITS FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID=P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ) SELECT PRODUCT_ID, ROUND(SUM(T_PRICE)/SUM(UNITS),2) AS AVERAGE_PRICE FROM TEMP_PRICE GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EUNI.UNIQUE_ID, E.NAME FROM EMPLOYEES AS E LEFT OUTER JOIN EMPLOYEEUNI AS EUNI ON E.ID = EUNI.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM PRODUCT P1 JOIN SALES S1 ON P1.PRODUCT_ID = S1.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(CON.USER_ID) AS CONTACTS_CNT, COUNT(C2.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS C ON C.CUSTOMER_ID = I.USER_ID LEFT JOIN CONTACTS CON ON CON.USER_ID = C.CUSTOMER_ID LEFT JOIN CUSTOMERS C2 ON C2.EMAIL = CON.CONTACT_EMAIL GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT P.EMAIL FROM PERSON AS P GROUP BY P.EMAIL HAVING COUNT(*)>1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(A.X-B.X) AS SHORTEST FROM POINT A, POINT B WHERE A.X!=B.X ORDER BY SHORTEST ASC LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COALESCE(T.CNT,0) CONTACTS_CNT, COALESCE(T2.CNT,0) TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN ( SELECT USER_ID, COUNT(*) CNT FROM CONTACTS GROUP BY USER_ID ) T ON I.USER_ID = T.USER_ID LEFT JOIN ( SELECT USER_ID, COUNT(*) CNT FROM CONTACTS WHERE (CONTACT_NAME, CONTACT_EMAIL) IN (SELECT CUSTOMER_NAME, EMAIL FROM CUSTOMERS ) GROUP BY USER_ID ) T2 ON I.USER_ID = T2.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C INNER JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE C.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND C.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND C.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT A.ID, A.NAME FROM STUDENTS A LEFT JOIN DEPARTMENTS B ON A.DEPARTMENT_ID = B.ID WHERE B.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH CTE AS( SELECT U.PRODUCT_ID, U.PURCHASE_DATE, U.UNITS, P.PRICE FROM UNITSSOLD U JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND (PURCHASE_DATE BETWEEN START_DATE AND END_DATE)) SELECT PRODUCT_ID, ROUND(SUM(PRICE * UNITS) / SUM(UNITS),2) AS AVERAGE_PRICE FROM CTE GROUP BY PRODUCT_ID ORDER BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND((SUM(P.PRICE * U.UNITS)/SUM(U.UNITS)),2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT P.PRODUCT_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE < '2019-01-01' OR S.SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID = CUSTOMERID WHERE CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S1.ID, S1.NAME FROM STUDENTS AS S1 LEFT JOIN DEPARTMENTS D1 ON S1.DEPARTMENT_ID = D1.ID WHERE D1.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(T2.PLAYER_ID)/COUNT(T1.PLAYER_ID),2) AS FRACTION FROM (SELECT PLAYER_ID,MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) T1 LEFT JOIN ACTIVITY T2 ON T1.PLAYER_ID =T2.PLAYER_ID AND T1.EVENT_DATE =T2.EVENT_DATE -1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(DISTINCT A.PLAYER_ID)/COUNT(DISTINCT T.PLAYER_ID), 2) FRACTION FROM ( SELECT PLAYER_ID, MIN(EVENT_DATE) FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID ) T LEFT JOIN ACTIVITY A ON T.PLAYER_ID = A.PLAYER_ID AND T.FIRST_LOGIN + 1 = A.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    }
]