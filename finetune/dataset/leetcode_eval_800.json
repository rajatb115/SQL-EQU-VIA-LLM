[
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.AUTHOR_ID AS ID FROM VIEWS V1, VIEWS V2 WHERE V1.AUTHOR_ID = V2.VIEWER_ID AND V1.AUTHOR_ID = V2.AUTHOR_ID ORDER BY V1.AUTHOR_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, STORE,PRICE FROM ( SELECT PRODUCT_ID, 'STORE1' AS STORE,STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION ALL SELECT PRODUCT_ID,'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION ALL SELECT PRODUCT_ID,'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL ) A;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM LIKES L WHERE L.USER_ID IN (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END USER_ID FROM FRIENDSHIP) AND L.PAGE_ID NOT IN(SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT SALARIES.COMPANY_ID, SALARIES.EMPLOYEE_ID, SALARIES.EMPLOYEE_NAME, ROUND( CASE WHEN MAX_SALARY < 1000 THEN SALARY * (1 - 0) WHEN (MAX_SALARY >= 1000) AND (MAX_SALARY <= 10000) THEN SALARY * (1 - 0.24) ELSE SALARY * (1 - 0.49) END ) AS SALARY FROM SALARIES JOIN ( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID ) AS COMPANYSALARIES USING (COMPANY_ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S WHERE S.PRODUCT_ID = (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'S8') AND S.BUYER_ID NOT IN (SELECT DISTINCT SS.BUYER_ID FROM SALES SS, PRODUCT P WHERE P.PRODUCT_NAME = 'IPHONE' AND P.PRODUCT_ID = SS.PRODUCT_ID );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(1)=1)A;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, STORE, PRICE FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) S WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A, (SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVT FROM ACTIVITY GROUP BY PLAYER_ID) TMP WHERE A.PLAYER_ID = TMP.PLAYER_ID AND A.EVENT_DATE = TMP.EVT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM ( SELECT PRODUCT_ID,'STORE1' AS STORE ,STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID,'STORE2' AS STORE ,STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION SELECT PRODUCT_ID,'STORE3' AS STORE ,STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL ) A ORDER BY 1 ,2;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT(V.VIEWER_ID) AS ID FROM VIEWS V GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID) > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P1.PROJECT_ID, ROUND(AVG(E1.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT AS P1 JOIN EMPLOYEE AS E1 ON P1.EMPLOYEE_ID = E1.EMPLOYEE_ID GROUP BY P1.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES JOIN PRODUCT ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE BUYER_ID NOT IN( SELECT BUYER_ID FROM SALES JOIN PRODUCT ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE') AND PRODUCT_NAME = 'S8';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT U.UNIQUE_ID AS UNIQUE_ID, E.NAME FROM EMPLOYEES AS E LEFT JOIN EMPLOYEEUNI AS U ON E.ID=U.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT A.NAME AS CUSTOMERS FROM CUSTOMERS A LEFT OUTER JOIN ORDERS B ON B.CUSTOMERID=A.ID WHERE B.CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C LEFT JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE C.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') AND C.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND C.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM EMPLOYEE AS E LEFT JOIN BONUS AS B ON E.EMPID = B.EMPID WHERE BONUS IS NULL OR BONUS < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT T2.PRODUCT_ID, ROUND(SUM(T2.UNITS*T1.PRICE) / SUM(T2.UNITS), 2) AVERAGE_PRICE FROM PRICES T1 INNER JOIN UNITSSOLD T2 ON T1.PRODUCT_ID = T2.PRODUCT_ID AND T2.PURCHASE_DATE BETWEEN T1.START_DATE AND T1.END_DATE GROUP BY T2.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION/60) >= 0 AND (DURATION/60) < 5 UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION/60) >= 5 AND (DURATION/60) < 10 UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION/60) >= 10 AND (DURATION/60) < 15 UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION/60) >= 15;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE AS ( SELECT USER2_ID AS FRIEND_ID FROM FRIENDSHIP WHERE USER1_ID=1 UNION SELECT USER1_ID AS FRIEND_ID FROM FRIENDSHIP WHERE USER2_ID=1 ) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT FRIEND_ID FROM CTE) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID , 'STORE1 AS STORE', STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID , 'STORE2 AS STORE', STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION SELECT PRODUCT_ID , 'STORE3 AS STORE', STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM ADDRESS A RIGHT JOIN PERSON B ON A.PERSONID = B.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT C.CLASS FROM COURSES AS C GROUP BY C.CLASS HAVING COUNT(C.STUDENT ) >= 5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID AS CUSTOMER_ID, COUNT(VISITS.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID WHERE TRANSACTIONS.VISIT_ID IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH X AS (SELECT P.PRODUCT_ID, P.PRICE , U.UNITS, (P.PRICE*U.UNITS) AS TOTAL_MONEY FROM PRICES AS P JOIN UNITSSOLD AS U ON P.PRODUCT_ID = U.PRODUCT_ID WHERE PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ) SELECT PRODUCT_ID, ROUND(SUM(TOTAL_MONEY)/SUM(UNITS), 2 ) AS AVERAGE_PRICE FROM X GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] (SELECT '[0-5>' AS BIN, SUM(CASE WHEN DURATION/60 < 5 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION ALL (SELECT '[5-10>' AS BIN, SUM(CASE WHEN (DURATION/60 >= 5 AND DURATION/60 < 10) THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION ALL (SELECT '[10-15>' AS BIN, SUM(CASE WHEN (DURATION/60 >= 10 AND DURATION/60 < 15) THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION ALL (SELECT '15 OR MORE' AS BIN, SUM(CASE WHEN DURATION/60 >= 15 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM SALES JOIN PRODUCT USING (PRODUCT_ID) WHERE PRODUCT_NAME ='S8' AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES JOIN PRODUCT USING (PRODUCT_ID) WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL) UNION ( SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL ) UNION ( SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL ) ORDER BY 1,2;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID AS ID , S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID WHERE D.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS C WHERE C.ID NOT IN ( SELECT C.ID FROM CUSTOMERS C JOIN ORDERS O ON C.ID = O.CUSTOMERID GROUP BY C.ID );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, STORE1 AS PRICE, 'STORE1' AS STORE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION ALL SELECT PRODUCT_ID, STORE2 AS PRICE, 'STORE2' AS STORE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION ALL SELECT PRODUCT_ID, STORE3 AS PRICE, 'STORE3' AS STORE FROM PRODUCTS WHERE STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(U.UNITS*P.PRICE)/SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD AS U JOIN PRICES AS P ON U.PRODUCT_ID=P.PRODUCT_ID AND P.START_DATE <= U.PURCHASE_DATE AND U.PURCHASE_DATE <=P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT(P.PRODUCT_ID), P.PRODUCT_NAME FROM PRODUCT P LEFT JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE >= '2019-01-01' AND S.SALE_DATE <= '2019-03-31' AND P.PRODUCT_ID NOT IN (SELECT P.PRODUCT_ID FROM PRODUCT P LEFT JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE < '2019-01-01' OR S.SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE (USER_ID IN (SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID = 1) OR USER_ID IN (SELECT USER1_ID FROM FRIENDSHIP WHERE USER2_ID = 1)) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS GROUP BY CUSTOMERID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.UNIQUE_ID, A.NAME FROM EMPLOYEEUNI E RIGHT JOIN EMPLOYEES A ON E.ID = A.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] WITH C AS (SELECT DISTINCT * FROM COURSES) SELECT CLASS FROM C GROUP BY CLASS HAVING COUNT(STUDENT) >= 5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH CTE AS ( SELECT DISTINCT S.PRODUCT_ID,PRODUCT_NAME FROM PRODUCT P INNER JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID AND S.SALE_DATE >= '2019-01-01' AND S.SALE_DATE<='2019-03-31' ) SELECT C.PRODUCT_ID,PRODUCT_NAME FROM CTE C LEFT JOIN ( SELECT SALES.PRODUCT_ID AS PD FROM SALES WHERE SALES.SALE_DATE < '2019-01-01' OR SALES.SALE_DATE > '2019-03-31' ) AS DT ON C.PRODUCT_ID = DT.PD WHERE DT.PD IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID , NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI E1 ON E.ID = E1.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT T2.ACCOUNT_ID FROM LOGINFO T1 JOIN LOGINFO T2 ON T1.ACCOUNT_ID = T2.ACCOUNT_ID AND T1.IP_ADDRESS <> T2.IP_ADDRESS AND T2.LOGIN >= T1.LOGIN AND T2.LOGIN <= T1.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT C.NAME, C.BONUS FROM ( SELECT NAME,BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID ) AS C WHERE C.BONUS < 1000 OR C.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] WITH CTE AS (SELECT PLAYER_ID,MIN(EVENT_DATE) AS FIRST_LOG FROM ACTIVITY GROUP BY PLAYER_ID) SELECT ROUND(COUNT(DISTINCT CTE.PLAYER_ID)/COUNT(DISTINCT A.PLAYER_ID),2) AS FRACTION FROM ACTIVITY A LEFT JOIN CTE ON A.PLAYER_ID = CTE.PLAYER_ID AND A.EVENT_DATE = CTE.FIRST_LOG + 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT (CASE WHEN F.USER1_ID=1 THEN F.USER2_ID WHEN F.USER2_ID=1 THEN F.USER1_ID ELSE NULL END ) AS USER_ID FROM FRIENDSHIP F) AS A JOIN LIKES L ON A.USER_ID=L.USER_ID AND L.PAGE_ID NOT IN (SELECT L1.PAGE_ID FROM LIKES L1 WHERE L1.USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT(AUTHOR_ID) AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY 1 ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID RECOMMENDED_PAGE FROM LIKES WHERE PAGE_ID IN ( SELECT PAGE_ID FROM LIKES WHERE USER_ID IN ( SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER1_ID FROM FRIENDSHIP WHERE USER2_ID = 1 ) ) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A INNER JOIN LOGINFO B ON A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS <> B.IP_ADDRESS AND ( (A.LOGIN BETWEEN B.LOGIN AND B.LOGOUT) OR (A.LOGOUT BETWEEN B.LOGIN AND B.LOGOUT));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID , S.EMPLOYEE_ID , S.EMPLOYEE_NAME , ROUND(CASE WHEN M_SAL < 1000 THEN S.SALARY WHEN M_SAL BETWEEN 1000 AND 10000 THEN S.SALARY - ((24 / 100) * S.SALARY ) WHEN M_SAL >= 10000 THEN S.SALARY - ((49 / 100) * S.SALARY ) END) SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) AS M_SAL FROM SALARIES GROUP BY COMPANY_ID) A ON A.COMPANY_ID= S.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(S.SALARY*T.TAX, 0) AS SALARY FROM SALARIES S JOIN ( SELECT COMPANY_ID, ( CASE WHEN MAX(SALARY) < 1000 THEN 1 WHEN MAX(SALARY) <= 10000 THEN 0.76 ELSE 0.51 END ) AS TAX FROM SALARIES GROUP BY COMPANY_ID ) T ON S.COMPANY_ID = T.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM, COUNT(*) AS C FROM MYNUMBERS GROUP BY NUM) NN WHERE C = 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS AS V WHERE V.VIEWER_ID = AUTHOR_ID ORDER BY AUTHOR_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] SELECT NAME FROM CUSTOMER WHERE (REFEREE_ID <> 2) OR (REFEREE_ID IS NULL);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] (SELECT '[0-5>' AS BIN, SUM(CASE WHEN DURATION/60 >= 0 AND DURATION/60 < 5 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION (SELECT '[5-10>' AS BIN, SUM(CASE WHEN DURATION/60 >= 5 AND DURATION/60 < 10 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION (SELECT '[10-15>' AS BIN, SUM(CASE WHEN DURATION/60 >= 10 AND DURATION/60 < 15 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS) UNION (SELECT '15 OR MORE' AS BIN, SUM(CASE WHEN DURATION/60 >= 15 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH TA AS (SELECT P.PRODUCT_ID, U.PURCHASE_DATE, PRICE, UNITS FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID WHERE U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) SELECT PRODUCT_ID, ROUND(SUM(PRICE * UNITS)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM TA GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY * (1 - TAX_RATE), 0) SALARY FROM SALARIES S JOIN ( SELECT COMPANY_ID, CASE WHEN MAX_SALARY > 10000 THEN 0.49 WHEN MAX_SALARY >= 1000 THEN 0.24 ELSE 0.0 END TAX_RATE FROM ( SELECT COMPANY_ID, MAX(SALARY) MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID ) S ) T ON S.COMPANY_ID = T.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID AS CUSTOMER_ID , COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A, LOGINFO B WHERE A.ACCOUNT_ID=B.ACCOUNT_ID AND A.IP_ADDRESS!=B.IP_ADDRESS AND A.LOGIN BETWEEN B.LOGIN AND B.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT CUSTOMERS.NAME AS CUSTOMERS FROM CUSTOMERS WHERE CUSTOMERS.ID NOT IN (SELECT ORDERS.CUSTOMERID FROM ORDERS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM ( SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1 ) AS NUM;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE AS (SELECT USER1_ID, USER2_ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER2_ID, USER1_ID FROM FRIENDSHIP WHERE USER2_ID = 1) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT USER2_ID FROM CTE) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EU USING(ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS AS S WHERE S.DEPARTMENT_ID NOT IN (SELECT D.ID FROM DEPARTMENTS AS D);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] WITH A AS (SELECT MIN(EVENT_DATE) AS MIN_DATE, PLAYER_ID FROM ACTIVITY GROUP BY PLAYER_ID) SELECT ROUND(COUNT(A.PLAYER_ID) / (SELECT COUNT(DISTINCT PLAYER_ID) FROM ACTIVITY),2) AS FRACTION FROM A JOIN ACTIVITY ON A.PLAYER_ID = ACTIVITY.PLAYER_ID AND A.MIN_DATE + 1 = ACTIVITY.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE (AREA >= 3000000) OR (POPULATION >= 25000000);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEES EMP LEFT JOIN EMPLOYEEUNI EMP_UNI ON EMP.ID = EMP_UNI.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME CUSTOMERS FROM CUSTOMERS C WHERE C.ID NOT IN(SELECT CUSTOMERID FROM ORDERS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(A.X - B.X)) AS SHORTEST FROM POINT A JOIN POINT B ON A.X != B.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH ABNOTC AS (SELECT CUSTOMER_ID, SUM(CASE WHEN PRODUCT_NAME='A' THEN 1 ELSE 0 END) AS PA, SUM(CASE WHEN PRODUCT_NAME='B' THEN 1 ELSE 0 END) AS PB, SUM(CASE WHEN PRODUCT_NAME='C' THEN 1 ELSE 0 END) AS PC FROM ORDERS GROUP BY CUSTOMER_ID) SELECT DISTINCT C.* FROM CUSTOMERS AS C JOIN ABNOTC AS O ON C.CUSTOMER_ID=O.CUSTOMER_ID WHERE PA>0 AND PB>0 AND PC=0 ORDER BY C.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH FIRSTLOGGED AS (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_DATE FROM ACTIVITY GROUP BY PLAYER_ID) SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A INNER JOIN FIRSTLOGGED F ON (A.PLAYER_ID = F.PLAYER_ID AND A.EVENT_DATE = F.FIRST_DATE);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT EMAIL FROM PERSON WHERE EMAIL IN (SELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM FRIENDSHIP AS F INNER JOIN LIKES AS L ON (L.USER_ID = F.USER2_ID AND F.USER1_ID = 1) OR (L.USER_ID = F.USER1_ID AND F.USER2_ID = 1) WHERE L.PAGE_ID NOT IN (SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(SUM(CASE WHEN TEMP.MIN_DATE+1 = A.EVENT_DATE THEN 1 ELSE 0 END)/COUNT(DISTINCT TEMP.PLAYER_ID),2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY A ON TEMP.PLAYER_ID=A.PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN (SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH CTE1 AS ( SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') ) SELECT * FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT * FROM CTE1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH TAX_RATE AS ( SELECT COMPANY_ID, CASE WHEN MAX(SALARY)>10000 THEN (1-.49) WHEN MAX(SALARY)>=1000 AND MAX(SALARY)<=10000 THEN (1-.24) WHEN MAX(SALARY)<1000 THEN 1 END AS TAXRATE FROM SALARIES GROUP BY COMPANY_ID ORDER BY COMPANY_ID ) SELECT S.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY*TAXRATE,0) AS SALARY FROM SALARIES S JOIN TAX_RATE T ON S.COMPANY_ID=T.COMPANY_ID ORDER BY S.COMPANY_ID, EMPLOYEE_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A JOIN LOGINFO B ON B.ACCOUNT_ID = A.ACCOUNT_ID WHERE A.IP_ADDRESS != B.IP_ADDRESS AND A.ACCOUNT_ID = B.ACCOUNT_ID AND (A.LOGIN BETWEEN B.LOGIN AND B.LOGOUT OR A.LOGOUT BETWEEN B.LOGIN AND B.LOGOUT);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM (SELECT EMAIL, COUNT(EMAIL) FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1) AS P;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM ( SELECT VIEWER_ID , VIEW_DATE FROM VIEWS GROUP BY VIEWER_ID , VIEW_DATE HAVING COUNT( DISTINCT ARTICLE_ID) > 1) AS T ORDER BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES AS E1 LEFT JOIN EMPLOYEEUNI AS E2 USING(ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT A.NAME , B.BONUS FROM EMPLOYEE AS A LEFT JOIN BONUS AS B ON A.EMPID = B.EMPID WHERE B.BONUS IS NULL OR B.BONUS < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT USER2_ID FROM (SELECT USER1_ID, USER2_ID FROM FRIENDSHIP UNION SELECT USER2_ID AS USER1_ID, USER1_ID AS USER2_ID FROM FRIENDSHIP) TEMP WHERE USER1_ID = 1) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON T.VISIT_ID = V.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, STORE, PRICE FROM ( SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS AS P1 UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS AS P2 UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS AS P3) AS SUB WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COALESCE(COUNT(DISTINCT SESSION_ID), 0) AS TOTAL FROM SESSIONS WHERE DURATION/60 < 5 UNION SELECT '[5-10>' AS BIN, COALESCE(COUNT(DISTINCT SESSION_ID), 0) AS TOTAL FROM SESSIONS WHERE DURATION/60 BETWEEN 5 AND 10 UNION SELECT '[10-15>' AS BIN, COALESCE(COUNT(DISTINCT SESSION_ID), 0) AS TOTAL FROM SESSIONS WHERE DURATION/60 BETWEEN 10 AND 15 UNION SELECT '15 OR MORE' AS BIN, COALESCE(COUNT(DISTINCT SESSION_ID), 0) AS TOTAL FROM SESSIONS WHERE DURATION/60 >= 15;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(A.X-B.X)) SHORTEST FROM POINT A, POINT B WHERE A.X != B.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(SALARY*(1-TAXRATE),0) AS SALARY FROM SALARIES S JOIN (SELECT COMPANY_ID, (CASE WHEN MAX(SALARY)<1000 THEN 0 WHEN MAX(SALARY)<=10000 THEN 0.24 WHEN MAX(SALARY)>10000 THEN 0.49 END) AS TAXRATE FROM SALARIES GROUP BY COMPANY_ID) T ON S.COMPANY_ID = T.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(PRICE * UNITS) / SUM(UNITS), 2) AS AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A INNER JOIN LOGINFO B ON A.ACCOUNT_ID=B.ACCOUNT_ID AND A.IP_ADDRESS<>B.IP_ADDRESS AND ((A.LOGIN BETWEEN B.LOGIN AND B.LOGOUT) OR (B.LOGIN BETWEEN A.LOGIN AND A.LOGOUT));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE AS( SELECT USER1_ID, USER2_ID FROM FRIENDSHIP UNION ALL SELECT USER2_ID, USER1_ID FROM FRIENDSHIP), CTE2 AS( SELECT USER1_ID, USER2_ID FROM CTE WHERE USER1_ID = 1) SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM CTE2 C JOIN LIKES L ON L.USER_ID = C.USER2_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID AND O.PRODUCT_NAME = 'A' JOIN ORDERS O2 ON C.CUSTOMER_ID = O2.CUSTOMER_ID AND O2.PRODUCT_NAME = 'B' LEFT JOIN ORDERS O3 ON C.CUSTOMER_ID = O3.CUSTOMER_ID AND O3.PRODUCT_NAME = 'C' WHERE O3.CUSTOMER_ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE)>=CAST('2019-01-01' AS DATE) AND MAX(SALE_DATE)<=CAST('2019-03-31' AS DATE) );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(CASE WHEN DURATION>=0 AND DURATION <300 THEN 1 END) AS TOTAL FROM SESSIONS UNION SELECT '[5-10>' AS BIN, COUNT(CASE WHEN DURATION>=301 AND DURATION <600 THEN 1 END) AS TOTAL FROM SESSIONS UNION SELECT '[10-15>' AS BIN, COUNT(CASE WHEN DURATION>=601 AND DURATION <900 THEN 1 END) AS TOTAL FROM SESSIONS UNION SELECT '15 OR MORE' AS BIN, COUNT(CASE WHEN DURATION>=901 THEN 1 END) AS TOTAL FROM SESSIONS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE AS (SELECT USER2_ID AS USER_ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER1_ID AS USER_ID FROM FRIENDSHIP WHERE USER2_ID = 1) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT USER_ID FROM CTE) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES P INNER JOIN UNITSSOLD U ON P.PRODUCT_ID=U.PRODUCT_ID AND (U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A LEFT JOIN ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID )AB ON A.PLAYER_ID = AB.PLAYER_ID WHERE A.EVENT_DATE = AB.MIN_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT US.PRODUCT_ID, ROUND(SUM(US.UNITS * P.PRICE) / SUM(US.UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD US INNER JOIN PRICES P ON US.PRODUCT_ID = P.PRODUCT_ID AND US.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY US.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT DATE_ID , MAKE_NAME , COUNT(DISTINCT(LEAD_ID)) AS UNIQUE_LEADS, COUNT(DISTINCT(PARTNER_ID)) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT SUMMARY.CUSTOMER_ID, CUSTOMERS.CUSTOMER_NAME FROM ( SELECT CUSTOMER_ID, SUM(CASE WHEN PRODUCT_NAME = 'A' THEN 1 ELSE 0 END) AS A, SUM(CASE WHEN PRODUCT_NAME = 'B' THEN 1 ELSE 0 END) AS B, SUM(CASE WHEN PRODUCT_NAME = 'C' THEN 1 ELSE 0 END) AS C FROM ORDERS GROUP BY CUSTOMER_ID ) SUMMARY JOIN CUSTOMERS ON SUMMARY.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID WHERE A > 0 AND B > 0 AND C = 0;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME , CASE WHEN A.MAX_SALARY < 1000 THEN SALARY WHEN A.MAX_SALARY>= 1000 AND A.MAX_SALARY <=10000 THEN ROUND(SALARY*(1-0.24), 0) ELSE ROUND(SALARY*(1-0.49),0) END AS SALARY FROM( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID) AS A JOIN SALARIES AS S ON A.COMPANY_ID = S.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] WITH TEMP AS ( SELECT E.EMPID, E.NAME, B.BONUS FROM EMPLOYEE AS E LEFT JOIN BONUS AS B USING (EMPID) ) SELECT TEMP.NAME, TEMP.BONUS FROM TEMP WHERE TEMP.EMPID NOT IN (SELECT TEMP.EMPID FROM TEMP WHERE TEMP.BONUS >= 1000);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT B.PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT USER2_ID AS UID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER1_ID AS UID FROM FRIENDSHIP WHERE USER2_ID = 1) A, LIKES B WHERE A.UID = B.USER_ID AND B.PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AS AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID WHERE PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT COALESCE(EU.UNIQUE_ID) AS UNIQUE_ID , E.NAME AS NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EU ON E.ID=EU.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS != L2.IP_ADDRESS WHERE NOT (L1.LOGIN > L2.LOGOUT OR L1.LOGOUT < L2.LOGIN);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN(SELECT D.ID FROM DEPARTMENTS D);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID , DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID , DIRECTOR_ID HAVING COUNT(1) >= 3;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(VISIT_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT V.VISIT_ID FROM VISITS AS V INNER JOIN TRANSACTIONS USING (VISIT_ID) ) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] WITH CTE AS( SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS AS P1 UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS AS P2 UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS AS P1 ) SELECT PRODUCT_ID,STORE, PRICE FROM CTE WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(DISTINCT B.PLAYER_ID)/COUNT(DISTINCT A.PLAYER_ID),2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A LEFT JOIN ACTIVITY B ON A.PLAYER_ID=B.PLAYER_ID AND B.EVENT_DATE-A.FIRST_LOGIN=1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT(T1.ACCOUNT_ID) FROM LOGINFO T1 LEFT JOIN LOGINFO T2 ON T1.ACCOUNT_ID = T2.ACCOUNT_ID WHERE ((T2.LOGIN BETWEEN T1.LOGIN AND T1.LOGOUT) OR (T2.LOGOUT BETWEEN T1.LOGIN AND T1.LOGOUT)) AND (T1.IP_ADDRESS != T2.IP_ADDRESS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A INNER JOIN (SELECT PLAYER_ID , MIN(EVENT_DATE) EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) B ON A.EVENT_DATE = B.EVENT_DATE AND A.PLAYER_ID = B.PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES L JOIN (SELECT USER1_ID FRIENDS FROM FRIENDSHIP WHERE USER2_ID = 1 UNION ALL SELECT USER2_ID FRIENDS FROM FRIENDSHIP WHERE USER1_ID = 1) F ON L.USER_ID = F.FRIENDS WHERE PAGE_ID NOT IN (SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TCTE AS ( SELECT P.PRODUCT_NAME, S.BUYER_ID FROM SALES S JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME IN ('S8','IPHONE') ) SELECT DISTINCT BUYER_ID FROM TCTE WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM TCTE WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT TB1.PAGE_ID AS RECOMMENDED_PAGE FROM ( SELECT USER1_ID AS ID,PAGE_ID FROM FRIENDSHIP INNER JOIN LIKES ON USER2_ID=USER_ID WHERE USER1_ID=1 UNION SELECT USER2_ID AS ID, PAGE_ID FROM FRIENDSHIP INNER JOIN LIKES ON USER1_ID=USER_ID WHERE USER2_ID=1 ) TB1 WHERE TB1.PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID =1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] SELECT CUSTOMER.NAME FROM CUSTOMER WHERE CUSTOMER.REFEREE_ID <> 2 OR CUSTOMER.REFEREE_ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND(SUM(E.EXPERIENCE_YEARS)/COUNT(DISTINCT P.EMPLOYEE_ID),2) AS AVERAGE_YEARS FROM PROJECT P LEFT JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT A LEFT JOIN EMPLOYEE B ON A.EMPLOYEE_ID=B.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND( SUM(U.UNITS * P.PRICE) / SUM(U.UNITS) , 2) AS AVERAGE_PRICE FROM UNITSSOLD U INNER JOIN PRICES P ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT BUYER_ID, PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' OR PRODUCT_NAME = 'IPHONE' ) SELECT DISTINCT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND((SUM(U.UNITS*P.PRICE) / SUM(U.UNITS)), 2) AS AVERAGE_PRICE FROM UNITSSOLD U JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE >= P.START_DATE AND U.PURCHASE_DATE <= P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY AS A, (SELECT PLAYER_ID, MIN(EVENT_DATE) AS EARLIEST_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS B WHERE A.PLAYER_ID = B.PLAYER_ID AND A.EVENT_DATE = B.EARLIEST_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EMP_UNI.UNIQUE_ID, EMP.NAME FROM EMPLOYEEUNI EMP_UNI RIGHT JOIN EMPLOYEES EMP USING(ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] WITH ID_BONUS AS (SELECT A.NAME, B.BONUS FROM EMPLOYEE A LEFT JOIN BONUS B ON A.EMPID = B.EMPID) SELECT NAME, BONUS FROM ID_BONUS WHERE BONUS<1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME, B.BONUS FROM EMPLOYEE AS E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE B.BONUS < 1000 OR B.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 LEFT JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS != L2.IP_ADDRESS AND (L2.LOGIN BETWEEN L1.LOGIN AND L1.LOGOUT) WHERE L2.IP_ADDRESS IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE AS( SELECT DISTINCT USER1_ID AS USER_ID FROM FRIENDSHIP WHERE USER2_ID = 1 UNION ALL SELECT DISTINCT USER2_ID AS USER_ID FROM FRIENDSHIP WHERE USER1_ID = 1) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT USER_ID FROM CTE) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE AS( SELECT COMPANY_ID,MAX(SALARY) AS MX FROM SALARIES GROUP BY COMPANY_ID) SELECT A.COMPANY_ID,EMPLOYEE_ID,EMPLOYEE_NAME, CASE WHEN MX <1000 THEN 1*SALARY WHEN MX<=10000 AND MX>=1000 THEN ROUND(0.76*SALARY,0) WHEN MX>10000 THEN ROUND(0.51*SALARY,0) END AS SALARY FROM SALARIES A LEFT JOIN CTE ON A.COMPANY_ID=CTE.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH T1 AS (SELECT USER2_ID AS ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION ALL SELECT USER1_ID AS ID FROM FRIENDSHIP WHERE USER2_ID = 1) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM T1 A JOIN LIKES B ON A.ID = USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] WITH T1 AS( SELECT '[0-5>' AS BIN, SUM(CASE WHEN DURATION/60>=0 AND DURATION/60 <5 THEN 1 ELSE 0 END) TOTAL FROM SESSIONS ), T2 AS( SELECT '[5-10>' AS BIN, SUM(CASE WHEN DURATION/60>=5 AND DURATION/60 <10 THEN 1 ELSE 0 END) TOTAL FROM SESSIONS ), T3 AS( SELECT '[10-15>' AS BIN, SUM(CASE WHEN DURATION/60>=10 AND DURATION/60 <15 THEN 1 ELSE 0 END) TOTAL FROM SESSIONS ), T4 AS( SELECT '15 OR MORE' AS BIN, SUM(CASE WHEN DURATION/60>=15 THEN 1 ELSE 0 END) TOTAL FROM SESSIONS ) SELECT * FROM (SELECT * FROM T1)A UNION (SELECT * FROM T2) UNION (SELECT * FROM T3) UNION (SELECT * FROM T4);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TMP AS( SELECT BUYER_ID FROM SALES WHERE PRODUCT_ID = ( SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'S8') ) SELECT DISTINCT BUYER_ID FROM TMP WHERE BUYER_ID NOT IN ( SELECT DISTINCT BUYER_ID FROM SALES WHERE PRODUCT_ID = ( SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'IPHONE') );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT DISTINCT(DATE_ID), MAKE_NAME, COUNT(DISTINCT(LEAD_ID)) AS UNIQUE_LEADS , COUNT(DISTINCT(PARTNER_ID)) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME ORDER BY 1, 2;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT(O.CUSTOMER_ID),C.CUSTOMER_NAME FROM CUSTOMERS AS C INNER JOIN ORDERS AS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE O.CUSTOMER_ID IN (SELECT DISTINCT(O1.CUSTOMER_ID) FROM ORDERS AS O1 INNER JOIN ORDERS AS O2 ON O1.CUSTOMER_ID = O2.CUSTOMER_ID WHERE O1.PRODUCT_NAME = 'A' AND O2.PRODUCT_NAME = 'B') AND O.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT P LEFT JOIN EMPLOYEE E USING(EMPLOYEE_ID) GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN( SELECT DISTINCT(CUSTOMER_ID) FROM ORDERS WHERE CUSTOMER_ID IN(SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN(SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN(SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C'));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS!= L2.IP_ADDRESS WHERE L2.LOGIN<=L1.LOGOUT AND L2.LOGOUT>=L1.LOGIN;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID,MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID;\n[SQL_2] SELECT A.PLAYER_ID, MIN(A.EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY A GROUP BY PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT(POST_ID)) AS REPORT_COUNT FROM (SELECT * FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04') T GROUP BY EXTRA;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT(AUTHOR_ID) AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY AUTHOR_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON T1 LEFT JOIN ADDRESS T2 ON T1.PERSONID = T2.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT DISTINCT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT U.UNIQUE_ID , NAME FROM EMPLOYEES AS E LEFT JOIN EMPLOYEEUNI AS U ON E.ID = U.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, EMP.NAME FROM EMPLOYEES EMP LEFT JOIN EMPLOYEEUNI UNI ON UNI.ID = EMP.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] SELECT NAME FROM CUSTOMER WHERE ID NOT IN ( SELECT ID FROM CUSTOMER WHERE REFEREE_ID = 2 );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH C AS (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='C'), A AS (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='A'), B AS (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME='B') SELECT DISTINCT CUSTOMERS.CUSTOMER_ID, CUSTOMER_NAME FROM ORDERS JOIN CUSTOMERS ON CUSTOMERS.CUSTOMER_ID=ORDERS.CUSTOMER_ID WHERE CUSTOMERS.CUSTOMER_ID NOT IN (SELECT * FROM C) AND CUSTOMERS.CUSTOMER_ID IN (SELECT * FROM A) AND CUSTOMERS.CUSTOMER_ID IN (SELECT * FROM B) ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT DISTINCT P.PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT PERSON.FIRSTNAME, PERSON.LASTNAME, ADDRESS.CITY, ADDRESS.STATE FROM ADDRESS RIGHT JOIN PERSON ON PERSON.PERSONID = ADDRESS.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT DS.DATE_ID, DS.MAKE_NAME, COUNT(DISTINCT(DS.LEAD_ID)) AS UNIQUE_LEADS , COUNT(DISTINCT(DS.PARTNER_ID)) AS UNIQUE_PARTNERS FROM DAILYSALES AS DS GROUP BY DS.DATE_ID, DS.MAKE_NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH FINAL AS ( SELECT P.PRODUCT_ID,P.PRODUCT_NAME,S.BUYER_ID FROM PRODUCT P INNER JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM FINAL WHERE PRODUCT_NAME ='S8' AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM FINAL WHERE PRODUCT_NAME ='IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS LEFT JOIN (SELECT CUSTOMER_ID C, SUM(CASE WHEN PRODUCT_NAME = 'A' THEN 1 ELSE 0 END) A, SUM(CASE WHEN PRODUCT_NAME = 'B' THEN 1 ELSE 0 END) B, SUM(CASE WHEN PRODUCT_NAME = 'C' THEN 1 ELSE 0 END) CC FROM ORDERS GROUP BY CUSTOMER_ID) AS T ON CUSTOMERS.CUSTOMER_ID = T.C WHERE A > 0 AND B > 0 AND CC = 0;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND((SUM(U.UNITS*P.PRICE)/SUM(U.UNITS)),2) AS AVERAGE_PRICE FROM UNITSSOLD AS U INNER JOIN PRICES AS P ON U.PRODUCT_ID=P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] WITH CTE AS( SELECT E.ID, NAME, UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EU ON E.ID = EU.ID ) SELECT UNIQUE_ID, NAME FROM CTE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM ORDERS O LEFT OUTER JOIN CUSTOMERS C ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE C.CUSTOMER_ID IN (SELECT A.CUSTOMER_ID FROM ORDERS A WHERE A.PRODUCT_NAME = 'A') AND C.CUSTOMER_ID IN (SELECT B.CUSTOMER_ID FROM ORDERS B WHERE B.PRODUCT_NAME = 'B') AND C.CUSTOMER_ID NOT IN (SELECT C.CUSTOMER_ID FROM ORDERS C WHERE C.PRODUCT_NAME = 'C') ORDER BY 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT P.FIRSTNAME AS FIRSTNAME, P.LASTNAME AS LASTNAME, A.CITY AS CITY, A.STATE AS STATE FROM PERSON AS P LEFT JOIN ADDRESS AS A ON P.PERSONID =A.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A INNER JOIN (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MINDATE FROM ACTIVITY GROUP BY PLAYER_ID) B ON A.PLAYER_ID = B.PLAYER_ID AND A.EVENT_DATE = B.MINDATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM ( SELECT EMAIL, COUNT(EMAIL) AS CNT FROM PERSON GROUP BY EMAIL) AS TEMP WHERE TEMP.CNT > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM ( SELECT CLASS, COUNT(DISTINCT(STUDENT)) AS CLASS_COUNT FROM COURSES GROUP BY CLASS ) AS S WHERE CLASS_COUNT >= 5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(U.UNITS * P.PRICE) / SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON P.PRODUCT_ID = U.PRODUCT_ID WHERE U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E1.UNIQUE_ID,E.NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI E1 ON E.ID = E1.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM ( SELECT T.PID, T.TIV_2015, T.TIV_2016, T.LAT, T.LON, T1.TIV_2015_COUNT, T2.CITY_COUNT FROM INSURANCE T LEFT JOIN( SELECT TIV_2015, COUNT(*) AS TIV_2015_COUNT FROM INSURANCE GROUP BY TIV_2015 )T1 ON T.TIV_2015=T1.TIV_2015 LEFT JOIN ( SELECT LAT, LON, COUNT(*) AS CITY_COUNT FROM INSURANCE GROUP BY LAT, LON )T2 ON T.LAT = T2.LAT AND T.LON = T2.LON WHERE T1.TIV_2015_COUNT > 1 AND T2.CITY_COUNT = 1 )FT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(A2.PLAYER_ID) / COUNT(A1.PLAYER_ID), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) A1 LEFT JOIN ACTIVITY A2 ON A1.PLAYER_ID = A2.PLAYER_ID AND A1.EVENT_DATE + 1 = A2.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT T.NAME CUSTOMERS FROM CUSTOMERS T WHERE T.ID NOT IN ( SELECT C.ID FROM CUSTOMERS C,ORDERS O WHERE C.ID = O.CUSTOMERID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME NAME, B.BONUS BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE B.BONUS IS NULL OR B.BONUS < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P. PROJECT_ID,ROUND(AVG(EXPERIENCE_YEARS),2) AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH DRAFT AS ( SELECT S.BUYER_ID, S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES AS S INNER JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM DRAFT WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM DRAFT WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS V1 GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID) > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT A.PRODUCT_ID , ROUND(SUM(A.PRICE * B.UNITS) / SUM(B.UNITS),2) AS AVERAGE_PRICE FROM PRICES A INNER JOIN UNITSSOLD B ON A.PRODUCT_ID = B.PRODUCT_ID AND A.START_DATE <= B.PURCHASE_DATE AND B.PURCHASE_DATE <= A.END_DATE GROUP BY A.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(S.BUYER_ID) FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND S.BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, STORE, PRICE FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) T1 WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(DISTINCT A.PLAYER_ID)/COUNT(DISTINCT TEMP.PLAYER_ID), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) TEMP LEFT JOIN ACTIVITY A ON A.PLAYER_ID = TEMP.PLAYER_ID AND A.EVENT_DATE = MIN_DATE+1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH FRIENDS AS (SELECT L.PAGE_ID AS FRIEND_LIKED FROM FRIENDSHIP F JOIN LIKES L ON F.USER2_ID = L.USER_ID WHERE F.USER1_ID = 1 UNION SELECT L.PAGE_ID AS FRIEND_LIKED FROM FRIENDSHIP F JOIN LIKES L ON F.USER1_ID = L.USER_ID WHERE F.USER2_ID = 1) SELECT DISTINCT FRIEND_LIKED AS RECOMMENDED_PAGE FROM FRIENDS WHERE FRIEND_LIKED NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(SUM(EXPERIENCE_YEARS) / COUNT(PROJECT.EMPLOYEE_ID),2) AS AVERAGE_YEARS FROM PROJECT INNER JOIN EMPLOYEE ON PROJECT.EMPLOYEE_ID = EMPLOYEE.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM (SELECT EMAIL, COUNT(EMAIL) AS COUNTEMAIL FROM PERSON GROUP BY EMAIL)C WHERE COUNTEMAIL>1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON PP LEFT JOIN ADDRESS AA ON PP.PERSONID = AA.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(T2.NUM) NUM FROM ( SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING(COUNT(*) = 1) ) T2;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS <>L2.IP_ADDRESS AND L1.LOGIN>=L2.LOGIN AND L1.LOGIN<=L2.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM (SELECT CLASS, COUNT(DISTINCT STUDENT) AS N FROM COURSES GROUP BY CLASS ) AS T WHERE N>=5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH CTE AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID ) SELECT A.PLAYER_ID, DEVICE_ID FROM ACTIVITY A JOIN CTE ON A.PLAYER_ID = CTE.PLAYER_ID AND A.EVENT_DATE = CTE.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT S.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P, SALES S WHERE S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.PRODUCT_ID, P.PRODUCT_NAME HAVING MIN(S.SALE_DATE) >= '2019-01-01' AND MAX(S.SALE_DATE) <= '2019-03-31';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS S WHERE DURATION/60 >=0 AND DURATION/60 < 5 UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS S WHERE DURATION/60 >=5 AND DURATION/60 < 10 UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS S WHERE DURATION/60 >=10 AND DURATION/60 < 15 UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS S WHERE DURATION/60 >=15;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 INNER JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS != L2.IP_ADDRESS WHERE L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT OR L2.LOGIN BETWEEN L1.LOGIN AND L1.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] WITH A AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID ) SELECT ROUND(COUNT(A2.PLAYER_ID) / COUNT(A1.PLAYER_ID), 2) AS FRACTION FROM A A1 LEFT JOIN ACTIVITY A2 ON A1.PLAYER_ID = A2.PLAYER_ID AND A1.FIRST_LOGIN + 1 = A2.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT O1.CUSTOMER_ID, C.CUSTOMER_NAME FROM ORDERS O1 JOIN ORDERS O2 ON O1.CUSTOMER_ID = O2.CUSTOMER_ID LEFT JOIN CUSTOMERS C ON O1.CUSTOMER_ID = C.CUSTOMER_ID WHERE O1.PRODUCT_NAME = 'A' AND O2.PRODUCT_NAME = 'B' AND O1.CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S WHERE S.DEPARTMENT_ID NOT IN (SELECT D.ID FROM DEPARTMENTS D JOIN STUDENTS S ON D. ID= S. DEPARTMENT_ID );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM ( SELECT DISTINCT (CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID END) AS USER_ID FROM FRIENDSHIP) SUB JOIN LIKES L ON (SUB.USER_ID=L.USER_ID) WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION/60 BETWEEN 0 AND 5 UNION SELECT '[5-10>' AS BIN, COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION/60 BETWEEN 5.01 AND 10 UNION SELECT '[10-15>' AS BIN, COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION/60 BETWEEN 10.01 AND 15 UNION SELECT '15 OR MORE' AS BIN, COUNT(*) AS TOTAL FROM SESSIONS WHERE DURATION/60 > 15;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME AS CUSTOMERS FROM CUSTOMERS C WHERE C.ID NOT IN (SELECT DISTINCT(CUSTOMERID) FROM ORDERS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM (SELECT DISTINCT VIEWER_ID, VIEW_DATE, COUNT(DISTINCT ARTICLE_ID) AS NUM_OF_BOOKS FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID) >1) A;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS), 2) AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID=U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH IPHONE AS ( SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE' ) SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM IPHONE);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT A.EMAIL FROM PERSON A, PERSON B WHERE A.EMAIL = B.EMAIL AND A.ID != B.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH T1 AS( SELECT *, UNITS * PRICE AS TOTAL FROM (SELECT U.* , P.START_DATE, P.END_DATE, P.PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID) AS T WHERE PURCHASE_DATE >= START_DATE AND PURCHASE_DATE <= END_DATE) SELECT PRODUCT_ID, ROUND(SUM(TOTAL)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM T1 GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID,MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID;\n[SQL_2] SELECT PLAYER_ID, MIN(EVENT_DATE) FIRST_LOGIN FROM ACTIVITY A GROUP BY PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EU.UNIQUE_ID,NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EU USING(ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, SUM(CASE WHEN DURATION < 300 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS UNION ALL SELECT '[5-10>' AS BIN, SUM(CASE WHEN DURATION >= 5*60 AND DURATION < 10*60 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS UNION ALL SELECT '[10-15>' AS BIN, SUM(CASE WHEN DURATION >= 10*60 AND DURATION < 15*60 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS UNION ALL SELECT '15 OR MORE' AS BIN, SUM(CASE WHEN DURATION >= 15*60 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT DISTINCT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(DISTINCT STUDENT) >=5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID,P.PRODUCT_NAME FROM SALES S, PRODUCT P WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND S.PRODUCT_ID=P.PRODUCT_ID AND S.PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31') ORDER BY PRODUCT_ID DESC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM (SELECT DISTINCT * FROM COURSES) SUB GROUP BY CLASS HAVING COUNT(*) >= 5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT A.NAME AS NAME, B.BONUS AS BONUS FROM EMPLOYEE A LEFT OUTER JOIN BONUS B ON A.EMPID = B.EMPID WHERE B.BONUS < 1000 OR BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM ( SELECT PRODUCT_ID,'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID,'STORE2', STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID,'STORE3', STORE3 AS PRICE FROM PRODUCTS) T WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNI.UNIQUE_ID AS UNIQUE_ID, E.NAME AS NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI UNI ON E.ID = UNI.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS LEFT JOIN ( SELECT CUSTOMERID, COUNT(*) AS NUM_ORDERS FROM ORDERS GROUP BY CUSTOMERID ) ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMERID WHERE ORDERS.NUM_ORDERS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] SELECT INSTALL_DT, COUNT(DISTINCT A.PLAYER_ID) AS INSTALLS, ROUND(SUM(CASE WHEN EVENT_DATE=INSTALL_DT+1 THEN 1 ELSE 0 END)/COUNT(DISTINCT A.PLAYER_ID),2) AS DAY1_RETENTION FROM ACTIVITY A LEFT JOIN (SELECT PLAYER_ID, MIN(EVENT_DATE) AS INSTALL_DT FROM ACTIVITY GROUP BY PLAYER_ID) I ON A.PLAYER_ID=I.PLAYER_ID GROUP BY INSTALL_DT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] WITH CTE AS (SELECT * FROM LOGINFO WHERE LOGOUT > LOGIN) SELECT DISTINCT A.ACCOUNT_ID FROM CTE A LEFT JOIN CTE B ON A.ACCOUNT_ID = B.ACCOUNT_ID AND A.IP_ADDRESS != B.IP_ADDRESS WHERE A.LOGIN BETWEEN B.LOGIN AND B.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM)=1)D;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM ( SELECT CLASS, COUNT(DISTINCT STUDENT) AS NUM FROM COURSES GROUP BY CLASS ) AS TEMP_TABLE WHERE NUM >= 5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL ORDER BY PRODUCT_ID, STORE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT(VIEWER_ID) AS ID FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID)>1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] WITH TAB AS (SELECT PRODUCT_ID, 'STORE1' AS STORE ,STORE1 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE,STORE2 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE,STORE3 AS PRICE FROM PRODUCTS ) SELECT* FROM TAB WHERE PRICE IS NOT NULL ORDER BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT LOOKUP.PLAYER_ID, AC.DEVICE_ID FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) LOOKUP JOIN ACTIVITY AC ON LOOKUP.PLAYER_ID = AC.PLAYER_ID AND LOOKUP.EVENT_DATE = AC.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(CASE WHEN (DURATION/60) >= 0 AND (DURATION/60) < 5 THEN SESSION_ID END) AS TOTAL FROM SESSIONS S UNION ALL SELECT '[5-10>' AS BIN, COUNT(CASE WHEN (DURATION/60) >= 5 AND (DURATION/60) < 10 THEN SESSION_ID END) AS TOTAL FROM SESSIONS S UNION ALL SELECT '[10-15>' AS BIN, COUNT(CASE WHEN (DURATION/60) >= 10 AND (DURATION/60) < 15 THEN SESSION_ID END) AS TOTAL FROM SESSIONS S UNION ALL SELECT '15 OR MORE' AS BIN, COUNT(CASE WHEN (DURATION/60) >= 15 THEN SESSION_ID END) AS TOTAL FROM SESSIONS S;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEEUNI RIGHT JOIN EMPLOYEES USING (ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM ( SELECT VIEWER_ID, VIEW_DATE, COUNT(DISTINCT ARTICLE_ID) AS ARTICLES_VIEWED FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE ) AS T WHERE ARTICLES_VIEWED > 1 ORDER BY VIEWER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT PRODUCT_ID, PRODUCT_NAME FROM ( SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID=S.PRODUCT_ID WHERE S.SALE_DATE >='2019-01-01' AND S.SALE_DATE <= '2019-03-31' ) S WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE<'2019-01-01' OR SALE_DATE>'2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH B AS (SELECT PLAYER_ID, MIN(EVENT_DATE) AS DATE_MIN FROM ACTIVITY GROUP BY PLAYER_ID) SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID,EVENT_DATE) IN (SELECT * FROM B);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN MAX_SALARY < 1000 THEN S.SALARY WHEN MAX_SALARY >= 1000 AND MAX_SALARY <= 10000 THEN S.SALARY*0.76 WHEN MAX_SALARY > 10000 THEN S.SALARY*0.51 END, 0) AS SALARY FROM SALARIES S LEFT JOIN (SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID) M ON S.COMPANY_ID = M.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM ( SELECT VIEWER_ID,COUNT(DISTINCT ARTICLE_ID) AS NUM FROM VIEWS GROUP BY VIEWER_ID,VIEW_DATE ) N WHERE NUM > 1 ORDER BY ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A JOIN LOGINFO B USING (ACCOUNT_ID) WHERE A.IP_ADDRESS != B.IP_ADDRESS AND (A.LOGIN BETWEEN B.LOGIN AND B.LOGOUT);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EU.UNIQUE_ID, E.NAME FROM EMPLOYEES AS E LEFT JOIN EMPLOYEEUNI AS EU ON E.ID = EU.ID ORDER BY E.NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(A.NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*) = 1) A;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT B.UNIQUE_ID AS UNIQUE_ID , A.NAME AS NAME FROM EMPLOYEES A LEFT OUTER JOIN EMPLOYEEUNI B ON A.ID = B.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT TEMP.* FROM ( (SELECT P.PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS P) UNION ALL (SELECT P.PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS P ) UNION ALL (SELECT P.PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS P ) ) TEMP WHERE TEMP.PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID,NAME FROM EMPLOYEES AS E LEFT JOIN EMPLOYEEUNI AS UE ON E.ID = UE.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT DISTINCT S.ID, S.NAME FROM STUDENTS S WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID,NAME FROM STUDENTS S WHERE ID NOT IN ( SELECT S.ID AS ID FROM STUDENTS S JOIN DEPARTMENTS D ON S.DEPARTMENT_ID=D.ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE (PRODUCT_NAME = 'A')) AND CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE (PRODUCT_NAME = 'B')) AND CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE (PRODUCT_NAME = 'C')) ORDER BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A JOIN LOGINFO B ON A.ACCOUNT_ID = B.ACCOUNT_ID AND A.LOGIN BETWEEN B.LOGIN AND B.LOGOUT AND A.IP_ADDRESS != B.IP_ADDRESS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS C WHERE C.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND C.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND C.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT T1.NAME AS CUSTOMERS FROM CUSTOMERS AS T1 LEFT JOIN ORDERS AS T2 ON T1.ID = T2.CUSTOMERID WHERE T2.CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] SELECT NAME FROM CUSTOMER WHERE (REFEREE_ID != 2 OR REFEREE_ID IS NULL);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS(SELECT BUYER_ID, A.PRODUCT_ID, PRODUCT_NAME FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID=B.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM CTE WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME='IPHONE') AND PRODUCT_NAME='S8';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT C.NAME AS CUSTOMERS FROM CUSTOMERS C LEFT JOIN ORDERS O ON C.ID = O.CUSTOMERID WHERE C.ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP_TABLE AS ( SELECT P.PRODUCT_NAME, S.BUYER_ID FROM PRODUCT AS P INNER JOIN SALES AS S ON P.PRODUCT_ID = S.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM TEMP_TABLE WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM TEMP_TABLE WHERE PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A JOIN LOGINFO B ON A.ACCOUNT_ID = B.ACCOUNT_ID WHERE A.IP_ADDRESS != B.IP_ADDRESS AND A.LOGIN BETWEEN (B.LOGIN) AND (B.LOGOUT);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME, B.BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON B.EMPID = E.EMPID WHERE B.BONUS IS NULL OR B.BONUS < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] WITH DISTINCT_NUMS AS (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*) = 1) SELECT MAX(NUM) AS NUM FROM DISTINCT_NUMS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] SELECT INSTALL_DT, INSTALLS, ROUND(SUM(CASE WHEN TEMP2.EVENT_DATE IS NOT NULL THEN 1 ELSE 0 END) / INSTALLS, 2) AS DAY1_RETENTION FROM ( SELECT INSTALL_DT, COUNT(DISTINCT PLAYER_ID ) AS INSTALLS FROM ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS INSTALL_DT FROM ACTIVITY GROUP BY PLAYER_ID )TEMP GROUP BY INSTALL_DT )TEMP1 LEFT JOIN ( SELECT A.EVENT_DATE AS EVENT_DATE FROM ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID )A JOIN ACTIVITY B ON A.PLAYER_ID = B.PLAYER_ID AND A.EVENT_DATE + 1 = B.EVENT_DATE )TEMP2 ON TEMP1.INSTALL_DT = TEMP2.EVENT_DATE GROUP BY INSTALL_DT, INSTALLS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT P INNER JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT B.NAME AS CUSTOMERS FROM ORDERS AS A RIGHT JOIN CUSTOMERS AS B ON A.CUSTOMERID=B.ID WHERE A.CUSTOMERID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) TOTAL FROM SESSIONS WHERE DURATION/60<5 UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) TOTAL FROM SESSIONS WHERE DURATION/60>=5 AND DURATION/60<10 UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) TOTAL FROM SESSIONS WHERE DURATION/60<15 AND DURATION/60>=10 UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) TOTAL FROM SESSIONS WHERE DURATION/60>=15;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON (S.PRODUCT_ID = P.PRODUCT_ID) WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID AND PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT Y.CUSTOMER_ID,CUSTOMER_NAME FROM CUSTOMERS C JOIN ( SELECT CUSTOMER_ID FROM (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A' AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B'))X WHERE CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C'))Y ON C.CUSTOMER_ID=Y.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH SPRING AS( SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' ) SELECT S.PRODUCT_ID,S.PRODUCT_NAME FROM SPRING S LEFT JOIN (SELECT * FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31')A ON S.PRODUCT_ID = A.PRODUCT_ID WHERE A.PRODUCT_ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH COMBINED AS ( SELECT USER1_ID, USER2_ID FROM FRIENDSHIP UNION ALL SELECT USER2_ID, USER1_ID FROM FRIENDSHIP), FRIENDS AS ( SELECT USER2_ID FROM COMBINED WHERE USER1_ID = 1) SELECT DISTINCT(PAGE_ID) AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT USER2_ID FROM FRIENDS) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES P INNER JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS) / SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM PRICES P INNER JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID , A.DEVICE_ID FROM ACTIVITY A INNER JOIN (SELECT PLAYER_ID , MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID) B ON A.PLAYER_ID = B.PLAYER_ID AND A.EVENT_DATE = B.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT S.PRODUCT_ID, S.BUYER_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM CTE WHERE BUYER_ID NOT IN ( SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE') AND PRODUCT_NAME = 'S8';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT A.FIRSTNAME AS FIRSTNAME, A.LASTNAME AS LASTNAME, B.CITY AS CITY, B.STATE AS STATE FROM PERSON AS A LEFT JOIN ADDRESS AS B ON A.PERSONID = B.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH FRIENDS AS (SELECT (CASE WHEN USER1_ID = 1 THEN USER2_ID WHEN USER2_ID = 1 THEN USER1_ID END) AS USERS FROM FRIENDSHIP) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT USERS FROM FRIENDS WHERE USERS IS NOT NULL) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJ.PROJECT_ID, ROUND(AVG(EMP.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT PROJ JOIN EMPLOYEE EMP ON PROJ.EMPLOYEE_ID = EMP.EMPLOYEE_ID GROUP BY PROJ.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P, SALES S WHERE P.PRODUCT_ID = S.PRODUCT_ID GROUP BY P.PRODUCT_ID, P.PRODUCT_NAME HAVING MIN(S.SALE_DATE) >= '2019-1-1' AND MAX(S.SALE_DATE) <= '2019-3-31';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM STUDENTS WHERE ID NOT IN( SELECT B.ID FROM DEPARTMENTS AS A JOIN STUDENTS AS B ON A.ID=B.DEPARTMENT_ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS) * 1.00,2) AVERAGE_YEARS FROM (SELECT T1.PROJECT_ID, T1.EMPLOYEE_ID, T2.EXPERIENCE_YEARS FROM PROJECT T1 LEFT JOIN EMPLOYEE T2 ON T1.EMPLOYEE_ID = T2.EMPLOYEE_ID) PP GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , COUNT(VISIT_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT(VISIT_ID) FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EU.UNIQUE_ID UNIQUE_ID, E.NAME NAME FROM EMPLOYEES AS E LEFT JOIN EMPLOYEEUNI AS EU ON E.ID = EU.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1) AND PAGE_ID IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID IN ( (SELECT USER1_ID AS ID FROM FRIENDSHIP WHERE USER2_ID = 1) UNION (SELECT USER2_ID AS ID FROM FRIENDSHIP WHERE USER1_ID = 1) ));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID AS ID,S.NAME AS NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID WHERE D.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(UNITS*PRICE) / SUM(UNITS),2) AS AVERAGE_PRICE FROM PRICES P INNER JOIN UNITSSOLD U ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(US.UNITS * P.PRICE) / SUM(US.UNITS), 2) AS AVERAGE_PRICE FROM PRICES AS P JOIN UNITSSOLD AS US ON P.PRODUCT_ID = US.PRODUCT_ID AND US.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN SALES S ON P.PRODUCT_ID=S.PRODUCT_ID WHERE SALE_DATE BETWEEN '2019-01-01' AND '2019-03-31' AND S.PRODUCT_ID NOT IN (SELECT DISTINCT(PRODUCT_ID) FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID WHERE D.ID IS NULL GROUP BY S.ID, S.NAME;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1, LOGINFO L2 WHERE L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT AND L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS != L2.IP_ADDRESS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT STG2.NUM FROM ((SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(*)=1 ) UNION ALL (SELECT NULL AS NUM FROM MYNUMBERS LIMIT 1) ) STG2 ORDER BY STG2.NUM DESC LIMIT 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT T1.ACCOUNT_ID FROM LOGINFO T1 JOIN LOGINFO T2 ON T1.ACCOUNT_ID = T2.ACCOUNT_ID AND T1.IP_ADDRESS != T2.IP_ADDRESS WHERE NOT (T2.LOGOUT < T1.LOGIN OR T1.LOGOUT < T2.LOGIN);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CET AS (SELECT USER2_ID AS ID FROM FRIENDSHIP WHERE USER1_ID=1 UNION SELECT USER1_ID AS ID FROM FRIENDSHIP WHERE USER2_ID=1 ) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES L JOIN CET ON L.USER_ID=CET.ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1) ORDER BY PAGE_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT(AUTHOR_ID) AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY AUTHOR_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH CTE1 AS ( SELECT USER2_ID AS FRIEND_ID FROM FRIENDSHIP WHERE USER1_ID = 1 UNION SELECT USER1_ID AS FRIEND_ID FROM FRIENDSHIP WHERE USER2_ID = 1) SELECT DISTINCT PAGE_ID RECOMMENDED_PAGE FROM LIKES WHERE USER_ID IN (SELECT FRIEND_ID FROM CTE1) AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT DISTINCT(CLASS) FROM COURSES GROUP BY CLASS HAVING COUNT(DISTINCT STUDENT) >= 5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable MYNUMBERS, Columns = [ *, NUM ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MAX(NUM) AS NUM FROM (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1) AS T;\n[SQL_2] SELECT MAX(NUM) AS NUM FROM MYNUMBERS WHERE NUM IN (SELECT NUM FROM MYNUMBERS GROUP BY NUM HAVING COUNT(NUM) = 1 );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT.PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT JOIN EMPLOYEE ON PROJECT.EMPLOYEE_ID=EMPLOYEE.EMPLOYEE_ID GROUP BY PROJECT.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT * FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT O.CUSTOMER_ID FROM ORDERS O JOIN ORDERS R ON O.CUSTOMER_ID = R.CUSTOMER_ID WHERE O.PRODUCT_NAME = 'A' AND R.PRODUCT_NAME = 'B' AND O.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C'));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT DISTINCT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY AS A INNER JOIN (SELECT DISTINCT PLAYER_ID, MIN(EVENT_DATE) AS MINDATE FROM ACTIVITY GROUP BY PLAYER_ID) AS A2 ON A.PLAYER_ID=A2.PLAYER_ID AND A.EVENT_DATE=A2.MINDATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH TAX_DATA AS ( SELECT COMPANY_ID, CASE WHEN MAX(SALARY)<1000 THEN 0 WHEN MAX(SALARY) BETWEEN 1000 AND 10000 THEN 0.24 WHEN MAX(SALARY)>10000 THEN 0.49 END AS TAX_RATE FROM SALARIES GROUP BY COMPANY_ID ) SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(S.SALARY*(1-T.TAX_RATE), 0) AS SALARY FROM SALARIES S JOIN TAX_DATA T USING(COMPANY_ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) > 1 ORDER BY EMAIL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, CASE WHEN STORE1 IS NOT NULL THEN STORE1 END AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID, CASE WHEN STORE2 IS NOT NULL THEN STORE2 END AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION SELECT PRODUCT_ID, CASE WHEN STORE3 IS NOT NULL THEN STORE3 END AS STORE, STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] SELECT NAME FROM CUSTOMER WHERE NOT(REFEREE_ID = 2) OR REFEREE_ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(E.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT P INNER JOIN EMPLOYEE E ON P.EMPLOYEE_ID=E.EMPLOYEE_ID GROUP BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID , ROUND(SUM(E.EXPERIENCE_YEARS)/COUNT(*),2) AS AVERAGE_YEARS FROM PROJECT P LEFT JOIN EMPLOYEE E ON E.EMPLOYEE_ID = P.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT BIN, SUM(TOTAL) AS TOTAL FROM ( SELECT '[0-5>' AS BIN, CASE WHEN DURATION/60 < 5 THEN 1 ELSE 0 END AS TOTAL FROM SESSIONS UNION ALL SELECT '[5-10>' AS BIN, CASE WHEN DURATION/60 >= 5 AND DURATION/60 < 10 THEN 1 ELSE 0 END AS TOTAL FROM SESSIONS UNION ALL SELECT '[10-15>' AS BIN, CASE WHEN DURATION/60 >= 10 AND DURATION/60 < 15 THEN 1 ELSE 0 END AS TOTAL FROM SESSIONS UNION ALL SELECT '15 OR MORE' AS BIN, CASE WHEN DURATION/60 >= 15 THEN 1 ELSE 0 END AS TOTAL FROM SESSIONS ) A GROUP BY BIN;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT T1.VIEWER_ID AS ID FROM ( SELECT VIEWER_ID, VIEW_DATE, COUNT(DISTINCT ARTICLE_ID) AS ARTICLE_COUNT FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE ) T1 WHERE ARTICLE_COUNT > 1 ORDER BY ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE * U.UNITS) / SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM PRICES P JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE <= P.END_DATE AND U.PURCHASE_DATE >= P.START_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, STORE,PRICE FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) T WHERE PRICE IS NOT NULL ORDER BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH IPHONE AS( SELECT BUYER_ID FROM SALES A LEFT JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'IPHONE' ) SELECT DISTINCT BUYER_ID FROM SALES A LEFT JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM IPHONE);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT A.NAME ,B.BONUS FROM EMPLOYEE A LEFT JOIN BONUS B ON A.EMPID = B.EMPID WHERE COALESCE(B.BONUS,0)<1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, STORE , PRICE FROM ( SELECT PRODUCT_ID , 'STORE1' AS STORE , STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID , 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID , 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS ) A WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C'));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH F AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRSTLOGIN FROM ACTIVITY GROUP BY PLAYER_ID ) SELECT ACTIVITY.PLAYER_ID, ACTIVITY.DEVICE_ID FROM ACTIVITY JOIN F ON (F.PLAYER_ID = ACTIVITY.PLAYER_ID AND F.FIRSTLOGIN = ACTIVITY.EVENT_DATE);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTEB AS( SELECT S.BUYER_ID, P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM CTEB WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTEB WHERE PRODUCT_NAME ='IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, PRODUCT_NAME FROM PRODUCT P INNER JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID GROUP BY P.PRODUCT_ID, PRODUCT_NAME HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31';\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(SUM(CASE WHEN EVENT_DATE = MIN_DATE+1 THEN 1 ELSE 0 END) / COUNT(DISTINCT A.PLAYER_ID), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) TEMP JOIN ACTIVITY A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] (SELECT '[0-5>' BIN, COUNT(SESSION_ID) TOTAL FROM SESSIONS WHERE DURATION/60 >=0 AND DURATION/60 <5) UNION (SELECT '[5-10>' BIN, COUNT(SESSION_ID) TOTAL FROM SESSIONS WHERE DURATION/60 >=5 AND DURATION/60 <10) UNION (SELECT '[10-15>' BIN, COUNT(SESSION_ID) TOTAL FROM SESSIONS WHERE DURATION/60 >=10 AND DURATION/60 <15) UNION (SELECT '15 OR MORE' BIN, COUNT(SESSION_ID) TOTAL FROM SESSIONS WHERE DURATION/60 >=15);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT T.PROJECT_ID, ROUND(AVG(T.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM( (SELECT P.PROJECT_ID, P.EMPLOYEE_ID, E.EXPERIENCE_YEARS FROM PROJECT P INNER JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID) )AS T GROUP BY T.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT A.FIRSTNAME, A.LASTNAME,B.CITY,B.STATE FROM PERSON A LEFT JOIN ADDRESS B ON (A.PERSONID = B.PERSONID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO AS A JOIN LOGINFO AS B ON A.ACCOUNT_ID=B.ACCOUNT_ID AND (A.LOGIN BETWEEN B.LOGIN AND B.LOGOUT OR B.LOGIN BETWEEN A.LOGIN AND A.LOGOUT) WHERE A.IP_ADDRESS != B.IP_ADDRESS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT DISTINCT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION='REPORT' AND ACTION_DATE='2019-07-04' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] SELECT INSTALL_DT, COUNT(PLAYER_ID) AS INSTALLS, ROUND(COUNT(RETENTION)/COUNT(PLAYER_ID),2) AS DAY1_RETENTION FROM (SELECT A1.PLAYER_ID, A1.INSTALL_DT, A2.EVENT_DATE AS RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS INSTALL_DT FROM ACTIVITY GROUP BY PLAYER_ID) A1 LEFT JOIN ACTIVITY A2 ON A1.PLAYER_ID = A2.PLAYER_ID AND A1.INSTALL_DT + 1 = A2.EVENT_DATE) TMP GROUP BY INSTALL_DT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE AS ( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SAL FROM SALARIES GROUP BY COMPANY_ID ) SELECT S.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(CASE WHEN MAX_SAL < 1000 THEN SALARY WHEN MAX_SAL >= 1000 AND MAX_SAL <= 10000 THEN SALARY - SALARY * 0.24 ELSE SALARY - SALARY * 0.49 END) AS SALARY FROM SALARIES S LEFT JOIN CTE C ON C.COMPANY_ID = S.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, SUM( CASE WHEN DURATION < 300 THEN 1 ELSE 0 END ) AS TOTAL FROM SESSIONS UNION SELECT '[5-10>' AS BIN, SUM( CASE WHEN 300 <= DURATION AND DURATION < 600 THEN 1 ELSE 0 END ) AS TOTAL FROM SESSIONS UNION SELECT '[10-15>' AS BIN, SUM( CASE WHEN 600 <= DURATION AND DURATION < 900 THEN 1 ELSE 0 END ) AS TOTAL FROM SESSIONS UNION SELECT '15 OR MORE' AS BIN, SUM( CASE WHEN DURATION >= 900 THEN 1 ELSE 0 END ) AS TOTAL FROM SESSIONS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE BONUS < 1000 OR E.EMPID NOT IN ( SELECT EMPID FROM BONUS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT TEMP.VIEWER_ID AS ID FROM (SELECT VIEWER_ID, VIEW_DATE, COUNT(DISTINCT ARTICLE_ID ) AS TOTAL_ARTICLE FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID ) >1)TEMP ORDER BY TEMP.VIEWER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE AS (SELECT COMPANY_ID , MAX(SALARY) AS MAX_SALARY , (CASE WHEN MAX(SALARY) < 1000 THEN 1 WHEN MAX(SALARY) >= 1000 AND MAX(SALARY) <= 10000 THEN .76 ELSE .51 END) AS TAX FROM SALARIES GROUP BY COMPANY_ID) SELECT SALARIES.COMPANY_ID , SALARIES.EMPLOYEE_ID , SALARIES.EMPLOYEE_NAME , ROUND(SALARIES.SALARY * CTE.TAX, 0) AS SALARY FROM SALARIES LEFT JOIN CTE ON CTE.COMPANY_ID = SALARIES.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS <> L2.IP_ADDRESS WHERE (L1.LOGIN BETWEEN (L2.LOGIN) AND (L2.LOGOUT)) OR (L1.LOGOUT BETWEEN (L2.LOGIN) AND (L2.LOGOUT));\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT COALESCE(U.UNIQUE_ID) AS UNIQUE_ID, E.NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI U ON E.ID = U.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(DISTINCT B.PLAYER_ID) / COUNT(DISTINCT A.PLAYER_ID), 2) AS FRACTION FROM ( SELECT PLAYER_ID, MIN(EVENT_DATE) AS EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID ) A LEFT JOIN ACTIVITY AS B ON A.PLAYER_ID = B.PLAYER_ID AND A.EVENT_DATE + 1 = B.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT C.BUYER_ID FROM SALES C JOIN PRODUCT D ON C.PRODUCT_ID = D.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND BUYER_ID NOT IN (SELECT F.BUYER_ID FROM SALES F JOIN PRODUCT E ON F.PRODUCT_ID = E.PRODUCT_ID WHERE E.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A1.FIRST_LOGIN AS INSTALL_DT, COUNT(DISTINCT A1.PLAYER_ID) AS INSTALLS, ROUND((SUM(CASE WHEN (A1.FIRST_LOGIN + 1) = A2.EVENT_DATE THEN 1 ELSE 0 END)/ COUNT(DISTINCT A1.PLAYER_ID)), 2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS A1 JOIN ACTIVITY AS A2 ON A1.PLAYER_ID = A2.PLAYER_ID GROUP BY A1.FIRST_LOGIN;\n[SQL_2] SELECT INSTALL_DATE AS INSTALL_DT , COUNT(*) AS INSTALLS , ROUND(COUNT(B.PLAYER_ID)/COUNT(*),2) AS DAY1_RETENTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS INSTALL_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS A LEFT JOIN ACTIVITY B ON A.PLAYER_ID=B.PLAYER_ID AND A.INSTALL_DATE=B.EVENT_DATE-1 GROUP BY INSTALL_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(SUM(CASE WHEN T1.EVENT_DATE - T2.FIRST_DATE = 1 THEN 1 ELSE 0 END)/COUNT(DISTINCT T1.PLAYER_ID), 2) AS FRACTION FROM ACTIVITY T1 INNER JOIN (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS T2 ON T1.PLAYER_ID = T2.PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(T1.X-T2.X)) SHORTEST FROM POINT T1, POINT T2 WHERE T1.X <> T2.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, SUM(CASE WHEN DURATION>=0*60 AND DURATION<5*60 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS UNION SELECT '[5-10>' AS BIN, SUM(CASE WHEN DURATION>=5*60 AND DURATION<10*60 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS UNION SELECT '[10-15>' AS BIN, SUM(CASE WHEN DURATION>=10*60 AND DURATION<15*60 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS UNION SELECT '15 OR MORE' AS BIN, SUM(CASE WHEN DURATION>=15*60 THEN 1 ELSE 0 END) AS TOTAL FROM SESSIONS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT A.AUTHOR_ID AS ID FROM VIEWS A JOIN VIEWS B USING (AUTHOR_ID) WHERE A.AUTHOR_ID = B.VIEWER_ID ORDER BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH TEMP AS ( SELECT DISTINCT(A.FRIEND) AS FRIEND FROM (SELECT USER1_ID AS FRIEND FROM FRIENDSHIP WHERE USER2_ID = 1 UNION SELECT USER2_ID AS FRIEND FROM FRIENDSHIP WHERE USER1_ID = 1 ) AS A WHERE FRIEND != 1 ) SELECT DISTINCT(PAGE_ID) AS RECOMMENDED_PAGE FROM LIKES JOIN TEMP ON TEMP.FRIEND = LIKES.USER_ID WHERE PAGE_ID NOT IN (SELECT DISTINCT(PAGE_ID) AS RECOMMENDED_PAGE FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT T1.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS AS T1 LEFT JOIN TRANSACTIONS AS T2 ON T1.VISIT_ID = T2.VISIT_ID WHERE T2.TRANSACTION_ID IS NULL GROUP BY T1.CUSTOMER_ID HAVING COUNT(*) > 0;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT COALESCE(B.UNIQUE_ID, NULL) AS UNIQUE_ID, A.NAME FROM EMPLOYEES A LEFT JOIN EMPLOYEEUNI B ON A.ID = B.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY P.PROJECT_ID ORDER BY P.PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID WHERE L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT AND L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS != L2.IP_ADDRESS;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] WITH CTE AS ( SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) SELECT PRODUCT_ID, STORE, PRICE FROM CTE WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID , 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID , 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL UNION SELECT PRODUCT_ID , 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH T AS( SELECT DISTINCT USER2_ID AS F FROM FRIENDSHIP WHERE USER1_ID=1 UNION ALL SELECT DISTINCT USER1_ID AS F FROM FRIENDSHIP WHERE USER2_ID=1 ) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM LIKES JOIN T ON T.F=LIKES.USER_ID WHERE PAGE_ID NOT IN (SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE (P.PRODUCT_NAME = 'S8') AND ( S.BUYER_ID NOT IN ( SELECT S.BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE' ) );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID,MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID;\n[SQL_2] SELECT DISTINCT A.PLAYER_ID, MIN(A.EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY AS A GROUP BY A.PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(E.EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY PROJECT_ID ORDER BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME, B.BONUS FROM EMPLOYEE AS E LEFT JOIN BONUS AS B ON E.EMPID = B.EMPID WHERE B.BONUS < 1000 OR B.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH TAX AS( SELECT DISTINCT COMPANY_ID, CASE WHEN MAX(SALARY) < 1000 THEN 0 WHEN MAX(SALARY) BETWEEN 1000 AND 10000 THEN 0.24 ELSE 0.49 END AS TAX FROM SALARIES GROUP BY COMPANY_ID ) SELECT A.COMPANY_ID, A.EMPLOYEE_ID, A.EMPLOYEE_NAME, ROUND(A.SALARY * (1-B.TAX)) AS SALARY FROM SALARIES AS A JOIN TAX AS B ON A.COMPANY_ID=B.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS WHERE STORE1 >0 UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS WHERE STORE2 >0 UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS WHERE STORE3 >0;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH FRIENDS AS (SELECT ( CASE WHEN USER1_ID = 1 THEN USER2_ID ELSE USER1_ID END ) AS FRIEND FROM FRIENDSHIP WHERE USER1_ID = 1 OR USER2_ID = 1) SELECT DISTINCT(PAGE_ID) AS RECOMMENDED_PAGE FROM FRIENDS JOIN LIKES ON FRIENDS.FRIEND = LIKES.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME AS NAME, B.BONUS AS BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE B.BONUS IS NULL OR B.BONUS < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(*) COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] WITH FIRST_LOGIN_DAY AS ( SELECT PLAYER_ID,MIN(EVENT_DATE) AS FIRST_DAY FROM ACTIVITY GROUP BY PLAYER_ID ) SELECT CAST(COUNT(DISTINCT B.PLAYER_ID)/COUNT(DISTINCT A.PLAYER_ID) AS DECIMAL(13,2)) AS FRACTION FROM FIRST_LOGIN_DAY A LEFT OUTER JOIN ACTIVITY B ON A.PLAYER_ID=B.PLAYER_ID AND A.FIRST_DAY=B.EVENT_DATE-1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND((SUM(UNITS*PRICE) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES P INNER JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID WHERE PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A INNER JOIN (SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) AS T ON A.PLAYER_ID = T.PLAYER_ID AND A.EVENT_DATE = T.FIRST_LOGIN GROUP BY A.PLAYER_ID, A.DEVICE_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS STORE_TEMP WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] SELECT A.PLAYER_ID, A.DEVICE_ID FROM ACTIVITY A ,( SELECT B.PLAYER_ID, MIN(B.EVENT_DATE) FIRST FROM ACTIVITY B GROUP BY B.PLAYER_ID) AS C WHERE A.EVENT_DATE =C.FIRST AND A. PLAYER_ID = C. PLAYER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT AUTHOR_ID ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID GROUP BY AUTHOR_ID ORDER BY ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(P2.X-P1.X)) SHORTEST FROM POINT P1, POINT P2 WHERE P1.X != P2.X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID ) AS TOTAL FROM SESSIONS WHERE DURATION/60 <5 UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID ) AS TOTAL FROM SESSIONS WHERE DURATION/60 BETWEEN 5 AND 10 UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID ) AS TOTAL FROM SESSIONS WHERE DURATION/60 BETWEEN 10 AND 15 UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID ) AS TOTAL FROM SESSIONS WHERE DURATION/60 > 15;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM (SELECT EMAIL, COUNT(EMAIL) AS C FROM PERSON GROUP BY EMAIL) TEMP WHERE C > 1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT NAME AS CUSTOMERS FROM CUSTOMERS A WHERE A.ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.IP_ADDRESS != L2.IP_ADDRESS AND L1.LOGIN <= L2.LOGOUT AND L1.LOGOUT >= L2.LOGIN;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM (SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8')A WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT PLAYER_ID, DEVICE_ID FROM ACTIVITY WHERE (PLAYER_ID, EVENT_DATE) IN ( SELECT PLAYER_ID, MIN(EVENT_DATE) FROM ACTIVITY GROUP BY PLAYER_ID );\n[SQL_2] WITH T AS ( SELECT PLAYER_ID, MIN(EVENT_DATE) EVENT_DATE FROM ACTIVITY GROUP BY PLAYER_ID ) SELECT A.PLAYER_ID PLAYER_ID, A.DEVICE_ID DEVICE_ID FROM ACTIVITY A JOIN T ON A.PLAYER_ID=T.PLAYER_ID AND A.EVENT_DATE=T.EVENT_DATE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT(P_A.EMAIL) FROM PERSON AS P_A JOIN PERSON AS P_B ON P_A.EMAIL = P_B.EMAIL WHERE P_A.ID != P_B.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, 'STORE1' STORE, STORE1 PRICE FROM PRODUCTS WHERE STORE1 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE2' STORE, STORE2 PRICE FROM PRODUCTS WHERE STORE2 IS NOT NULL UNION SELECT PRODUCT_ID, 'STORE3' STORE, STORE3 PRICE FROM PRODUCTS WHERE STORE3 IS NOT NULL ORDER BY PRODUCT_ID, STORE;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME IN ('C')) AND CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME IN ('B')) AND CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME IN ('A')) ORDER BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND S.BUYER_ID NOT IN ( SELECT DISTINCT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT A.ID,A.NAME FROM STUDENTS AS A WHERE A.DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT EMPLOYEE.NAME ,BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS.BONUS < 1000 OR BONUS.BONUS IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT U.UNIQUE_ID,A.NAME FROM EMPLOYEES A LEFT JOIN EMPLOYEEUNI U ON A.ID=U.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH A AS (SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE O.PRODUCT_NAME = 'A') , B AS ( SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE O.PRODUCT_NAME = 'B'), C AS ( SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE O.PRODUCT_NAME = 'C') SELECT A.CUSTOMER_ID, A.CUSTOMER_NAME FROM A JOIN B ON A.CUSTOMER_ID = B.CUSTOMER_ID LEFT JOIN C ON A.CUSTOMER_ID = C.CUSTOMER_ID WHERE C.CUSTOMER_ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN , COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE DURATION BETWEEN 0 AND 299 UNION SELECT '[5-10>' AS BIN , COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE DURATION BETWEEN 300 AND 599 UNION SELECT '[10-15>' AS BIN , COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE DURATION BETWEEN 600 AND 899 UNION SELECT '15 OR MORE AS BIN', COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE DURATION >= 900;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT OUTER JOIN TRANSACTIONS ON TRANSACTIONS.VISIT_ID = VISITS.VISIT_ID WHERE TRANSACTIONS.VISIT_ID IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT C.CLASS FROM ( SELECT CLASS, COUNT(DISTINCT STUDENT) CNT FROM COURSES GROUP BY CLASS ) C WHERE CNT >= 5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME='S8' AND BUYER_ID NOT IN ( SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM EMPLOYEE E LEFT JOIN BONUS B USING(EMPID) WHERE COALESCE(BONUS,0)<1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SESSIONS, Columns = [ *, SESSION_ID, DURATION ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT '[0-5>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 0 AND (DURATION / 60) < 5) UNION SELECT '[5-10>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 5 AND (DURATION / 60) < 10) UNION SELECT '[10-15>' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE ((DURATION / 60) >= 10 AND (DURATION / 60) < 15) UNION SELECT '15 OR MORE' AS BIN, COUNT(SESSION_ID) AS TOTAL FROM SESSIONS WHERE (DURATION / 60) >= 15;\n[SQL_2] SELECT '[0-5>' AS BIN,COUNT(*) TOTAL FROM SESSIONS WHERE DURATION <5*60 UNION SELECT '[5-10>' AS BIN,COUNT(*) TOTAL FROM SESSIONS WHERE DURATION >=5*60 AND DURATION <=10*60 UNION SELECT '[10-15>' AS BIN,COUNT(*) TOTAL FROM SESSIONS WHERE DURATION >=10*60 AND DURATION <=15*60 UNION SELECT '15 OR MORE' AS BIN,COUNT(*) TOTAL FROM SESSIONS WHERE DURATION >=15*60;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT MIN(ABS(X1. X - X2. X)) AS SHORTEST FROM POINT AS X1 CROSS JOIN POINT AS X2 WHERE X1.X != X2. X;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT AUTHOR_ID AS ID FROM VIEWS GROUP BY AUTHOR_ID HAVING SUM(CASE WHEN VIEWER_ID = AUTHOR_ID THEN 1 ELSE 0 END) > 0 ORDER BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT T.CUSTOMER_ID AS CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM (SELECT CUSTOMER_ID, TRANSACTION_ID FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID=TRANSACTIONS.VISIT_ID) AS T WHERE T.TRANSACTION_ID IS NULL GROUP BY T.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT STUDENTS.ID, STUDENTS.NAME FROM STUDENTS LEFT JOIN DEPARTMENTS ON DEPARTMENTS.ID = STUDENTS.DEPARTMENT_ID WHERE DEPARTMENTS.ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID != 2 OR REFEREE_ID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH JOINED_TABLE AS ( SELECT P.PRODUCT_ID, P.PRICE, U.UNITS, P.PRICE * U.UNITS AS TOTAL_PAID FROM PRICES P JOIN UNITSSOLD U USING (PRODUCT_ID) WHERE U.PURCHASE_DATE >= P.START_DATE AND U.PURCHASE_DATE <= P.END_DATE ), AGGREGATED_DATA AS ( SELECT PRODUCT_ID, SUM(TOTAL_PAID) AS TOTAL_PAID, SUM(UNITS) AS TOTAL_UNITS FROM JOINED_TABLE GROUP BY PRODUCT_ID ) SELECT PRODUCT_ID, ROUND(TOTAL_PAID/TOTAL_UNITS, 2) AS AVERAGE_PRICE FROM AGGREGATED_DATA;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM ( SELECT VIEWER_ID, VIEW_DATE FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ) AS TMP ORDER BY ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT A.PAGE_ID AS RECOMMENDED_PAGE FROM ( SELECT USER_ID, PAGE_ID FROM LIKES WHERE USER_ID IN ( SELECT DISTINCT USER2_ID FROM FRIENDSHIP WHERE USER1_ID=1 UNION SELECT DISTINCT USER1_ID FROM FRIENDSHIP WHERE USER2_ID=1) AND PAGE_ID NOT IN (SELECT DISTINCT PAGE_ID FROM LIKES WHERE USER_ID=1) ) AS A;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT BUYER_ID FROM SALES A, PRODUCT B WHERE A.PRODUCT_ID=B.PRODUCT_ID AND PRODUCT_NAME='IPHONE') SELECT DISTINCT BUYER_ID FROM SALES A, PRODUCT B WHERE A.PRODUCT_ID=B.PRODUCT_ID AND PRODUCT_NAME='S8' AND BUYER_ID NOT IN (SELECT * FROM CTE);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT B.COMPANY_ID,EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY- (SALARY*(TAX/100))) AS SALARY FROM ( SELECT COMPANY_ID, CASE WHEN MAX_SAL <1000 THEN 0 WHEN MAX_SAL>=1000 AND 10000>=MAX_SAL THEN 24 ELSE 49 END AS TAX FROM ( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) A ) B JOIN SALARIES S ON B.COMPANY_ID=S.COMPANY_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME, B.BONUS FROM EMPLOYEE AS E LEFT JOIN BONUS AS B ON E.EMPID = B.EMPID WHERE B.BONUS IS NULL OR B.BONUS < 1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT P.PROJECT_ID, ROUND(SUM(E.EXPERIENCE_YEARS)/COUNT(E.EMPLOYEE_ID),2) AS AVERAGE_YEARS FROM PROJECT P LEFT JOIN EMPLOYEE E ON E.EMPLOYEE_ID = P.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT PRODUCT_ID, STORE, PRICE FROM ( SELECT PRODUCT_ID, STORE1 AS PRICE, 'STORE1' AS STORE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, STORE2 AS PRICE, 'STORE2' AS STORE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, STORE3 AS PRICE, 'STORE3' AS STORE FROM PRODUCTS ) F WHERE PRICE IS NOT NULL ORDER BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH TEMP AS ( SELECT U.PRODUCT_ID, U.UNITS, P.PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID WHERE U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) SELECT PRODUCT_ID, ROUND(SUM(UNITS*PRICE)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM TEMP GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH A AS (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A'), B AS (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') SELECT CUSTOMERS.CUSTOMER_ID, CUSTOMERS.CUSTOMER_NAME FROM A, B, CUSTOMERS WHERE A.CUSTOMER_ID = B.CUSTOMER_ID AND A.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID AND CUSTOMERS.CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L.ACCOUNT_ID FROM LOGINFO L JOIN LOGINFO T ON L.ACCOUNT_ID = T.ACCOUNT_ID AND L.IP_ADDRESS <> T.IP_ADDRESS AND T.LOGIN BETWEEN L.LOGIN AND L.LOGOUT;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT MIN(AUTHOR_ID) AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID GROUP BY AUTHOR_ID ORDER BY ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMER, Columns = [ *, ID, NAME, REFEREE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME FROM CUSTOMER WHERE REFEREE_ID <> 2 OR REFEREE_ID IS NULL;\n[SQL_2] SELECT NAME FROM CUSTOMER WHERE (REFEREE_ID IS NULL OR REFEREE_ID!=2);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT T1.CLASS FROM (SELECT CLASS, COUNT(*) AS TOT FROM COURSES GROUP BY CLASS) AS T1 WHERE T1.TOT >=5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A' )AND CUSTOMER_ID IN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B' )AND CUSTOMER_ID NOT IN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C' );\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, NAME FROM ( SELECT S.ID, S.NAME, D.ID DID FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID ) Q WHERE DID IS NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT FIRSTNAME, LASTNAME, CITY , STATE FROM PERSON P LEFT OUTER JOIN ADDRESS A ON P.PERSONID = A.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT DISTINCT S.ID, S.NAME FROM STUDENTS S WHERE S.DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT CASE WHEN E.ID IN (U.ID) THEN UNIQUE_ID ELSE NULL END AS UNIQUE_ID, E.NAME FROM EMPLOYEES AS E LEFT JOIN EMPLOYEEUNI AS U ON E.ID = U.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT * FROM LIKES WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1)) A WHERE USER_ID IN (SELECT USER1_ID FROM FRIENDSHIP WHERE USER2_ID=1 UNION ALL SELECT USER2_ID FROM FRIENDSHIP WHERE USER1_ID=1);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] WITH AGG AS ( SELECT CLASS , COUNT(*) AS A FROM COURSES GROUP BY CLASS) SELECT CLASS FROM AGG WHERE A >=5;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS V WHERE V.AUTHOR_ID = V.VIEWER_ID ORDER BY AUTHOR_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY MAKE_NAME, DATE_ID ORDER BY MAKE_NAME DESC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMERS.CUSTOMER_ID,CUSTOMERS.CUSTOMER_NAME FROM (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C')) A INNER JOIN CUSTOMERS ON A.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT P.FIRSTNAME AS FIRSTNAME, P.LASTNAME AS LASTNAME, A.CITY AS CITY, A.STATE AS STATE FROM ( SELECT * FROM PERSON ) P LEFT JOIN ( SELECT * FROM ADDRESS ) A ON P.PERSONID = A.PERSONID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID = E.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND((SUM((U.UNITS * P.PRICE)))/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD U JOIN PRICES P ON P.PRODUCT_ID = U.PRODUCT_ID WHERE U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID=BONUS.EMPID WHERE BONUS IS NULL OR BONUS <1000;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY AUTHOR_ID ASC;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIVITY, Columns = [ *, PLAYER_ID, EVENT_DATE, DEVICE_ID, GAMES_PLAYED ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND((SUM(CASE WHEN (TEMP.MIN_DATE + 1) = A.EVENT_DATE THEN 1 ELSE 0 END) / COUNT(DISTINCT TEMP.PLAYER_ID)), 2) AS FRACTION FROM (SELECT PLAYER_ID, MIN(EVENT_DATE) AS MIN_DATE FROM ACTIVITY GROUP BY PLAYER_ID) AS TEMP JOIN ACTIVITY AS A ON TEMP.PLAYER_ID = A.PLAYER_ID;\n[SQL_2] SELECT ROUND(COUNT(T2.PLAYER_ID)/COUNT(T1.PLAYER_ID),2) AS FRACTION FROM (SELECT PLAYER_ID,MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID) T1 LEFT JOIN ACTIVITY T2 ON T1.PLAYER_ID=T2.PLAYER_ID AND T2.EVENT_DATE=T1.FIRST_LOGIN+1;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT UNIQUE_ID, NAME FROM EMPLOYEEUNI AS EU RIGHT JOIN EMPLOYEES AS E ON EU.ID = E.ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION ALL SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS CTE WHERE PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, ID, NAME ]\nTable ORDERS, Columns = [ *, ID, CUSTOMERID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME AS CUSTOMERS FROM CUSTOMERS WHERE ID NOT IN (SELECT CUSTOMERID FROM ORDERS);\n[SQL_2] SELECT A.NAME AS CUSTOMERS FROM CUSTOMERS AS A WHERE A.ID NOT IN (SELECT DISTINCT(CUSTOMERID) FROM ORDERS);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCTS, Columns = [ *, PRODUCT_ID, STORE1, STORE2, STORE3 ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT * FROM (SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS) AS T WHERE PRICE IS NOT NULL;\n[SQL_2] SELECT * FROM ( SELECT PRODUCT_ID, 'STORE1' AS STORE, STORE1 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE2' AS STORE, STORE2 AS PRICE FROM PRODUCTS UNION SELECT PRODUCT_ID, 'STORE3' AS STORE, STORE3 AS PRICE FROM PRODUCTS ) AS A WHERE A.PRICE IS NOT NULL;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT A.EMAIL FROM PERSON A, PERSON B WHERE A.EMAIL = B.EMAIL AND (A.ID <> B.ID);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] WITH PE AS ( SELECT P.PROJECT_ID, E.EXPERIENCE_YEARS FROM PROJECT AS P LEFT JOIN EMPLOYEE AS E ON P.EMPLOYEE_ID=E.EMPLOYEE_ID ) SELECT PROJECT_ID, ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS FROM PE GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH IPHONE_BUYER AS( SELECT DISTINCT A.BUYER_ID FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'IPHONE'), S8_BUYER AS( SELECT DISTINCT A.BUYER_ID FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'S8' ) SELECT BUYER_ID FROM S8_BUYER WHERE BUYER_ID NOT IN (SELECT * FROM IPHONE_BUYER);\n\n### Answer",
        "answer": "Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM(SELECT VISITS.CUSTOMER_ID FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTION_ID IS NULL) AS TEMP GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY(V.CUSTOMER_ID);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P, SALES S WHERE P.PRODUCT_ID = S.PRODUCT_ID AND P.PRODUCT_ID NOT IN (SELECT P1.PRODUCT_ID FROM PRODUCT P1, SALES S1 WHERE P1.PRODUCT_ID = S1.PRODUCT_ID AND (S1.SALE_DATE < '2019-01-01' OR S1.SALE_DATE > '2019-03-31'));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN ( SELECT CUSTOMER_ID FROM ( SELECT CUSTOMER_ID, SUM( CASE WHEN PRODUCT_NAME='A' THEN 1 WHEN PRODUCT_NAME='B' THEN 1 WHEN PRODUCT_NAME='C' THEN 3 ELSE 0 END ) AS PRODUCT_SUM FROM ORDERS GROUP BY CUSTOMER_ID) TMP WHERE PRODUCT_SUM=2);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH TRUST AS ( SELECT CON.USER_ID, COUNT(CON.CONTACT_EMAIL) AS CONTACTS_CNT, COUNT(CUS.EMAIL) AS TRUSTED_CONTACTS_CNT FROM CONTACTS CON LEFT JOIN CUSTOMERS CUS ON CUS.EMAIL = CON.CONTACT_EMAIL GROUP BY CON.USER_ID) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COALESCE(T.CONTACTS_CNT,0) CONTACTS_CNT, COALESCE(T.TRUSTED_CONTACTS_CNT,0) TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN TRUST T ON I.USER_ID = T.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH PRODUCT_BUYER AS ( SELECT DISTINCT PRODUCT_NAME, BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID ) SELECT P1.BUYER_ID FROM PRODUCT_BUYER P1 LEFT JOIN PRODUCT_BUYER P2 ON P1.BUYER_ID = P2.BUYER_ID AND P2.PRODUCT_NAME = 'IPHONE' WHERE P1.PRODUCT_NAME = 'S8' AND P2.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) =0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AS AVERAGE_PRICE FROM (SELECT U.PRODUCT_ID, PRICE, UNITS FROM PRICES P RIGHT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND PURCHASE_DATE>= START_DATE AND PURCHASE_DATE<=END_DATE) A GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT A.EMAIL FROM PERSON A GROUP BY EMAIL HAVING COUNT(ID) >1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT SALES.PRODUCT_ID FROM SALES WHERE SALES.SALE_DATE > CAST('2019-03-31' AS DATE) OR SALES.SALE_DATE < CAST('2019-01-01' AS DATE));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES A JOIN PRODUCT B USING (PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN B.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) >0 AND SUM(CASE WHEN B.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT NAME,UNIQUE_ID FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID=E2.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM PRODUCT P JOIN SALES S USING (PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME='S8' THEN 1 ELSE 0 END)>0 AND SUM(CASE WHEN P.PRODUCT_NAME='IPHONE' THEN 1 ELSE 0 END)=0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM (SELECT DISTINCT STUDENT, CLASS FROM COURSES)A GROUP BY CLASS HAVING COUNT(CLASS) >=5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID , ROUND(SUM(P.PRICE * U.UNITS) / SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT STUDENTS.ID AS ID, STUDENTS.NAME AS NAME FROM STUDENTS LEFT JOIN DEPARTMENTS ON STUDENTS.DEPARTMENT_ID = DEPARTMENTS.ID WHERE DEPARTMENTS.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.NAME, EU.UNIQUE_ID FROM EMPLOYEES AS E LEFT JOIN EMPLOYEEUNI AS EU ON E.ID = EU.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID,COUNT(V.CUSTOMER_ID ) AS COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT ID FROM (SELECT A.AUTHOR_ID AS ID FROM VIEWS A,VIEWS B WHERE A.AUTHOR_ID=B.VIEWER_ID AND A.ARTICLE_ID=B.ARTICLE_ID) ID GROUP BY ID ORDER BY ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT A.DATE_ID, A.MAKE_NAME, COUNT(DISTINCT A.LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT A.PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES B LEFT JOIN DAILYSALES A ON A.DATE_ID = B.DATE_ID AND A.MAKE_NAME = B.MAKE_NAME WHERE B.LEAD_ID <= A.LEAD_ID AND B.PARTNER_ID <= A.PARTNER_ID GROUP BY A.DATE_ID, A.MAKE_NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, CASE WHEN CONTACTS_CNT IS NULL THEN 0 ELSE CONTACTS_CNT END CONTACTS_CNT, CASE WHEN TRUSTED_CONTACTS_CNT IS NULL THEN 0 ELSE TRUSTED_CONTACTS_CNT END TRUSTED_CONTACTS_CNT FROM CUSTOMERS LEFT JOIN (SELECT USER_ID, COUNT(CONTACT_EMAIL) CONTACTS_CNT, SUM(IS_TRUSTED) TRUSTED_CONTACTS_CNT FROM (SELECT * , CASE WHEN EMAIL IS NULL THEN 0 ELSE 1 END AS IS_TRUSTED FROM CONTACTS CO LEFT JOIN CUSTOMERS CU ON CO.CONTACT_EMAIL=CU.EMAIL) CO GROUP BY USER_ID) TAMPA ON USER_ID=CUSTOMER_ID INNER JOIN INVOICES ON INVOICES.USER_ID=CUSTOMER_ID ORDER BY INVOICES.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY DIRECTOR_ID,ACTOR_ID HAVING COUNT(DIRECTOR_ID)>=3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN( SELECT P.PRODUCT_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.SALE_DATE < '2019-01-01' OR S.SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT A.ACCOUNT_ID FROM LOGINFO A INNER JOIN LOGINFO B ON A.ACCOUNT_ID=B.ACCOUNT_ID AND A.IP_ADDRESS != B.IP_ADDRESS AND A.LOGIN >B.LOGIN AND A.LOGIN<=B.LOGOUT;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH SOLD_PRODUCTS AS ( SELECT S.BUYER_ID, SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) S8, SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) IPHONE FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID ) SELECT DISTINCT BUYER_ID FROM SOLD_PRODUCTS WHERE S8 > 0 AND IPHONE = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH F1 AS( SELECT DISTINCT A.PID FROM INSURANCE A CROSS JOIN INSURANCE B WHERE A.TIV_2015 = B.TIV_2015 AND A.PID != B.PID ), F2 AS( SELECT PID FROM INSURANCE WHERE (LAT, LON) NOT IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) > 1)) SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE PID IN (SELECT F1.PID FROM F1 JOIN F2 USING(PID));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE<'2019-01-01' OR SALE_DATE>'2019-03-31' ) GROUP BY P.PRODUCT_ID, P.PRODUCT_NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>=2) AND (LAT, LON) NOT IN ( SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) > 1 );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES INNER JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT P.LASTNAME, P.FIRSTNAME, A.CITY, A.STATE FROM PERSON P LEFT OUTER JOIN ADDRESS A ON P.PERSONID = A.PERSONID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM SALES WHERE BUYER_ID IN ( SELECT BUYER_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' ) AND BUYER_ID NOT IN( SELECT BUYER_ID FROM SALES AS S LEFT JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT SUB1.CUSTOMER_ID , C.CUSTOMER_NAME FROM ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') SUB1 JOIN ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') SUB2 ON SUB1.CUSTOMER_ID = SUB2.CUSTOMER_ID LEFT JOIN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') SUB3 ON SUB1.CUSTOMER_ID = SUB3.CUSTOMER_ID JOIN CUSTOMERS C ON SUB1.CUSTOMER_ID = C.CUSTOMER_ID WHERE SUB3.CUSTOMER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(DISTINCT(I1.TIV_2016)), 2) AS TIV_2016 FROM INSURANCE I1 INNER JOIN INSURANCE I2 ON I1.PID != I2.PID AND I1.TIV_2015 = I2.TIV_2015 AND I1.LAT!=I2.LAT AND I1.LON!=I2.LON AND (I1.LAT, I1.LON) NOT IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) > 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT(CUSTOMER_ID), COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN(SELECT DISTINCT(VISIT_ID) FROM TRANSACTIONS) GROUP BY CUSTOMER_ID ORDER BY COUNT(CUSTOMER_ID);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT A1.AUTHOR_ID AS ID FROM VIEWS A1, VIEWS A2 WHERE A1.AUTHOR_ID = A2.VIEWER_ID AND A1.ARTICLE_ID = A2.ARTICLE_ID ORDER BY A1.AUTHOR_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.VIEWER_ID AS ID FROM VIEWS V1 JOIN VIEWS V2 ON V1.VIEWER_ID = V2.VIEWER_ID AND V1.VIEW_DATE = V2.VIEW_DATE AND V1.ARTICLE_ID != V2.ARTICLE_ID ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH S8_BUYERS AS ( SELECT BUYER_ID FROM SALES WHERE PRODUCT_ID = (SELECT PRODUCT_ID FROM PRODUCT P WHERE PRODUCT_NAME = 'S8') ), IPHONE_BUYERS AS ( SELECT BUYER_ID FROM SALES WHERE PRODUCT_ID = (SELECT PRODUCT_ID FROM PRODUCT P WHERE PRODUCT_NAME='IPHONE') ) SELECT DISTINCT S.BUYER_ID FROM SALES S WHERE S.BUYER_ID IN (SELECT A.BUYER_ID FROM S8_BUYERS A) AND S.BUYER_ID NOT IN (SELECT B.BUYER_ID FROM IPHONE_BUYERS B);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT A.VIEWER_ID AS ID FROM VIEWS A JOIN VIEWS B ON A.VIEWER_ID = B.VIEWER_ID AND A.ARTICLE_ID != B.ARTICLE_ID AND A.VIEW_DATE = B.VIEW_DATE ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(*) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS FROM DAILYSALES GROUP BY MAKE_NAME, DATE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID , PRODUCT_NAME FROM PRODUCT P WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CONTACTS_LKP AS ( SELECT CT.*, CASE WHEN CUST_EMAILS.EMAIL IS NOT NULL THEN 1 ELSE 0 END AS IS_TRUSTED FROM CONTACTS AS CT LEFT JOIN ( SELECT EMAIL FROM CUSTOMERS GROUP BY EMAIL ) AS CUST_EMAILS ON CT.CONTACT_EMAIL = CUST_EMAILS.EMAIL ) , CONTACT_INFO AS ( SELECT USER_ID, COUNT(*) AS CONTACTS_CNT, SUM(IS_TRUSTED) AS TRUSTED_CONTACTS_CNT FROM CONTACTS_LKP GROUP BY USER_ID ) SELECT I.INVOICE_ID, CT.CUSTOMER_NAME, I.PRICE, COALESCE(CI.CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(CI.TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM INVOICES AS I INNER JOIN CUSTOMERS AS CT ON I.USER_ID = CT.CUSTOMER_ID LEFT JOIN CONTACT_INFO AS CI ON I.USER_ID = CI.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT A.EXTRA AS REPORT_REASON,COUNT(A.EXTRA) AS REPORT_COUNT FROM( SELECT DISTINCT POST_ID,ACTION_DATE,ACTION,EXTRA FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT') A WHERE A.EXTRA IS NOT NULL GROUP BY A.EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT DISTINCT EXTRA AS REPORT_REASON,COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION='REPORT' AND ACTION_DATE='2019-07-04' AND EXTRA IS NOT NULL GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM PRODUCT LEFT JOIN SALES USING(PRODUCT_ID) WHERE PRODUCT_NAME='S8' AND BUYER_ID NOT IN ( SELECT BUYER_ID FROM SALES LEFT JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME='IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA > 3E6 OR POPULATION > 25E6;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH TOTAL_DOLLAR_STEP1 AS( SELECT U.PRODUCT_ID,P.PRICE*U.UNITS AS TOTAL_LINES FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID=P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE), TOTAL_DOLLAR_STEP2 AS ( SELECT PRODUCT_ID,SUM(TOTAL_LINES) AS TOTAL_PRICE FROM TOTAL_DOLLAR_STEP1 GROUP BY PRODUCT_ID), UNITS_TOTAL AS(SELECT PRODUCT_ID,SUM(UNITS) AS TOTAL_U FROM UNITSSOLD GROUP BY PRODUCT_ID) SELECT A.PRODUCT_ID,ROUND(A.TOTAL_PRICE/B.TOTAL_U,2) AS AVERAGE_PRICE FROM TOTAL_DOLLAR_STEP2 A INNER JOIN UNITS_TOTAL B ON A.PRODUCT_ID=B.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT SS8.BUYER_ID FROM SALES AS SS8 INNER JOIN PRODUCT AS PS8 ON PS8.PRODUCT_ID = SS8.PRODUCT_ID AND PRODUCT_NAME = 'S8' LEFT JOIN (SELECT BUYER_ID, S.PRODUCT_ID FROM SALES S INNER JOIN PRODUCT AS PIPHONE ON PIPHONE.PRODUCT_ID = S.PRODUCT_ID AND PIPHONE.PRODUCT_NAME = 'IPHONE') AS SIPHONE ON SS8.BUYER_ID = SIPHONE.BUYER_ID WHERE PS8.PRODUCT_ID IS NOT NULL AND SIPHONE.PRODUCT_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID AS PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD AS U LEFT JOIN PRICES AS P ON U.PRODUCT_ID = P.PRODUCT_ID AND P.START_DATE <= U.PURCHASE_DATE AND (P.END_DATE >= U.PURCHASE_DATE) GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON P.PRODUCT_ID=U.PRODUCT_ID AND PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY U.PRODUCT_ID ORDER BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT NAME, UNIQUE_ID FROM EMPLOYEES AS A LEFT JOIN EMPLOYEEUNI AS B ON A.ID=B.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT A.BUYER_ID FROM (SELECT S.BUYER_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8') A LEFT JOIN (SELECT S.BUYER_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE') B ON A.BUYER_ID = B.BUYER_ID WHERE B.PRODUCT_NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTIONS.TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, COALESCE(ROUND(SUM(P.PRICE * U.UNITS) / SUM(U.UNITS), 2), 0) AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON (U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE >= P.START_DATE AND U.PURCHASE_DATE <= P.END_DATE) GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] WITH POINT1 AS (SELECT X FROM POINT ORDER BY X), POINT2 AS (SELECT X FROM POINT ORDER BY X LIMIT 1234566 OFFSET 1) SELECT ABS(P2.X-P1.X) SHORTEST FROM POINT1 P1, POINT2 P2 WHERE ABS(P2.X-P1.X)>0 ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(P.PRICE * U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN ( SELECT DISTINCT BUYER_ID FROM SALES INNER JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'S8' ) AND BUYER_ID NOT IN ( SELECT DISTINCT BUYER_ID FROM SALES INNER JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'IPHONE' ) ORDER BY BUYER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH B AS ( WITH A AS ( SELECT VIEWER_ID,VIEW_DATE , COUNT(DISTINCT ARTICLE_ID) AS X FROM VIEWS GROUP BY VIEWER_ID,VIEW_DATE ) SELECT A.VIEWER_ID AS ID , A.VIEW_DATE FROM A JOIN A B ON A.VIEW_DATE = B.VIEW_DATE WHERE A.X > 1 ) SELECT DISTINCT ID FROM B ORDER BY ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM CUSTOMERS C JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID WHERE O.PRODUCT_NAME = 'A' AND C.CUSTOMER_ID IN (SELECT B.CUSTOMER_ID FROM ORDERS B WHERE B.PRODUCT_NAME = 'B') AND C.CUSTOMER_ID NOT IN (SELECT C1.CUSTOMER_ID FROM ORDERS C1 WHERE C1.PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID, DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID HAVING COUNT(ACTOR_ID)> 2 AND COUNT(DIRECTOR_ID) > 2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT AS P WHERE P.PRODUCT_ID NOT IN ( SELECT DISTINCT PRODUCT_ID FROM SALES AS S WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS T) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH TABLE1 AS (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) > 1) SELECT ROUND(SUM(DISTINCT(I1.TIV_2016)), 2) AS TIV_2016 FROM INSURANCE I1 INNER JOIN INSURANCE I2 ON I1.PID != I2.PID AND I1.TIV_2015 = I2.TIV_2015 AND I1.LAT!=I2.LAT AND I1.LON!=I2.LON AND (I1.LAT, I1.LON) NOT IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) > 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(*) AS REPORT_COUNT FROM (SELECT DISTINCT POST_ID, EXTRA FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04') AS T GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM (SELECT DISTINCT * FROM VIEWS) V GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(ARTICLE_ID)>1 ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND (EXTRA IS NOT NULL) AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES S WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH TABLE1 AS (SELECT VISITS.VISIT_ID,CUSTOMER_ID, AMOUNT FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE AMOUNT IS NULL) SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM TABLE1 GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT S.PRODUCT_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE (SALE_DATE > '2019-03-31') OR (SALE_DATE < '2019-01-01') );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM ( SELECT DISTINCT ARTICLE_ID , AUTHOR_ID , VIEWER_ID , VIEW_DATE FROM VIEWS )A GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(1) >1 ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT DISTINCT ACTOR_ID, DIRECTOR_ID FROM (SELECT ACTOR_ID, DIRECTOR_ID, COUNT(ACTOR_ID) AS CNT FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID) AS TEMP WHERE CNT>=3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.NAME, EM.UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EM ON E.ID = EM.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID, CU.CUSTOMER_NAME, I.PRICE, COALESCE(CC.CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(TCC.TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM INVOICES AS I LEFT JOIN CUSTOMERS AS CU ON I.USER_ID = CU.CUSTOMER_ID LEFT JOIN (SELECT USER_ID, COUNT(*) AS CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID) AS CC ON I.USER_ID = CC.USER_ID LEFT JOIN (SELECT USER_ID, COUNT(*) AS TRUSTED_CONTACTS_CNT FROM CONTACTS WHERE CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) GROUP BY USER_ID ) AS TCC ON I.USER_ID = TCC.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH VISIT_T AS ( SELECT VISIT_ID, SUM(AMOUNT) AS TOTAL FROM TRANSACTIONS GROUP BY VISIT_ID ) ,VISIT_C AS ( SELECT V.VISIT_ID, V.CUSTOMER_ID, VT.TOTAL FROM VISITS V LEFT JOIN VISIT_T VT ON V.VISIT_ID = VT.VISIT_ID ) SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISIT_C VC WHERE VC.TOTAL IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM (SELECT DISTINCT * FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION_DATE='2019-07-04' AND ACTION='REPORT') AS X GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AS AVERAGE_PRICE, US.PRODUCT_ID FROM UNITSSOLD AS US INNER JOIN PRICES ON PRICES.PRODUCT_ID = US.PRODUCT_ID WHERE PURCHASE_DATE>= START_DATE AND PURCHASE_DATE <= END_DATE GROUP BY US.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(P1.X - P2.X) AS SHORTEST FROM POINT P1 CROSS JOIN POINT P2 WHERE P1.X != P2.X ORDER BY SHORTEST ASC LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT A.BUYER_ID FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE A.BUYER_ID IN (SELECT A.BUYER_ID FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'S8') AND A.BUYER_ID NOT IN (SELECT A.BUYER_ID FROM SALES A JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE B.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON,COUNT(DISTINCT(POST_ID)) AS REPORT_COUNT FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION ='REPORT' AND ACTION_DATE = (SELECT MAX(ACTION_DATE) FROM ACTIONS) GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(DISTINCT V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID=T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID NOT IN(SELECT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE') AND BUYER_ID IN(SELECT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT T1.EXTRA AS REPORT_REASON, COUNT(*) AS REPORT_COUNT FROM (SELECT DISTINCT POST_ID, ACTION_DATE, ACTION, EXTRA FROM ACTIONS) T1 WHERE T1.ACTION = 'REPORT' AND T1.ACTION_DATE = '2019-07-04' GROUP BY T1.EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.NAME, EUNI.UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EUNI ON E.ID = EUNI.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID=PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME='S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID=PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT UNITSSOLD.PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD LEFT JOIN PRICES ON PRICES.PRODUCT_ID = UNITSSOLD.PRODUCT_ID AND PRICES.START_DATE <= UNITSSOLD.PURCHASE_DATE AND UNITSSOLD.PURCHASE_DATE <= PRICES.END_DATE GROUP BY UNITSSOLD.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID AND P.PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID AND P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 INNER JOIN LOGINFO L2 ON L1.ACCOUNT_ID =L2.ACCOUNT_ID AND L1.IP_ADDRESS !=L2.IP_ADDRESS AND L1.LOGIN > L2.LOGIN AND L1.LOGIN <= L2.LOGOUT;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID, COUNT(A.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS A WHERE A.VISIT_ID NOT IN (SELECT B.VISIT_ID FROM TRANSACTIONS B) GROUP BY A.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(*) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID, CUSTOMER_NAME FROM ORDERS A JOIN ORDERS B ON A.CUSTOMER_ID = B.CUSTOMER_ID JOIN CUSTOMERS C ON A.CUSTOMER_ID = C.CUSTOMER_ID WHERE A.PRODUCT_NAME = 'A' AND B.PRODUCT_NAME = 'B' AND A.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISITS.VISIT_ID FROM VISITS INNER JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID) GROUP BY CUSTOMER_ID ORDER BY COUNT(CUSTOMER_ID) DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(X2.X - X1.X) AS SHORTEST FROM POINT X1 JOIN POINT X2 ON X1.X != X2.X ORDER BY 1 LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM (SELECT DISTINCT STUDENT, CLASS FROM COURSES) AS S GROUP BY CLASS HAVING COUNT(CLASS) >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) NOT IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)>1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT AS P JOIN SALES AS S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' ) AND P.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT DISTINCT ABS(P1.X-P2.X) SHORTEST FROM POINT P1, POINT P2 WHERE P1.X != P2.X ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT W.NAME, W.POPULATION, W.AREA FROM WORLD W WHERE W.AREA > 3000000 OR W.POPULATION > 25000000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID,P.PRODUCT_NAME FROM PRODUCT AS P WHERE P.PRODUCT_ID NOT IN (SELECT S.PRODUCT_ID FROM SALES AS S WHERE S.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM PERSON GROUP BY(EMAIL) HAVING COUNT(*)>1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES A,PRODUCT B WHERE A.PRODUCT_ID=B.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME='S8' THEN 1 ELSE 0 END) >0 AND SUM(CASE WHEN PRODUCT_NAME='IPHONE' THEN 1 ELSE 0 END) =0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH S8 AS ( SELECT BUYER_ID FROM SALES INNER JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' ), IPHONE AS ( SELECT BUYER_ID FROM SALES INNER JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE' ) SELECT DISTINCT S8.BUYER_ID FROM S8 LEFT JOIN IPHONE ON S8.BUYER_ID = IPHONE.BUYER_ID WHERE IPHONE.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(EXTRA) AS REPORT_COUNT FROM (SELECT DISTINCT POST_ID , EXTRA FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND EXTRA IS NOT NULL AND ACTION = 'REPORT') AS SQ GROUP BY EXTRA HAVING COUNT(EXTRA) > 0 ORDER BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT T.CUSTOMER_ID, CUSTOMER_NAME FROM ( SELECT CUSTOMER_ID, SUM(CASE WHEN PRODUCT_NAME IN ('A', 'B') THEN 1 WHEN PRODUCT_NAME = 'C' THEN -1 ELSE 0 END) AS POINT FROM ORDERS GROUP BY CUSTOMER_ID) AS T JOIN CUSTOMERS AS C ON T.CUSTOMER_ID = C.CUSTOMER_ID WHERE POINT = 2 ORDER BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*US.UNITS) / SUM(US.UNITS), 2) AS AVERAGE_PRICE FROM PRICES AS P LEFT JOIN UNITSSOLD AS US ON P.PRODUCT_ID = US.PRODUCT_ID AND US.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT T2.PRODUCT_ID, ROUND(T2.REVENUE/T2.AMT,2) AS AVERAGE_PRICE FROM (SELECT A.PRODUCT_ID, SUM(A.UNITS*B.PRICE) AS REVENUE, SUM(A.UNITS) AS AMT FROM UNITSSOLD A LEFT JOIN PRICES B ON (A.PRODUCT_ID=B.PRODUCT_ID AND A.PURCHASE_DATE>=B.START_DATE AND A.PURCHASE_DATE<=B.END_DATE) GROUP BY A.PRODUCT_ID)T2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS( SELECT BUYER_ID,PRODUCT_NAME FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID=PRODUCT.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM CTE WHERE BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME='S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN( SELECT S.PRODUCT_ID FROM SALES S WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT P.FIRSTNAME, P.LASTNAME, A.CITY, A.STATE FROM PERSON P LEFT JOIN ADDRESS A ON P.PERSONID = A.PERSONID UNION SELECT P.FIRSTNAME, P.LASTNAME, A.CITY, A.STATE FROM PERSON P LEFT JOIN ADDRESS A ON P.PERSONID = A.PERSONID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V WHERE V.VISIT_ID NOT IN(SELECT T.VISIT_ID FROM TRANSACTIONS AS T) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH S8_BUYERS AS ( SELECT DISTINCT(S.BUYER_ID) FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' ), IPHONE_BUYERS AS ( SELECT DISTINCT(S.BUYER_ID) FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE' ) SELECT X.BUYER_ID FROM S8_BUYERS AS X LEFT JOIN IPHONE_BUYERS AS Y ON X.BUYER_ID = Y.BUYER_ID WHERE Y.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH A AS ( SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A'), B AS (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') SELECT A.CUSTOMER_ID, C.CUSTOMER_NAME FROM A JOIN B ON A.CUSTOMER_ID = B.CUSTOMER_ID JOIN CUSTOMERS C ON A.CUSTOMER_ID = C.CUSTOMER_ID AND A.CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT Y.EXTRA AS REPORT_REASON,COUNT(DISTINCT Y.POST_ID) AS REPORT_COUNT FROM ( SELECT * FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION_DATE='2019-07-04' AND ACTION='REPORT' ) AS Y GROUP BY Y.EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(1) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID, COUNT(C.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS C LEFT JOIN TRANSACTIONS T ON C.VISIT_ID = T.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY C.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE, COALESCE(C.CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(D.TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM INVOICES A LEFT JOIN CUSTOMERS B ON A.USER_ID = B.CUSTOMER_ID LEFT JOIN ( SELECT USER_ID, COUNT(*) AS CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID ) C ON B.CUSTOMER_ID = C.USER_ID LEFT JOIN ( SELECT USER_ID, COUNT(*) AS TRUSTED_CONTACTS_CNT FROM CONTACTS WHERE CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) GROUP BY USER_ID ) D ON C.USER_ID = D.USER_ID ORDER BY A.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT A.CLASS FROM (SELECT DISTINCT STUDENT, CLASS FROM COURSES) A GROUP BY A.CLASS HAVING COUNT(A.CLASS) >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT W.NAME, W.POPULATION, W.AREA FROM WORLD W WHERE W.POPULATION>25000000 OR W.AREA>3000000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES JOIN PRODUCT USING(PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME='S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN PRODUCT_NAME='IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON T.VISIT_ID = V.VISIT_ID WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, PERSONID, FIRSTNAME, LASTNAME ]\nTable ADDRESS, Columns = [ *, ADDRESSID, PERSONID, CITY, STATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT FIRSTNAME, LASTNAME, CITY, STATE FROM PERSON AS P LEFT OUTER JOIN ADDRESS AS A ON P.PERSONID = A.PERSONID;\n[SQL_2] SELECT DISTINCT A.FIRSTNAME, A.LASTNAME, B.CITY, B.STATE FROM PERSON A LEFT JOIN ADDRESS B ON A.PERSONID=B.PERSONID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] WITH TB1 AS( SELECT * FROM ACTIONS A WHERE EXTRA <> 'NULL' AND ACTION_DATE = '2019-07-4' AND A.ACTION = 'REPORT' ) SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT(POST_ID)) AS REPORT_COUNT FROM TB1 GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT A.EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS AS A WHERE A.ACTION_DATE = '2019-07-04' AND A.ACTION = 'REPORT' AND A.EXTRA IS NOT NULL GROUP BY A.EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM ( SELECT V.VISIT_ID,CUSTOMER_ID, T.AMOUNT FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE AMOUNT IS NULL) G GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT PRODUCT_ID, PRODUCT_NAME FROM ( SELECT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID ) X WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID,S.NAME FROM STUDENTS AS S LEFT JOIN DEPARTMENTS AS D ON D.ID=S.DEPARTMENT_ID WHERE D.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID,COUNT(A.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS AS A LEFT JOIN TRANSACTIONS AS B ON A.VISIT_ID = B.VISIT_ID WHERE B.AMOUNT IS NULL GROUP BY A.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM PRODUCT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE PRODUCT.PRODUCT_ID NOT IN (SELECT DISTINCT SALES.PRODUCT_ID FROM SALES WHERE SALES.SALE_DATE > '2019-03-31' OR SALES.SALE_DATE < '2019-01-01');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH GET_ORDERS AS ( SELECT CUSTOMER_ID, COUNT(DISTINCT CASE WHEN PRODUCT_NAME = 'A' THEN PRODUCT_NAME WHEN PRODUCT_NAME = 'B' THEN PRODUCT_NAME ELSE NULL END ) AS C1, SUM(CASE WHEN PRODUCT_NAME = 'A' THEN 1 WHEN PRODUCT_NAME = 'B' THEN 1 WHEN PRODUCT_NAME = 'C' THEN -2 ELSE 0 END) AS S1 FROM ORDERS GROUP BY CUSTOMER_ID ) SELECT A.CUSTOMER_ID, B.CUSTOMER_NAME FROM GET_ORDERS A LEFT JOIN CUSTOMERS B ON A.CUSTOMER_ID = B.CUSTOMER_ID WHERE S1 >=2 AND C1 >=2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH SAME_TIV_2015 AS ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(1) > 1 ), DIFF_LAT_LONG AS ( SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(1) = 1 ) SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE I1 WHERE ( TIV_2015 IN (SELECT * FROM SAME_TIV_2015) ) AND ( (LAT,LON) IN (SELECT * FROM DIFF_LAT_LONG) );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS (SELECT S.BUYER_ID, P.PRODUCT_NAME FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' OR PRODUCT_NAME = 'IPHONE') SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH REVENUE AS ( SELECT A.*, B.PURCHASE_DATE, B.UNITS, A.PRICE * B.UNITS AS REVENUE FROM PRICES AS A LEFT JOIN UNITSSOLD AS B ON A.PRODUCT_ID = B.PRODUCT_ID AND A.START_DATE <= B.PURCHASE_DATE AND A.END_DATE >= B.PURCHASE_DATE ) SELECT PRODUCT_ID, ROUND(SUM(REVENUE) / SUM(UNITS), 2) AS AVERAGE_PRICE FROM REVENUE GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME FROM ORDERS AS O INNER JOIN CUSTOMERS AS C ON O.CUSTOMER_ID = C.CUSTOMER_ID WHERE PRODUCT_NAME IN ('A','B') AND C.CUSTOMER_ID NOT IN ( SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C' ) GROUP BY C.CUSTOMER_ID , C.CUSTOMER_NAME HAVING COUNT(C.CUSTOMER_NAME)=2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E.NAME ,COALESCE(U.UNIQUE_ID,NULL) AS UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI U ON E.ID = U.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(VISITS.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' OR PRODUCT_NAME = 'IPHONE' GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) != 0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] WITH POP AS ( SELECT NAME, POPULATION, AREA FROM WORLD WHERE POPULATION > 25000000 ), AREA AS ( SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA > 3000000 ) SELECT * FROM POP UNION SELECT * FROM AREA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE AS( SELECT USER_ID, COUNT(CONTACT_NAME) AS CONTACTS_CNT,COUNT(CU.EMAIL) AS TRUSTED_CONTACTS_CNT FROM CONTACTS C LEFT JOIN CUSTOMERS CU ON C.CONTACT_EMAIL = CU.EMAIL GROUP BY USER_ID ) SELECT INVOICE_ID,CUSTOMER_NAME,PRICE,COALESCE(CONTACTS_CNT,0) AS CONTACTS_CNT,COALESCE(TRUSTED_CONTACTS_CNT,0) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS CU ON I.USER_ID = CU.CUSTOMER_ID LEFT JOIN CTE C ON I.USER_ID = C.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS USING(VISIT_ID) WHERE AMOUNT IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT VIEWER_ID AS ID FROM (SELECT DISTINCT VIEWER_ID, COUNT(DISTINCT ARTICLE_ID) AS CNT FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID) A WHERE CNT > 1 ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT REPORT_REASON, SUM(REPORT_COUNT) AS REPORT_COUNT FROM (SELECT EXTRA AS REPORT_REASON , COUNT(DISTINCT ACTION) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY POST_ID, EXTRA) SQ GROUP BY REPORT_REASON;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID,PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID IN ( SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE>'2019-01-01' AND SALE_DATE<='2019-03-31' AND PRODUCT_ID NOT IN ( SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' ) );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT US.PRODUCT_ID, ROUND(SUM(US.UNITS * P.PRICE)/SUM(US.UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD AS US LEFT JOIN PRICES AS P ON US.PRODUCT_ID = P.PRODUCT_ID AND US.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY US.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS( SELECT S.BUYER_ID, P.PRODUCT_NAME FROM PRODUCT AS P JOIN SALES AS S ON P.PRODUCT_ID = S.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM CTE WHERE BUYER_ID IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM CTE WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(A.X - B.X) SHORTEST FROM POINT A , POINT B WHERE A.X<>B.X ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON T.VISIT_ID = V.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM ( SELECT DISTINCT STUDENT, CLASS FROM COURSES ) T GROUP BY CLASS HAVING COUNT(CLASS) >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM (SELECT EMAIL, COUNT(*) FROM PERSON GROUP BY EMAIL HAVING COUNT(*) > 1) AS A;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRICES.PRODUCT_ID, ROUND(SUM(PRICES.PRICE*UNITSSOLD.UNITS)/SUM(UNITSSOLD.UNITS),2) AS AVERAGE_PRICE FROM PRICES INNER JOIN (SELECT DISTINCT * FROM UNITSSOLD) UNITSSOLD ON PRICES.PRODUCT_ID = UNITSSOLD.PRODUCT_ID WHERE PURCHASE_DATE>=START_DATE AND PURCHASE_DATE<=END_DATE GROUP BY PRICES.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(*)>1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(CN.USER_ID) CONTACTS_CNT, COUNT(T.CUSTOMER_NAME) TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS CN ON CN.USER_ID = C.CUSTOMER_ID LEFT JOIN CUSTOMERS T ON CN.CONTACT_NAME = T.CUSTOMER_NAME GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] WITH X AS (SELECT DATE_ID,MAKE_NAME,COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS FROM DAILYSALES GROUP BY DATE_ID,MAKE_NAME) , Y AS (SELECT DATE_ID,MAKE_NAME,COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID,MAKE_NAME) SELECT X.DATE_ID, X.MAKE_NAME, X.UNIQUE_LEADS, Y.UNIQUE_PARTNERS FROM X INNER JOIN Y ON X.DATE_ID=Y.DATE_ID AND X.MAKE_NAME=Y.MAKE_NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT A.NAME, B.UNIQUE_ID FROM EMPLOYEES AS A LEFT JOIN EMPLOYEEUNI AS B ON A.ID=B.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT SALES.PRODUCT_ID FROM PRODUCT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM (SELECT DISTINCT I3.PID, I3.TIV_2016 FROM INSURANCE I3 INNER JOIN INSURANCE I4 ON I3.TIV_2015=I4.TIV_2015 WHERE I3.PID<>I4.PID AND I3.PID NOT IN (SELECT I1.PID FROM INSURANCE I1, INSURANCE I2 WHERE I1.LAT = I2.LAT AND I1.LON=I2.LON AND I1.PID<>I2.PID)) AS T;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(*) AS REPORT_COUNT FROM (SELECT EXTRA, POST_ID FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE='2019-07-04' GROUP BY EXTRA, POST_ID) AS RR GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH CTE AS (SELECT CUSTOMER_ID FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS)) SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM CTE GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(A.X - B.X) AS SHORTEST FROM POINT A, POINT B WHERE A.X <> B.X ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(A.X - B.X) AS SHORTEST FROM POINT A, POINT B WHERE ABS(A.X - B.X) > 0 ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT INVOICE_ID, C.CUSTOMER_NAME, PRICE, COUNT(O.CONTACT_NAME) CONTACTS_CNT, COUNT(A.EMAIL) TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS O ON C.CUSTOMER_ID = O. USER_ID LEFT JOIN CUSTOMERS A ON A.EMAIL = O.CONTACT_EMAIL GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME,I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME IN ('S8', 'IPHONE') GROUP BY BUYER_ID HAVING COUNT(DISTINCT PRODUCT_NAME) = 1 AND MAX(PRODUCT_NAME) = 'S8';\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM ( SELECT BUYER_ID, CASE WHEN PRODUCT.PRODUCT_NAME = 'S8' THEN 1 WHEN PRODUCT.PRODUCT_NAME = 'IPHONE' THEN -1 END AS COEFF FROM PRODUCT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID AND ( PRODUCT.PRODUCT_NAME = 'S8' OR PRODUCT.PRODUCT_NAME = 'IPHONE' ) GROUP BY BUYER_ID, PRODUCT.PRODUCT_NAME ) AS SALES_INFO GROUP BY BUYER_ID HAVING SUM(COEFF) = 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT.PRODUCT_ID AS PRODUCT_ID FROM PRODUCT RIGHT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' GROUP BY PRODUCT.PRODUCT_ID );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE ((AREA > 3000000) OR (POPULATION > 25000000));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID GROUP BY BUYER_ID HAVING COUNT(CASE PRODUCT_NAME WHEN 'S8' THEN 1 ELSE NULL END)>=1 AND COUNT(CASE PRODUCT_NAME WHEN 'IPHONE' THEN 1 ELSE NULL END) =0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT P.PRODUCT_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE V.VISIT_ID NOT IN (SELECT T1.VISIT_ID FROM TRANSACTIONS T1) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN ( SELECT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN ( SELECT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT NAME, UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI E1 ON E.ID = E1.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT ROUND(AVG(EXPERIENCE_YEARS),2) AS AVERAGE_YEARS,PROJECT_ID FROM PROJECT ,EMPLOYEE WHERE PROJECT.EMPLOYEE_ID=EMPLOYEE.EMPLOYEE_ID GROUP BY PROJECT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT A.AUTHOR_ID AS ID FROM VIEWS AS A JOIN VIEWS AS B ON A.ARTICLE_ID = B.ARTICLE_ID WHERE A.AUTHOR_ID = B.VIEWER_ID ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID, DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID HAVING COUNT(DIRECTOR_ID) > 2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(UNITS*P.PRICE)/SUM(UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT T1.ACCOUNT_ID FROM LOGINFO T1, LOGINFO T2 WHERE T1.ACCOUNT_ID = T2.ACCOUNT_ID AND T1.IP_ADDRESS <> T2.IP_ADDRESS AND T1.LOGIN < T2.LOGIN AND T1.LOGOUT >= T2.LOGIN;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID,ROUND(SUM(S.UNITS*P.PRICE)/SUM(S.UNITS),2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD S ON P.PRODUCT_ID=S.PRODUCT_ID AND S.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH CTE AS ( SELECT CUSTOMER_ID,AMOUNT FROM ( SELECT V.VISIT_ID,V.CUSTOMER_ID ,T.AMOUNT FROM VISITS V LEFT OUTER JOIN TRANSACTIONS T ON V.VISIT_ID=T.VISIT_ID) A WHERE A.AMOUNT IS NULL ) SELECT CUSTOMER_ID , COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM CTE GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S_ID AS ID,NAME AS NAME FROM( SELECT D.ID AS DEPT_ID,D.NAME AS DEPARTMENT_NAME,S.DEPARTMENT_ID,S.NAME AS NAME,S.ID AS S_ID FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID WHERE D.NAME IS NULL)FHF;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT S.BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' ) AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM (SELECT A.BUYER_ID, SUM(CASE WHEN B.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS IPHONE_SALES, SUM(CASE WHEN B.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS S8_SALES FROM SALES A LEFT JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID GROUP BY A.BUYER_ID) C WHERE IPHONE_SALES = 0 AND S8_SALES >= 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE1 AS (SELECT CT.USER_ID , COUNT(*) CONTACT_CNT, SUM(CASE WHEN C.CUSTOMER_ID IS NOT NULL THEN 1 ELSE 0 END) TRUSTED_CONTACTS_CNT FROM CONTACTS CT LEFT OUTER JOIN CUSTOMERS C ON CT.CONTACT_NAME = C.CUSTOMER_NAME AND CT.CONTACT_EMAIL = C.EMAIL GROUP BY CT.USER_ID ) SELECT I.INVOICE_ID INVOICE_ID,C.CUSTOMER_NAME CUSTOMER_NAME,I.PRICE PRICE ,COALESCE(CTE1.CONTACT_CNT,0) CONTACTS_CNT, COALESCE(CTE1.TRUSTED_CONTACTS_CNT,0)TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT OUTER JOIN CTE1 ON C.CUSTOMER_ID = CTE1.USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT NAME, UNIQUE_ID FROM EMPLOYEEUNI RIGHT JOIN EMPLOYEES ON EMPLOYEEUNI.ID = EMPLOYEES.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT DISTINCT A.EXTRA AS REPORT_REASON, COUNT(A.EXTRA) AS REPORT_COUNT FROM (SELECT DISTINCT POST_ID, ACTION_DATE, ACTION, EXTRA FROM ACTIONS) A WHERE A.ACTION_DATE='2019-07-04' AND A.ACTION='REPORT' GROUP BY A.EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH T1 AS ( SELECT TIV_2015, 1 AS ISSATTIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(PID) >= 2 ), T2 AS ( SELECT LAT, LON, 1 AS ISUNIQUELOC FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(PID) = 1 ) SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE T3 LEFT JOIN T1 ON T3.TIV_2015 = T1.TIV_2015 LEFT JOIN T2 ON T3.LAT = T2.LAT AND T3.LON = T2.LON WHERE T1.ISSATTIV_2015 = 1 AND T2.ISUNIQUELOC = 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM( SELECT CUSTOMER_ID, AMOUNT FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE AMOUNT IS NULL) AS T1 GROUP BY CUSTOMER_ID ORDER BY COUNT_NO_TRANS;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] WITH CTE AS ( SELECT DISTINCT CUSTOMER_ID, SUM(CASE WHEN PRODUCT_NAME IN ('A','B','C') THEN 1 ELSE 0 END) CNT, SUM(CASE WHEN PRODUCT_NAME IN ('A','B') THEN 1 ELSE 0 END) CNT1 FROM ORDERS GROUP BY CUSTOMER_ID HAVING SUM(CASE WHEN PRODUCT_NAME IN ('A','B','C') THEN 1 ELSE 0 END)!=3 AND SUM(CASE WHEN PRODUCT_NAME IN ('A','B') THEN 1 ELSE 0 END)=2 ) SELECT C.CUSTOMER_ID,C.CUSTOMER_NAME FROM CTE C1 INNER JOIN CUSTOMERS C ON C.CUSTOMER_ID=C1.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID, DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY DIRECTOR_ID, ACTOR_ID HAVING COUNT(ACTOR_ID) >2;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH UNIQUE_LOC AS( SELECT * FROM INSURANCE WHERE (LAT, LON) NOT IN ( SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) > 1) ), MULTIPLE_VALUE AS( SELECT * FROM INSURANCE WHERE TIV_2015 IN ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) > 1) ) SELECT ROUND(SUM(TIV_2016), 2) AS TIV_2016 FROM UNIQUE_LOC WHERE PID IN (SELECT PID FROM MULTIPLE_VALUE);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID ORDER BY COUNT(CUSTOMER_ID) DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH TB1 AS ( SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME, COUNT(CON.CONTACT_NAME) AS CONTACTS_CNT, COUNT(C2.CUSTOMER_ID) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS C LEFT JOIN CONTACTS CON ON C.CUSTOMER_ID = CON.USER_ID LEFT JOIN CUSTOMERS C2 ON CON.CONTACT_EMAIL = C2.EMAIL GROUP BY C.CUSTOMER_ID, C.CUSTOMER_NAME ) SELECT I.INVOICE_ID, TB1.CUSTOMER_NAME, I.PRICE, TB1.CONTACTS_CNT, TB1.TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN TB1 ON I.USER_ID = TB1.CUSTOMER_ID ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE POPULATION > 25000000 OR AREA > 3000000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS( SELECT P.PRODUCT_ID, P.PRODUCT_NAME,S.BUYER_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN(SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM TEMP WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE BUYER_ID IN (SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME='S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM PRODUCT WHERE PRODUCT.PRODUCT_ID NOT IN ( SELECT PRODUCT.PRODUCT_ID FROM PRODUCT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID AND (SALES.SALE_DATE < '2019-01-01' OR SALES.SALE_DATE > '2019-03-31') );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM PRODUCT P LEFT JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' AND S.BUYER_ID NOT IN (SELECT S.BUYER_ID FROM PRODUCT P LEFT JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT CLASS FROM ( SELECT DISTINCT CLASS, STUDENT FROM COURSES ) T GROUP BY CLASS HAVING COUNT(CLASS) >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 INNER JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID WHERE L1.LOGIN <> L2.LOGIN AND ((L1.LOGIN BETWEEN L2.LOGIN AND L2.LOGOUT) OR (L1.LOGOUT) BETWEEN L2.LOGIN AND L2.LOGOUT) AND L1.IP_ADDRESS <> L2.IP_ADDRESS;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH X AS (SELECT DISTINCT * FROM VIEWS) SELECT DISTINCT VIEWER_ID AS ID FROM X GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(VIEWER_ID ) >1 ORDER BY ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE S.PRODUCT_ID IN ( SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME IN ('S8','IPHONE') ) GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH BOUGHT_S8 AS (SELECT DISTINCT BUYER_ID, PRODUCT_ID FROM SALES WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'S8')) SELECT BUYER_ID FROM BOUGHT_S8 WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME='IPHONE'));\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT NAME, UNIQUE_ID FROM EMPLOYEES A LEFT JOIN EMPLOYEEUNI B ON A.ID = B.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID , COUNT(*) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T USING (VISIT_ID) WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT A.BUYER_ID FROM SALES A INNER JOIN PRODUCT B ON A.PRODUCT_ID = B.PRODUCT_ID WHERE A.BUYER_ID IN (SELECT C.BUYER_ID FROM SALES C INNER JOIN PRODUCT D ON C.PRODUCT_ID = D.PRODUCT_ID WHERE D.PRODUCT_NAME = 'S8') AND A.BUYER_ID NOT IN (SELECT C.BUYER_ID FROM SALES C INNER JOIN PRODUCT D ON C.PRODUCT_ID = D.PRODUCT_ID WHERE D.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1 INNER JOIN LOGINFO L2 ON L1.ACCOUNT_ID = L2.ACCOUNT_ID WHERE L1.IP_ADDRESS <> L2.IP_ADDRESS AND (L2.LOGIN > L1.LOGIN AND L2.LOGIN <= L1.LOGOUT);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L1.ACCOUNT_ID FROM LOGINFO L1, LOGINFO L2 WHERE L1.ACCOUNT_ID = L2.ACCOUNT_ID AND L1.LOGOUT >= L2.LOGIN AND L1.LOGIN < L2.LOGIN AND L1.IP_ADDRESS <> L2.IP_ADDRESS;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT A.PRODUCT_ID, B.PRODUCT_NAME FROM SALES A, PRODUCT B WHERE A.PRODUCT_ID = B.PRODUCT_ID AND A.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01') GROUP BY A.PRODUCT_ID, B.PRODUCT_NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES LEFT JOIN PRODUCT USING(PRODUCT_ID) GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END ) >0 AND SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) =0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT W.NAME, W.POPULATION, W.AREA FROM WORLD W WHERE W.AREA > 3000000 OR POPULATION > 25000000;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T AS ( SELECT S.BUYER_ID,P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID ) SELECT BUYER_ID FROM T GROUP BY BUYER_ID HAVING BUYER_ID IN (SELECT BUYER_ID FROM T WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM T WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT(P.PRODUCT_ID),P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID=S.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM SALES JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME='S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT T1.PRODUCT_ID, ROUND(SUM((UNITS*PRICE))/SUM(UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD T1 LEFT JOIN PRICES T2 ON T1.PRODUCT_ID = T2.PRODUCT_ID AND (PURCHASE_DATE BETWEEN START_DATE AND END_DATE) GROUP BY T1.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS ( SELECT DISTINCT S.BUYER_ID, S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT DISTINCT BUYER_ID FROM TEMP WHERE PRODUCT_NAME = 'S8') AND BUYER_ID NOT IN (SELECT DISTINCT BUYER_ID FROM TEMP WHERE PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH TEMP AS ( SELECT P.PRODUCT_ID, P.START_DATE, P.END_DATE, P.PRICE, U.PURCHASE_DATE, U.UNITS FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE ) SELECT PRODUCT_ID, ROUND((SUM(PRICE * UNITS) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM TEMP GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID,PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT E.NAME, B.BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE E.EMPID NOT IN (SELECT EMPID FROM BONUS WHERE BONUS>1000);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH CTE AS(SELECT DISTINCT VIEWER_ID, COUNT(DISTINCT ARTICLE_ID) AS CNT FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID) SELECT VIEWER_ID AS ID FROM CTE WHERE CNT > 1 ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE1 AS ( SELECT USER_ID, COUNT(CONTACT_NAME) AS CONTACTS_CNT FROM CONTACTS GROUP BY USER_ID ), CTE2 AS ( SELECT USER_ID, COUNT(CONTACT_NAME) AS TRUSTED_CONTACTS_CNT FROM CONTACTS WHERE CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) GROUP BY USER_ID ) SELECT B.INVOICE_ID, A.CUSTOMER_NAME, B.PRICE , COALESCE(CTE1.CONTACTS_CNT, 0) AS CONTACTS_CNT, COALESCE(CTE2.TRUSTED_CONTACTS_CNT, 0) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CTE1 ON A.CUSTOMER_ID = CTE1.USER_ID LEFT JOIN CTE2 ON A.CUSTOMER_ID = CTE2.USER_ID LEFT JOIN INVOICES B ON A.CUSTOMER_ID = B.USER_ID WHERE B.INVOICE_ID IS NOT NULL ORDER BY B.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable LOGINFO, Columns = [ *, ACCOUNT_ID, IP_ADDRESS, LOGIN, LOGOUT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT I1.ACCOUNT_ID FROM LOGINFO AS I1 JOIN LOGINFO AS I2 ON (I1.ACCOUNT_ID = I2.ACCOUNT_ID AND I1.IP_ADDRESS <> I2.IP_ADDRESS AND I2.LOGIN BETWEEN I1.LOGIN AND I1.LOGOUT);\n[SQL_2] SELECT DISTINCT L.ACCOUNT_ID FROM LOGINFO L JOIN LOGINFO I ON L.ACCOUNT_ID = I.ACCOUNT_ID AND ((I.LOGIN BETWEEN L.LOGIN AND L.LOGOUT) OR (I.LOGOUT BETWEEN L.LOGIN AND L.LOGOUT)) AND I.LOGIN <> L.LOGIN AND I.LOGOUT <> L.LOGOUT AND I.IP_ADDRESS <> L.IP_ADDRESS;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH CTE AS (SELECT COMPANY_ID, (CASE WHEN MAX(SALARY) > 10000 THEN 0.49 WHEN MAX(SALARY) < 1000 THEN 0 WHEN 1000 < MAX(SALARY) AND MAX(SALARY)<10000 THEN 0.24 ELSE NULL END ) AS TAX FROM SALARIES GROUP BY COMPANY_ID) SELECT S1.COMPANY_ID, S1.EMPLOYEE_ID, S1.EMPLOYEE_NAME, ROUND(S1.SALARY*(1-TAX), 0)AS SALARY FROM SALARIES S1 JOIN CTE ON S1.COMPANY_ID = CTE.COMPANY_ID ORDER BY COMPANY_ID ASC, EMPLOYEE_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT UNITSSOLD.PRODUCT_ID, ROUND(SUM(UNITS*PRICE)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD LEFT JOIN PRICES ON PRICES.PRODUCT_ID = UNITSSOLD.PRODUCT_ID AND PURCHASE_DATE >= START_DATE AND PURCHASE_DATE <= END_DATE GROUP BY UNITSSOLD.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TEMP AS (SELECT * FROM SALES LEFT JOIN PRODUCT USING (PRODUCT_ID)) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID NOT IN (SELECT TEMP.BUYER_ID FROM TEMP WHERE PRODUCT_NAME='IPHONE' ) AND BUYER_ID IN (SELECT TEMP.BUYER_ID FROM TEMP WHERE PRODUCT_NAME='S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH F AS ( SELECT CASE WHEN USER1_ID<USER2_ID THEN USER1_ID ELSE USER2_ID END AS USER1_ID, CASE WHEN USER1_ID<USER2_ID THEN USER2_ID ELSE USER1_ID END AS USER2_ID FROM FRIENDSHIP) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM F JOIN LIKES L ON F.USER2_ID = L.USER_ID WHERE USER1_ID = 1 AND PAGE_ID NOT IN ( SELECT DISTINCT PAGE_ID FROM LIKES L WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE*U.UNITS)/SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES AS P LEFT JOIN UNITSSOLD AS U ON P.PRODUCT_ID=U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, T1.CUSTOMER_NAME, I.PRICE, T1.CONTACTS_CNT, T1.TRUSTED_CONTACTS_CNT FROM INVOICES I JOIN ( SELECT CU.CUSTOMER_ID, CU.CUSTOMER_NAME, COUNT(CO.CONTACT_NAME) AS CONTACTS_CNT, COUNT(CASE WHEN CO.CONTACT_NAME IN (SELECT DISTINCT CUSTOMER_NAME FROM CUSTOMERS) THEN 1 ELSE NULL END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS CU LEFT JOIN CONTACTS CO ON CU.CUSTOMER_ID = CO.USER_ID GROUP BY CU.CUSTOMER_ID, CU.CUSTOMER_NAME ) T1 ON I.USER_ID = T1.CUSTOMER_ID ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T USING(VISIT_ID) WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(PRICE*UNITS) / SUM(UNITS),2) AS AVERAGE_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH S8_TAB AS ( SELECT BUYER_ID FROM SALES SALES LEFT JOIN PRODUCT PROD ON SALES.PRODUCT_ID = PROD.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' ), IPHONE_TAB AS ( SELECT BUYER_ID FROM SALES SALES LEFT JOIN PRODUCT PROD ON SALES.PRODUCT_ID = PROD.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE' ) SELECT DISTINCT(BUYER_ID) FROM SALES WHERE BUYER_ID IN (SELECT * FROM S8_TAB) AND BUYER_ID NOT IN (SELECT * FROM IPHONE_TAB);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT P.PRODUCT_ID, ROUND(SUM(U.UNITS * P.PRICE) / SUM(U.UNITS),2) AS AVERAGE_PRICE FROM PRICES AS P LEFT JOIN UNITSSOLD AS U ON (P.PRODUCT_ID = U.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) GROUP BY P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT DISTINCT ID, NAME FROM (SELECT S.*, D.NAME AS DEP_NAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID ) TEMP WHERE DEP_NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT P1.X - P2.X AS SHORTEST FROM POINT P1 JOIN POINT P2 ON P1.X > P2.X ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(UNITS*PRICE)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID=P.PRODUCT_ID AND PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T1 AS ( SELECT * FROM SALES JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'S8'), T2 AS ( SELECT * FROM SALES JOIN PRODUCT USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'IPHONE') SELECT DISTINCT T1.BUYER_ID FROM T1 LEFT JOIN T2 USING(BUYER_ID) WHERE T2.SELLER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE SALES.PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'S8' OR PRODUCT_NAME = 'IPHONE') GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS ( SELECT BUYER_ID FROM PRODUCT P INNER JOIN SALES S ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME='S8'), CTE2 AS ( SELECT BUYER_ID FROM PRODUCT P INNER JOIN SALES S ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME='IPHONE') SELECT DISTINCT A.BUYER_ID FROM CTE A LEFT JOIN CTE2 B ON A.BUYER_ID=B.BUYER_ID WHERE B.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM (SELECT * FROM ACTIONS WHERE EXTRA IS NOT NULL AND ACTION = 'REPORT') AS TEMP WHERE ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH S8_BUYERS AS (SELECT DISTINCT S.BUYER_ID, S.PRODUCT_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8') SELECT BUYER_ID FROM S8_BUYERS WHERE BUYER_ID NOT IN (SELECT S.BUYER_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT DISTINCT(EMAIL) FROM ( SELECT EMAIL, COUNT(ID) AS CNT FROM PERSON GROUP BY EMAIL ) AS TB1 WHERE CNT > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH NON_SPRING AS ( SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' ) SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM NON_SPRING );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT P.EMAIL FROM PERSON P GROUP BY P.EMAIL HAVING COUNT(*) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEWER_ID, VIEW_DATE HAVING COUNT(VIEWER_ID) > 1 AND COUNT(DISTINCT ARTICLE_ID) > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT.PRODUCT_ID FROM PRODUCT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN (SELECT DISTINCT S.PRODUCT_ID FROM SALES S WHERE S.SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.VIEWER_ID AS ID FROM VIEWS V1 JOIN VIEWS V2 ON V1.VIEWER_ID = V2.VIEWER_ID AND V1.ARTICLE_ID != V2.ARTICLE_ID AND V1.VIEW_DATE = V2.VIEW_DATE ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM INSURANCE WHERE (LAT, LON) NOT IN(SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) > 1) AND TIV_2015 IN(SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(TIV_2015) > 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND EXTRA IS NOT NULL AND ACTION = 'REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEE, Columns = [ *, EMPID, NAME, SUPERVISOR, SALARY ]\nTable BONUS, Columns = [ *, EMPID, BONUS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMPLOYEE.NAME, BONUS.BONUS FROM EMPLOYEE LEFT JOIN BONUS ON EMPLOYEE.EMPID = BONUS.EMPID WHERE BONUS < 1000 OR BONUS IS NULL;\n[SQL_2] SELECT NAME, BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE BONUS <1000 UNION SELECT NAME, BONUS FROM EMPLOYEE E LEFT JOIN BONUS B ON E.EMPID = B.EMPID WHERE BONUS IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE (LAT, LON) IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) = 1) AND TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(TIV_2015) > 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID=T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT (P1.X - P2.X) AS SHORTEST FROM POINT P1, POINT P2 WHERE P1.X > P2.X ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT A.EMAIL FROM ( SELECT EMAIL , COUNT(*) AS EMAIL_COUNT FROM PERSON GROUP BY EMAIL ) A WHERE A.EMAIL_COUNT > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT DISTINCT PRODUCT.PRODUCT_ID FROM PRODUCT LEFT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE SALE_DATE > '2019-03-31' OR SALE_DATE < '2019-01-01');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM (SELECT EMAIL,COUNT(*) AS NUM FROM PERSON GROUP BY EMAIL)P WHERE P.NUM>1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(EXTRA) AS REPORT_COUNT FROM (SELECT DISTINCT POST_ID , ACTION_DATE , ACTION , EXTRA FROM ACTIONS) AS X WHERE ACTION_DATE = '2019-07-04' AND ACTION='REPORT' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(TIV_2015)>1) AND (LAT, LON) IN ( SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(PID)=1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(*) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS USING (VISIT_ID) WHERE AMOUNT IS NULL GROUP BY CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V WHERE V.VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID,COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISITS.VISIT_ID FROM VISITS INNER JOIN TRANSACTIONS ON VISITS.VISIT_ID=TRANSACTIONS.VISIT_ID ) GROUP BY (CUSTOMER_ID);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH CTE AS (SELECT DISTINCT SALES.BUYER_ID AS BUYER_IPHONE FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE') , CTE1 AS( SELECT DISTINCT SALES.BUYER_ID AS BUYER_S8 FROM SALES LEFT JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8') SELECT CTE1.BUYER_S8 AS BUYER_ID FROM CTE1 LEFT JOIN CTE ON CTE.BUYER_IPHONE = CTE1.BUYER_S8 WHERE BUYER_IPHONE IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND( SUM( CASE WHEN U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE THEN P.PRICE ELSE 0 END * U.UNITS) / SUM(CASE WHEN U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE THEN U.UNITS ELSE 0 END) ,2) AS AVERAGE_PRICE FROM PRICES P, UNITSSOLD U WHERE U.PRODUCT_ID = P.PRODUCT_ID GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT DISTINCT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(CLASS)>=5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V WHERE V.VISIT_ID NOT IN (SELECT V.VISIT_ID FROM VISITS AS V JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID) GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PROJECT, Columns = [ *, PROJECT_ID, EMPLOYEE_ID ]\nTable EMPLOYEE, Columns = [ *, EMPLOYEE_ID, NAME, EXPERIENCE_YEARS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PROJECT_ID, ROUND(AVG(B.EXPERIENCE_YEARS), 2) AS AVERAGE_YEARS FROM PROJECT AS A INNER JOIN EMPLOYEE AS B ON A.EMPLOYEE_ID = B.EMPLOYEE_ID GROUP BY A.PROJECT_ID;\n[SQL_2] SELECT PROJECT_ID, ROUND(SUM(EXPERIENCE_YEARS)/COUNT(NAME),2) AS AVERAGE_YEARS FROM PROJECT P JOIN EMPLOYEE E ON P.EMPLOYEE_ID=E.EMPLOYEE_ID GROUP BY PROJECT_ID ORDER BY PROJECT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT T.PRODUCT_ID, ROUND((SUM(T.PRICE*U.UNITS))/SUM(U.UNITS), 2) AS AVERAGE_PRICE FROM PRICES T LEFT JOIN UNITSSOLD U ON T.PRODUCT_ID = U.PRODUCT_ID AND T.START_DATE <= U.PURCHASE_DATE AND T.END_DATE >= U.PURCHASE_DATE GROUP BY T.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH JOIN_LOC AS ( SELECT DISTINCT L.PID, L.TIV_2015, L.TIV_2016 FROM INSURANCE L LEFT JOIN INSURANCE R ON L.PID != R.PID AND L.LAT = R.LAT AND L.LON = R.LON WHERE R.PID IS NULL ), JOIN_2015 AS ( SELECT DISTINCT L.PID, L.TIV_2016 FROM JOIN_LOC L INNER JOIN INSURANCE R ON L.PID != R.PID AND L.TIV_2015 = R.TIV_2015 WHERE R.TIV_2015 IS NOT NULL ) SELECT SUM(TIV_2016) AS TIV_2016 FROM JOIN_2015;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM PRODUCT P LEFT JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND S.BUYER_ID NOT IN (SELECT DISTINCT S.BUYER_ID FROM PRODUCT P LEFT JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH FRIENDS1 AS ( SELECT USER1_ID AS USER1, USER2_ID AS USER2 FROM FRIENDSHIP UNION SELECT USER2_ID AS USER1, USER1_ID AS USER2 FROM FRIENDSHIP ), FRIENDS2 AS ( SELECT DISTINCT USER1, USER2 FROM FRIENDS1 WHERE USER2 > USER1 ORDER BY USER1, USER2 ) SELECT DISTINCT L.PAGE_ID AS RECOMMENDED_PAGE FROM LIKES AS L JOIN FRIENDS2 AS F ON L.USER_ID = F.USER2 WHERE F.USER1 = 1 AND L.PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRICES.PRODUCT_ID, ROUND(SUM(UNITSSOLD.UNITS * PRICES.PRICE) / SUM(UNITSSOLD.UNITS), 2) AS AVERAGE_PRICE FROM PRICES LEFT JOIN UNITSSOLD ON PRICES.PRODUCT_ID = UNITSSOLD.PRODUCT_ID AND UNITSSOLD.PURCHASE_DATE BETWEEN PRICES.START_DATE AND PRICES.END_DATE GROUP BY PRICES.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT(BUYER_ID) FROM SALES WHERE BUYER_ID IN (SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME='S8' ) AND BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME='IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT PERSON.EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(*)>1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT NAME , UNIQUE_ID FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EU ON E.ID = EU.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT P.PRODUCT_ID FROM PRODUCT AS P JOIN SALES AS S ON S.PRODUCT_ID = P.PRODUCT_ID WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(A.X-B.X) SHORTEST FROM POINT A, POINT B WHERE A.X != B.X ORDER BY ABS(A.X-B.X) LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN( SELECT BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID =P.PRODUCT_ID WHERE PRODUCT_NAME ='S8') AND BUYER_ID NOT IN(SELECT BUYER_ID FROM SALES AS S JOIN PRODUCT AS P ON S.PRODUCT_ID =P.PRODUCT_ID WHERE PRODUCT_NAME ='IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT BUYER_ID FROM SALES INNER JOIN PRODUCT ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE SALES.PRODUCT_ID IN (SELECT PRODUCT_ID FROM PRODUCT WHERE PRODUCT_NAME = 'S8' OR PRODUCT_NAME = 'IPHONE') GROUP BY BUYER_ID HAVING SUM(CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT AS P WHERE P.PRODUCT_ID NOT IN ( SELECT DISTINCT PRO.PRODUCT_ID FROM PRODUCT AS PRO INNER JOIN SALES AS S ON PRO.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE < '2019-01-01' OR S.SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE > CAST('2019-03-31' AS DATE) OR SALE_DATE < CAST('2019-01-01' AS DATE) );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT A.INVOICE_ID, A.CUSTOMER_NAME, A.PRICE, A.CONTACTS_CNT, COALESCE(B.TRUSTED_CONTACTS_CNT, 0) TRUSTED_CONTACTS_CNT FROM (SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE, COUNT(CO.CONTACT_NAME) CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID = C.CUSTOMER_ID LEFT JOIN CONTACTS CO ON I.USER_ID = CO.USER_ID GROUP BY I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE) A LEFT JOIN (SELECT I.INVOICE_ID, COUNT(C.CONTACT_NAME) TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CONTACTS C ON I.USER_ID = C.USER_ID WHERE C.CONTACT_NAME IN (SELECT CUSTOMER_NAME FROM CUSTOMERS) GROUP BY I.INVOICE_ID) B ON A.INVOICE_ID = B.INVOICE_ID ORDER BY A.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(CUSTOMER_ID)COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID ORDER BY COUNT_NO_TRANS DESC, CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES AS S INNER JOIN PRODUCT AS P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME ='S8' AND BUYER_ID NOT IN (SELECT S.BUYER_ID FROM PRODUCT AS P INNER JOIN SALES AS S ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE ');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT S.ID, S.NAME FROM STUDENTS AS S LEFT JOIN DEPARTMENTS D ON D.ID = S.DEPARTMENT_ID WHERE D.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] WITH SALES_NOT_1Q_2022 AS ( SELECT S.* FROM SALES S WHERE S.SALE_DATE <'2019-01-01' OR S.SALE_DATE > '2019-03-31' ) SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES_NOT_1Q_2022);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH S8 AS ( SELECT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8' ) , IPHONE AS ( SELECT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE' ) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM S8 ) AND BUYER_ID NOT IN (SELECT BUYER_ID FROM IPHONE );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] WITH TABLE1 AS (SELECT CASE WHEN USER2_ID > USER1_ID THEN USER1_ID ELSE USER2_ID END AS USER1_ID, CASE WHEN USER2_ID < USER1_ID THEN USER1_ID ELSE USER2_ID END AS USER2_ID FROM FRIENDSHIP ORDER BY 1) ,TABLE2 AS (SELECT USER_ID, PAGE_ID FROM LIKES WHERE USER_ID IN (SELECT USER2_ID FROM TABLE1 WHERE USER1_ID = 1)), TABLE3 AS (SELECT USER_ID, PAGE_ID FROM LIKES WHERE USER_ID = 1) SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM TABLE2 WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM TABLE3);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT DISTINCT CUSTOMER_ID, COUNT(CUSTOMER_ID) COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(U.UNITS*P.PRICE)/SUM(UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID=P.PRODUCT_ID AND (U.PURCHASE_DATE BETWEEN P.START_DATE AND P.END_DATE) GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] WITH T1 AS ( SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME ), T2 AS ( SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME ) SELECT T1.DATE_ID, T1.MAKE_NAME, UNIQUE_LEADS, UNIQUE_PARTNERS FROM T1, T2 WHERE T1.DATE_ID = T2.DATE_ID AND T1.MAKE_NAME = T2.MAKE_NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON T.VISIT_ID = V.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT BUYER_ID FROM SALES S JOIN PRODUCT P USING(PRODUCT_ID) WHERE PRODUCT_NAME='S8') AND BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S JOIN PRODUCT P USING(PRODUCT_ID) WHERE PRODUCT_NAME='IPHONE');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT COURSES.CLASS FROM COURSES GROUP BY COURSES.CLASS HAVING COUNT(DISTINCT STUDENT) >= 4;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH TMP_TABLE1 AS (SELECT EMAIL FROM CUSTOMERS) SELECT INVOICE_ID, MAX(CUSTOMER_NAME) AS CUSTOMER_NAME, MAX(PRICE) AS PRICE, COUNT(DISTINCT(CONTACT_EMAIL)) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT * FROM TMP_TABLE1) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM ( SELECT A.INVOICE_ID, B.CUSTOMER_NAME, A.PRICE, C.CONTACT_EMAIL FROM INVOICES A LEFT JOIN CUSTOMERS B ON A.USER_ID = B.CUSTOMER_ID LEFT JOIN CONTACTS C ON B.CUSTOMER_ID = C.USER_ID ) D GROUP BY INVOICE_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH CTE AS ( SELECT P.PRODUCT_ID, UNITS, UNITS*PRICE AS TOT_PRICE FROM PRICES P LEFT JOIN UNITSSOLD U ON P.PRODUCT_ID = U.PRODUCT_ID AND PURCHASE_DATE BETWEEN START_DATE AND END_DATE) SELECT PRODUCT_ID, ROUND(SUM(TOT_PRICE)/SUM(UNITS),2) AS AVERAGE_PRICE FROM CTE GROUP BY PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE T.VISIT_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] WITH TRAN_PER_VISIT AS ( SELECT VISIT_ID, SUM(AMOUNT) AS TOTAL_AMOUNT FROM TRANSACTIONS GROUP BY VISIT_ID ), VISITS_TRANS AS ( SELECT A.*, B.TOTAL_AMOUNT FROM VISITS AS A LEFT JOIN TRAN_PER_VISIT AS B ON A.VISIT_ID = B.VISIT_ID ) SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS_TRANS WHERE TOTAL_AMOUNT IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT T3.* FROM ( SELECT T1.CUSTOMER_ID, CNT1, CNT2 FROM ( SELECT CUSTOMER_ID, COUNT(DISTINCT ORDER_ID) AS CNT1 FROM ORDERS WHERE PRODUCT_NAME IN ('A','B') GROUP BY CUSTOMER_ID )T1 LEFT JOIN ( SELECT CUSTOMER_ID, COUNT(DISTINCT ORDER_ID) AS CNT2 FROM ORDERS WHERE PRODUCT_NAME IN ('C') GROUP BY CUSTOMER_ID )T2 ON T1.CUSTOMER_ID = T2.CUSTOMER_ID WHERE CNT1 >=2 )T INNER JOIN ( SELECT * FROM CUSTOMERS )T3 ON T.CUSTOMER_ID = T3.CUSTOMER_ID WHERE CNT2 IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTORDIRECTOR, Columns = [ *, TIMESTAMP, ACTOR_ID, DIRECTOR_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ACTOR_ID,DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID,DIRECTOR_ID HAVING COUNT(*)>=3;\n[SQL_2] SELECT ACTOR_ID, DIRECTOR_ID FROM ACTORDIRECTOR GROUP BY ACTOR_ID, DIRECTOR_ID HAVING COUNT(ACTOR_ID) >= 3 AND COUNT(DIRECTOR_ID) >= 3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.AUTHOR_ID AS ID FROM VIEWS V1, VIEWS V2 WHERE V1.ARTICLE_ID = V2.ARTICLE_ID AND V1.AUTHOR_ID = V2.VIEWER_ID ORDER BY V1.AUTHOR_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION_DATE = '2019-07-04' AND ACTION = 'REPORT' AND EXTRA IS NOT NULL GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, MIN(CU.CUSTOMER_NAME) AS CUSTOMER_NAME, MIN(I.PRICE) AS PRICE, COUNT(C.CONTACT_NAME) AS CONTACTS_CNT, COUNT(CU2.EMAIL) AS TRUSTED_CONTACTS_CNT FROM INVOICES AS I LEFT JOIN CUSTOMERS AS CU ON I.USER_ID = CU.CUSTOMER_ID LEFT JOIN CONTACTS AS C ON I.USER_ID = C.USER_ID LEFT JOIN CUSTOMERS AS CU2 ON C.CONTACT_NAME = CU2.CUSTOMER_NAME GROUP BY I.INVOICE_ID ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT VIEWER_ID AS ID FROM (SELECT * FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID, ARTICLE_ID, AUTHOR_ID) AS TB1 GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(VIEWER_ID) > 1 ORDER BY VIEWER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL FROM (SELECT EMAIL,COUNT(*) AS CNT FROM PERSON GROUP BY EMAIL)TEMP WHERE TEMP.CNT > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH BIG_TABLE AS ( SELECT P.PRODUCT_NAME, S.PRODUCT_ID, S.BUYER_ID FROM PRODUCT P JOIN SALES S ON P.PRODUCT_ID = S.PRODUCT_ID ), S8 AS ( SELECT BUYER_ID FROM BIG_TABLE WHERE PRODUCT_NAME = 'S8' ), IPHONES AS ( SELECT BUYER_ID FROM BIG_TABLE WHERE PRODUCT_NAME = 'IPHONE' ) SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID IN (SELECT * FROM S8) AND BUYER_ID NOT IN (SELECT * FROM IPHONES);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) >= 2) AND (LAT, LON) NOT IN (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) >= 2);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH MAXSAL (COMPANY_ID , MSALARY) AS ( SELECT COMPANY_ID, MAX(SALARY) FROM SALARIES GROUP BY COMPANY_ID ) SELECT COMPANY_ID,EMPLOYEE_ID,EMPLOYEE_NAME, CASE WHEN MSALARY>1000 AND MSALARY<10000 THEN ROUND((SALARY*76)/100) WHEN MSALARY>10000 THEN ROUND((SALARY*51)/100) ELSE SALARY END AS SALARY FROM (SELECT SALARIES.COMPANY_ID,SALARIES.EMPLOYEE_ID,SALARIES.EMPLOYEE_NAME, SALARIES.SALARY,MAXSAL.MSALARY FROM SALARIES,MAXSAL WHERE MAXSAL.COMPANY_ID=SALARIES.COMPANY_ID)T;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH MAX_SAL AS ( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SAL FROM SALARIES GROUP BY COMPANY_ID ), TAX_RATE AS ( SELECT COMPANY_ID, CASE WHEN MAX_SAL < 1000 THEN 0 WHEN MAX_SAL > 1000 AND MAX_SAL < 10000 THEN 24/100 WHEN MAX_SAL > 10000 THEN 49/100 END AS TAX_RATE FROM MAX_SAL ) SELECT E.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY - SALARY*TAX_RATE) AS SALARY FROM SALARIES E JOIN TAX_RATE T ON E.COMPANY_ID = T.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, C1.CUSTOMER_NAME, I.PRICE, COUNT(C2.CONTACT_NAME) AS CONTACTS_CNT, COUNT(C3.CUSTOMER_NAME) AS TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN CUSTOMERS C1 ON I.USER_ID = C1.CUSTOMER_ID LEFT JOIN CONTACTS C2 ON C1.CUSTOMER_ID = C2.USER_ID LEFT JOIN CUSTOMERS C3 ON C2.CONTACT_NAME = C3.CUSTOMER_NAME GROUP BY I.INVOICE_ID, C1.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] WITH T1 AS ( SELECT P.PRODUCT_ID, SUM(UNITS*PRICE) AS TOTAL_PRICE FROM UNITSSOLD AS U JOIN PRICES AS P ON PURCHASE_DATE BETWEEN START_DATE AND END_DATE AND U.PRODUCT_ID=P.PRODUCT_ID GROUP BY P.PRODUCT_ID), T2 AS (SELECT PRODUCT_ID, SUM(UNITS) AS TOTAL_UNITS FROM UNITSSOLD GROUP BY PRODUCT_ID) SELECT T1.PRODUCT_ID, ROUND(TOTAL_PRICE/TOTAL_UNITS,2) AS AVERAGE_PRICE FROM T1 JOIN T2 USING(PRODUCT_ID);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT E1.NAME, E2.UNIQUE_ID FROM EMPLOYEEUNI E2 RIGHT JOIN EMPLOYEES E1 ON E1.ID = E2.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE BUYER_ID IN (SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME ='S8' ) AND BUYER_ID NOT IN (SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE P.PRODUCT_NAME ='IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT B.BUYER_ID FROM ( SELECT A.BUYER_ID , SUM(CASE WHEN A.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) AS S8 , SUM(CASE WHEN A.PRODUCT_NAME = 'G4' THEN 1 ELSE 0 END) AS G4 , SUM(CASE WHEN A.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) AS IPHONE FROM (SELECT S.BUYER_ID , P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID) A GROUP BY A.BUYER_ID) B WHERE B.S8 >= 1 AND B.IPHONE = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE AS ( SELECT I.INVOICE_ID , C.CUSTOMER_NAME , USER_ID , I.PRICE FROM INVOICES I JOIN CUSTOMERS C ON C.CUSTOMER_ID = I.USER_ID ), CTE2 AS( SELECT USER_ID , COUNT(DISTINCT CONTACT_NAME ) AS CONTACTS_CNT ,COUNT(DISTINCT CUSTOMER_NAME ) AS TRUSTED_CONTACTS_CNT FROM CONTACTS C LEFT JOIN CUSTOMERS CU ON C.CONTACT_NAME = CU.CUSTOMER_NAME GROUP BY USER_ID ) SELECT INVOICE_ID,CUSTOMER_NAME,PRICE,COALESCE (CONTACTS_CNT,0) AS CONTACTS_CNT,COALESCE (TRUSTED_CONTACTS_CNT,0) AS TRUSTED_CONTACTS_CNT FROM CTE LEFT JOIN CTE2 USING(USER_ID) ORDER BY INVOICE_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ( SELECT EXTRA,POST_ID FROM ACTIONS WHERE ACTION_DATE='2019-07-04' AND EXTRA IS NOT NULL AND ACTION='REPORT' ) AS AAA GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT ID, SNAME AS NAME FROM ( SELECT S.ID, S.NAME AS SNAME, D.NAME AS DNAME FROM STUDENTS S LEFT JOIN DEPARTMENTS D ON S.DEPARTMENT_ID = D.ID ) AS LJT WHERE DNAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE (PRODUCT_ID, PRODUCT_NAME) NOT IN ( SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S JOIN PRODUCT P ON P.PRODUCT_ID = S.PRODUCT_ID WHERE S.SALE_DATE < '2019-01-01' OR S.SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S1.BUYER_ID FROM PRODUCT P1 LEFT JOIN SALES S1 ON P1.PRODUCT_ID = S1.PRODUCT_ID WHERE P1.PRODUCT_NAME = 'S8' AND S1.BUYER_ID NOT IN ( SELECT DISTINCT S1.BUYER_ID FROM PRODUCT P1 LEFT JOIN SALES S1 ON P1.PRODUCT_ID = S1.PRODUCT_ID WHERE P1.PRODUCT_NAME = 'IPHONE' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE AS (SELECT I.INVOICE_ID, C.CUSTOMER_NAME, I.PRICE,CON.USER_ID AS CONTACT_ID , CON.CONTACT_NAME CONTACT_NAME FROM INVOICES I LEFT JOIN CUSTOMERS C ON I.USER_ID=C.CUSTOMER_ID LEFT JOIN CONTACTS CON ON I.USER_ID=CON.USER_ID ), CTE_1 AS (SELECT A.INVOICE_ID, A.CUSTOMER_NAME, A.PRICE, A.CONTACT_NAME CONTACT_NAME, B.CUSTOMER_NAME AS TRUSTED_CONTACT FROM CTE A LEFT JOIN CUSTOMERS B ON A.CONTACT_NAME=B.CUSTOMER_NAME ORDER BY INVOICE_ID ) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, COUNT(CONTACT_NAME) AS CONTACTS_CNT, COUNT(TRUSTED_CONTACT) AS TRUSTED_CONTACTS_CNT FROM CTE_1 GROUP BY INVOICE_ID, CUSTOMER_NAME, PRICE ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT.PRODUCT_ID FROM PRODUCT JOIN SALES ON PRODUCT.PRODUCT_ID = SALES.PRODUCT_ID WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID , COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DEPARTMENTS, Columns = [ *, ID, NAME ]\nTable STUDENTS, Columns = [ *, ID, NAME, DEPARTMENT_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ID, NAME FROM STUDENTS WHERE DEPARTMENT_ID NOT IN (SELECT ID FROM DEPARTMENTS);\n[SQL_2] SELECT DISTINCT STUDENTS.ID AS ID, STUDENTS.NAME AS NAME FROM STUDENTS LEFT JOIN DEPARTMENTS ON STUDENTS.DEPARTMENT_ID = DEPARTMENTS.ID WHERE DEPARTMENTS.NAME IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE (AREA > 3000000 OR POPULATION > 25000000);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT I.INVOICE_ID, CUST.CUSTOMER_NAME, I.PRICE, SUM(CASE WHEN C.USER_ID IS NOT NULL THEN 1 ELSE 0 END) AS CONTACTS_CNT, SUM(CASE WHEN CONT_CUST.CUSTOMER_ID IS NOT NULL THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM INVOICES I INNER JOIN CUSTOMERS CUST ON I.USER_ID = CUST.CUSTOMER_ID LEFT JOIN CONTACTS C ON I.USER_ID = C.USER_ID LEFT JOIN CUSTOMERS CONT_CUST ON C.CONTACT_EMAIL = CONT_CUST.EMAIL GROUP BY I.INVOICE_ID, CUST.CUSTOMER_NAME, I.PRICE ORDER BY I.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID AS CUSTOMER_ID , COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE P.PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] SELECT S.COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, ROUND(SALARY * T1.TAX_PCT/100,0) AS SALARY FROM ( SELECT COMPANY_ID, CASE WHEN MAX_SALARY < 1000 THEN 100 WHEN MAX_SALARY >1000 AND MAX_SALARY<10000 THEN 76 WHEN MAX_SALARY > 10000 THEN 51 ELSE 0 END AS TAX_PCT FROM ( SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID ) T ) T1 JOIN SALARIES S ON T1.COMPANY_ID=S.COMPANY_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT A.INVOICE_ID,B.CUSTOMER_NAME,A.PRICE,COUNT(C.CONTACT_NAME) AS CONTACTS_CNT, COUNT(D.CUSTOMER_NAME) AS TRUSTED_CONTACTS_CNT FROM INVOICES A JOIN CUSTOMERS B ON A.USER_ID=B.CUSTOMER_ID LEFT JOIN CONTACTS C ON B.CUSTOMER_ID=C.USER_ID LEFT JOIN CUSTOMERS D ON C.CONTACT_NAME=D.CUSTOMER_NAME GROUP BY A.INVOICE_ID,B.CUSTOMER_NAME,A.PRICE ORDER BY A.INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT P.PRODUCT_ID,P.PRODUCT_NAME FROM PRODUCT AS P WHERE P.PRODUCT_ID NOT IN (SELECT S.PRODUCT_ID FROM SALES AS S WHERE SALE_DATE<'2019-01-01' OR SALE_DATE>='2019-04-01' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(PRICE*UNITS)/SUM(UNITS),2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID = P.PRODUCT_ID AND U.PURCHASE_DATE BETWEEN START_DATE AND END_DATE GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) >= 1 AND SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE') AND BUYER_ID IN (SELECT BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON T.VISIT_ID = V.VISIT_ID WHERE T.TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID, COUNT(VISITS.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE AMOUNT IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 NOT IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)=1) AND (LAT,LON) NOT IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*)>1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT DISTINCT V1.AUTHOR_ID AS ID FROM VIEWS V1, VIEWS V2 WHERE V1.AUTHOR_ID=V2.VIEWER_ID AND V1.ARTICLE_ID=V2.ARTICLE_ID ORDER BY V1.AUTHOR_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016 FROM INSURANCE WHERE PID NOT IN (SELECT DISTINCT A.PID FROM INSURANCE A JOIN INSURANCE B ON A.PID != B.PID AND A.LAT = B.LAT AND A.LON = B.LON) AND PID IN (SELECT DISTINCT A.PID FROM INSURANCE A JOIN INSURANCE B ON A.PID != B.PID AND A.TIV_2015 = B.TIV_2015);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V LEFT JOIN TRANSACTIONS T ON V.VISIT_ID = T.VISIT_ID WHERE TRANSACTION_ID IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA AS REPORT_REASON, COUNT(EXTRA) AS REPORT_COUNT FROM (SELECT DISTINCT POST_ID,EXTRA FROM ACTIONS WHERE ACTION_DATE='2019-07-04' AND ACTION='REPORT' )A GROUP BY A.EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT T.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P JOIN ( SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' ) ) AS T ON T.PRODUCT_ID = P.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T AS ( SELECT BUYER_ID, CASE WHEN PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END AS S8_FLAG, CASE WHEN PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END AS IPHONE_FLAG FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID ) SELECT BUYER_ID FROM T GROUP BY BUYER_ID HAVING SUM(S8_FLAG) > 0 AND SUM(IPHONE_FLAG) =0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT V.CUSTOMER_ID, COUNT(V.VISIT_ID) AS COUNT_NO_TRANS FROM VISITS AS V LEFT JOIN TRANSACTIONS AS T ON V.VISIT_ID = T.VISIT_ID WHERE T.AMOUNT IS NULL GROUP BY V.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT S.BUYER_ID FROM (SELECT S.PRODUCT_ID,PRODUCT_NAME,BUYER_ID FROM SALES S JOIN PRODUCT P USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'S8') S LEFT JOIN (SELECT S.PRODUCT_ID,PRODUCT_NAME,BUYER_ID FROM SALES S JOIN PRODUCT P USING(PRODUCT_ID) WHERE PRODUCT_NAME = 'IPHONE') I USING(BUYER_ID) WHERE I.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(B.X - A.X) AS SHORTEST FROM POINT A JOIN POINT B ON A.X!=B.X ORDER BY SHORTEST ASC LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT S.PRODUCT_ID, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID WHERE SALE_DATE < '2019-03-31' AND SALE_DATE > '2019-01-01' AND S.PRODUCT_ID NOT IN ( SELECT DISTINCT PRODUCT_ID FROM SALES WHERE SALE_DATE NOT BETWEEN '2019-01-01' AND '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME ]\nTable ORDERS, Columns = [ *, ORDER_ID, CUSTOMER_ID, PRODUCT_NAME ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, CUSTOMER_NAME FROM CUSTOMERS WHERE CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'A') AND CUSTOMER_ID IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'B') AND CUSTOMER_ID NOT IN (SELECT DISTINCT CUSTOMER_ID FROM ORDERS WHERE PRODUCT_NAME = 'C') ORDER BY CUSTOMER_ID;\n[SQL_2] SELECT A.CUSTOMER_ID, B.CUSTOMER_NAME FROM (SELECT CUSTOMER_ID, SUM(CASE WHEN PRODUCT_NAME='A' THEN 1 WHEN PRODUCT_NAME='B' THEN 10 WHEN PRODUCT_NAME='C' THEN 100 ELSE 0 END) AS PRODUCT_SCORE FROM ORDERS GROUP BY CUSTOMER_ID ) A LEFT JOIN CUSTOMERS B ON A.CUSTOMER_ID=B.CUSTOMER_ID WHERE A.PRODUCT_SCORE=11;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT NAME, UNIQUE_ID FROM EMPLOYEES LEFT OUTER JOIN EMPLOYEEUNI ON EMPLOYEES.ID = EMPLOYEEUNI.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH VALID_TIV15 AS (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) != 1), VALID_LATLON AS (SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(*) = 1) SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE AS I INNER JOIN VALID_LATLON AS V ON I.LAT = V.LAT AND I.LON=V.LON WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) != 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable WORLD, Columns = [ *, NAME, CONTINENT, AREA, POPULATION, GDP ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA >= 3000000 OR POPULATION >= 25000000;\n[SQL_2] SELECT NAME, POPULATION, AREA FROM WORLD WHERE AREA > 3000000 OR POPULATION > 25000000 ORDER BY 1,2,3;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE AS TBL_1 WHERE TIV_2015 IN ( SELECT TIV_2015 FROM INSURANCE AS TBL_2 GROUP BY TIV_2015 HAVING COUNT(*) > 1 ) AND (TBL_1.LAT, TBL_1.LON) IN ( SELECT LAT, LON FROM INSURANCE AS TBL_3 GROUP BY LAT, LON HAVING COUNT(*) = 1 );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH SALES_EXPANDED AS ( SELECT S.*, P.PRODUCT_NAME FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID ), SUMMARY AS( SELECT SE.BUYER_ID, MAX(CASE WHEN SE.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) S8 , MAX(CASE WHEN SE.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) IPHONE FROM SALES_EXPANDED SE GROUP BY SE.BUYER_ID ) SELECT BUYER_ID FROM SUMMARY WHERE IPHONE = 0 AND S8 = 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable FRIENDSHIP, Columns = [ *, USER1_ID, USER2_ID ]\nTable LIKES, Columns = [ *, USER_ID, PAGE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT PAGE_ID AS RECOMMENDED_PAGE FROM (SELECT CASE WHEN USER1_ID=1 THEN USER2_ID WHEN USER2_ID=1 THEN USER1_ID ELSE NULL END AS USER_ID FROM FRIENDSHIP) AS TB1 JOIN LIKES AS TB2 ON TB1.USER_ID=TB2.USER_ID WHERE PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID=1);\n[SQL_2] SELECT DISTINCT L.PAGE_ID RECOMMENDED_PAGE FROM (SELECT (CASE WHEN USER1_ID < USER2_ID THEN USER1_ID ELSE USER2_ID END) USER1_ID, (CASE WHEN USER1_ID > USER2_ID THEN USER1_ID ELSE USER2_ID END) USER2_ID FROM FRIENDSHIP ) TEMP JOIN LIKES L ON TEMP.USER2_ID = L.USER_ID AND TEMP.USER1_ID = 1 WHERE L.USER_ID != 1 AND PAGE_ID NOT IN (SELECT PAGE_ID FROM LIKES WHERE USER_ID = 1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable SALARIES, Columns = [ *, COMPANY_ID, EMPLOYEE_ID, EMPLOYEE_NAME, SALARY ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT S.COMPANY_ID, S.EMPLOYEE_ID, S.EMPLOYEE_NAME, ROUND(CASE WHEN X.MAX_SAL BETWEEN 1000 AND 10000 THEN SALARY * 0.76 WHEN X.MAX_SAL > 10000 THEN SALARY * 0.51 ELSE SALARY END, 0) AS SALARY FROM SALARIES S INNER JOIN (SELECT COMPANY_ID, MAX(SALARY) MAX_SAL FROM SALARIES GROUP BY COMPANY_ID) X ON S.COMPANY_ID = X.COMPANY_ID;\n[SQL_2] WITH MAX_SALARIES AS (SELECT COMPANY_ID, MAX(SALARY) AS MAX_SALARY FROM SALARIES GROUP BY COMPANY_ID) SELECT C.COMPANY_ID, C.EMPLOYEE_ID, C.EMPLOYEE_NAME, ROUND((CASE WHEN MS.MAX_SALARY < 1000 THEN 1 WHEN MS.MAX_SALARY < 10000 THEN 0.76 ELSE 0.51 END) * C.SALARY) AS SALARY FROM SALARIES C INNER JOIN MAX_SALARIES MS USING(COMPANY_ID);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable DAILYSALES, Columns = [ *, DATE_ID, MAKE_NAME, LEAD_ID, PARTNER_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DATE_ID, MAKE_NAME, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID, MAKE_NAME;\n[SQL_2] SELECT MAKE_NAME , DATE_ID, COUNT(DISTINCT LEAD_ID) AS UNIQUE_LEADS, COUNT(DISTINCT PARTNER_ID) AS UNIQUE_PARTNERS FROM DAILYSALES GROUP BY DATE_ID,MAKE_NAME;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING SUM(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN 1 ELSE 0 END) = 0;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME FROM PRODUCT WHERE PRODUCT.PRODUCT_ID NOT IN (SELECT SALES.PRODUCT_ID FROM SALES WHERE SALES.SALE_DATE > '2019-03-31' OR SALES.SALE_DATE < '2019-01-01') AND PRODUCT.PRODUCT_ID IN (SELECT SALES.PRODUCT_ID FROM SALES);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE<'2019-01-01'OR SALE_DATE>'2019_03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable EMPLOYEES, Columns = [ *, ID, NAME ]\nTable EMPLOYEEUNI, Columns = [ *, ID, UNIQUE_ID ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT E2.UNIQUE_ID, E1.NAME FROM EMPLOYEES E1 LEFT JOIN EMPLOYEEUNI E2 ON E1.ID = E2.ID;\n[SQL_2] SELECT EMPLOYEES.NAME, EMPLOYEEUNI.UNIQUE_ID FROM EMPLOYEES LEFT JOIN EMPLOYEEUNI ON EMPLOYEEUNI.ID = EMPLOYEES.ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT REPORT_REASON, COUNT(REPORT_REASON) AS REPORT_COUNT FROM ( SELECT DISTINCT(T1.POST_ID), T1.ACTION, T1.EXTRA AS REPORT_REASON, T1.ACTION_DATE FROM ACTIONS AS T1 WHERE T1.ACTION_DATE = '2019-07-04' AND T1.ACTION = 'REPORT' ) AS T2 GROUP BY T2.REPORT_REASON;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL AS EMAIL FROM (SELECT EMAIL, COUNT(ID) AS CNT FROM PERSON GROUP BY EMAIL) AS T WHERE T.CNT > 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT PRODUCT_ID, PRODUCT_NAME FROM PRODUCT WHERE PRODUCT_ID NOT IN (SELECT DISTINCT P.PRODUCT_ID FROM PRODUCT P LEFT JOIN SALES S ON S.PRODUCT_ID=P.PRODUCT_ID WHERE S.SALE_DATE < '2019-01-01' OR S.SALE_DATE > '2019-03-31');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS WHERE VISITS.VISIT_ID NOT IN(SELECT TRANSACTIONS.VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] SELECT A.INVOICE_ID, B.CUSTOMER_NAME, MIN(PRICE) AS PRICE, COUNT(C.USER_ID) AS CONTACTS_CNT, COUNT(D.CUSTOMER_ID) AS TRUSTED_CONTACTS_CNT FROM INVOICES A JOIN CUSTOMERS B ON A.USER_ID = B.CUSTOMER_ID LEFT JOIN CONTACTS C ON B.CUSTOMER_ID = C.USER_ID LEFT JOIN CUSTOMERS D ON C.CONTACT_NAME = D.CUSTOMER_NAME GROUP BY A.INVOICE_ID, B.CUSTOMER_NAME ORDER BY 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT DISTINCT BUYER_ID FROM SALES WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID= P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'IPHONE') AND BUYER_ID IN (SELECT BUYER_ID FROM SALES S JOIN PRODUCT P ON S.PRODUCT_ID= P.PRODUCT_ID WHERE P.PRODUCT_NAME = 'S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] SELECT S.BUYER_ID FROM SALES S LEFT JOIN PRODUCT P ON S.PRODUCT_ID = P.PRODUCT_ID GROUP BY S.BUYER_ID HAVING (MAX(CASE WHEN P.PRODUCT_NAME = 'S8' THEN 1 ELSE 0 END) + MIN(CASE WHEN P.PRODUCT_NAME = 'IPHONE' THEN -1 ELSE 0 END)) = 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(A.X - B.X) AS SHORTEST FROM POINT A CROSS JOIN POINT B WHERE A.X <> B.X ORDER BY SHORTEST ASC LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT U.PRODUCT_ID, ROUND(SUM(UNITS*PRICE)/SUM(UNITS), 2) AS AVERAGE_PRICE FROM UNITSSOLD U LEFT JOIN PRICES P ON U.PRODUCT_ID=P.PRODUCT_ID AND (PURCHASE_DATE BETWEEN START_DATE AND END_DATE) GROUP BY U.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(DISTINCT A1.VISIT_ID) AS COUNT_NO_TRANS FROM (SELECT CUSTOMER_ID, VISITS.VISIT_ID FROM VISITS LEFT JOIN TRANSACTIONS ON VISITS.VISIT_ID = TRANSACTIONS.VISIT_ID WHERE AMOUNT IS NULL) A1 GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T(BUYER_ID) AS ( SELECT BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID WHERE P.PRODUCT_NAME ='IPHONE' ) SELECT DISTINCT S.BUYER_ID FROM SALES S INNER JOIN PRODUCT P ON S.PRODUCT_ID=P.PRODUCT_ID LEFT JOIN T ON T.BUYER_ID=S.BUYER_ID WHERE P.PRODUCT_NAME='S8' AND T.BUYER_ID IS NULL;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PERSON, Columns = [ *, ID, EMAIL ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) >1;\n[SQL_2] SELECT EMAIL AS EMAIL FROM PERSON GROUP BY EMAIL HAVING SUM(1)>1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LON, LAT) IN (SELECT LON, LAT LAT FROM INSURANCE GROUP BY LON, LAT HAVING COUNT(LAT)=1);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P INNER JOIN ( SELECT PRODUCT_ID FROM SALES GROUP BY PRODUCT_ID HAVING MIN(SALE_DATE) >= '2019-01-01' AND MAX(SALE_DATE) <= '2019-03-31' ) S ON (P.PRODUCT_ID = S.PRODUCT_ID);\n[SQL_2] SELECT DISTINCT P.PRODUCT_ID, P.PRODUCT_NAME FROM PRODUCT P WHERE PRODUCT_ID NOT IN ( SELECT PRODUCT_ID FROM SALES WHERE SALE_DATE < '2019-01-01' OR SALE_DATE > '2019-03-31' );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT ROUND(SUM(TIV_2016), 2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN ( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(TIV_2015) > 1 ) AND (LAT, LON) NOT IN ( SELECT LAT, LON FROM INSURANCE GROUP BY LAT, LON HAVING COUNT(PID) > 1 );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] WITH TP1 AS( SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) > 1) , TP2 AS( SELECT LAT, LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*) = 1 ) SELECT SUM(TIV_2016) AS TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM TP1) AND (LAT,LON) IN (SELECT LAT,LON FROM TP2);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT AUTHOR_ID AS ID FROM VIEWS WHERE AUTHOR_ID = VIEWER_ID ORDER BY ID;\n[SQL_2] SELECT V1.AUTHOR_ID ID FROM VIEWS V1 INNER JOIN VIEWS V2 ON V1.AUTHOR_ID = V2.VIEWER_ID AND V1.VIEW_DATE = V2.VIEW_DATE AND V1.ARTICLE_ID = V2.ARTICLE_ID GROUP BY V1.AUTHOR_ID HAVING COUNT(*) >=1 ORDER BY ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS V1 LEFT JOIN TRANSACTIONS T1 ON V1.VISIT_ID=T1.VISIT_ID WHERE T1.TRANSACTION_ID IS NULL GROUP BY CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] SELECT DISTINCT(T1.VIEWER_ID) AS ID FROM VIEWS T1 JOIN VIEWS T2 ON T1.VIEWER_ID = T2.VIEWER_ID WHERE T1.ARTICLE_ID != T2.ARTICLE_ID AND T1.VIEW_DATE = T2.VIEW_DATE ORDER BY ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRICES, Columns = [ *, PRODUCT_ID, START_DATE, END_DATE, PRICE ]\nTable UNITSSOLD, Columns = [ *, PRODUCT_ID, PURCHASE_DATE, UNITS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT A.PRODUCT_ID, ROUND((SUM((UNITS * PRICE)) / SUM(UNITS)), 2) AS AVERAGE_PRICE FROM PRICES AS A JOIN UNITSSOLD AS B ON (A.PRODUCT_ID = B.PRODUCT_ID AND B.PURCHASE_DATE BETWEEN A.START_DATE AND A.END_DATE) GROUP BY A.PRODUCT_ID;\n[SQL_2] SELECT PRICES.PRODUCT_ID, ROUND(SUM(PRICES.PRICE * UNITSSOLD.UNITS) / SUM(UNITSSOLD.UNITS), 2) AS AVERAGE_PRICE FROM PRICES LEFT JOIN UNITSSOLD ON PRICES.PRODUCT_ID = UNITSSOLD.PRODUCT_ID AND PRICES.START_DATE <= UNITSSOLD.PURCHASE_DATE AND UNITSSOLD.PURCHASE_DATE <= PRICES.END_DATE GROUP BY PRICES.PRODUCT_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable POINT, Columns = [ *, X ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT MIN(ABS((A.X - B.X))) AS SHORTEST FROM POINT AS A, POINT AS B WHERE A.X <> B.X;\n[SQL_2] SELECT ABS(A.X-B.X) AS SHORTEST FROM POINT A JOIN POINT B ON A.X <>B.X ORDER BY SHORTEST LIMIT 1;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable COURSES, Columns = [ *, STUDENT, CLASS ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CLASS FROM COURSES GROUP BY CLASS HAVING COUNT(*)>=5;\n[SQL_2] SELECT T1.CLASS FROM ( SELECT STUDENT, CLASS FROM COURSES GROUP BY STUDENT, CLASS ) T1 GROUP BY T1.CLASS HAVING COUNT(CLASS) >= 5;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH TMP AS ( SELECT A.BUYER_ID, B.PRODUCT_NAME FROM SALES AS A JOIN PRODUCT AS B ON A.PRODUCT_ID = B.PRODUCT_ID ) SELECT DISTINCT BUYER_ID FROM TMP WHERE BUYER_ID NOT IN (SELECT BUYER_ID FROM TMP WHERE PRODUCT_NAME = 'IPHONE') AND BUYER_ID IN (SELECT BUYER_ID FROM TMP WHERE PRODUCT_NAME = 'S8');\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VISITS, Columns = [ *, VISIT_ID, CUSTOMER_ID ]\nTable TRANSACTIONS, Columns = [ *, TRANSACTION_ID, VISIT_ID, AMOUNT ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT CUSTOMER_ID, COUNT(*) AS COUNT_NO_TRANS FROM VISITS WHERE VISIT_ID NOT IN (SELECT DISTINCT VISIT_ID FROM TRANSACTIONS) GROUP BY CUSTOMER_ID;\n[SQL_2] SELECT VISITS.CUSTOMER_ID, COUNT(CUSTOMER_ID) AS COUNT_NO_TRANS FROM VISITS LEFT JOIN (SELECT DISTINCT TRANSACTIONS.VISIT_ID AS A FROM TRANSACTIONS) AS TMP ON VISITS.VISIT_ID = TMP.A WHERE TMP.A IS NULL GROUP BY VISITS.CUSTOMER_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable PRODUCT, Columns = [ *, PRODUCT_ID, PRODUCT_NAME, UNIT_PRICE ]\nTable SALES, Columns = [ *, PRODUCT_ID, SELLER_ID, BUYER_ID, SALE_DATE, QUANTITY, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT SALES.BUYER_ID AS BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'S8' AND SALES.BUYER_ID NOT IN ( SELECT SALES.BUYER_ID FROM PRODUCT INNER JOIN SALES ON SALES.PRODUCT_ID = PRODUCT.PRODUCT_ID WHERE PRODUCT_NAME = 'IPHONE');\n[SQL_2] WITH T0 AS ( SELECT S.BUYER_ID,P.PRODUCT_NAME FROM SALES S, PRODUCT P WHERE S.PRODUCT_ID = P.PRODUCT_ID ) SELECT BUYER_ID FROM T0 GROUP BY BUYER_ID HAVING (BUYER_ID,'S8') IN (SELECT * FROM T0) AND (BUYER_ID,'IPHONE') NOT IN (SELECT * FROM T0);\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable INSURANCE, Columns = [ *, PID, TIV_2015, TIV_2016, LAT, LON ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT ROUND(SUM(TIV_2016),2) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*)>1) AND (LAT,LON) IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*)=1);\n[SQL_2] SELECT SUM(TIV_2016) TIV_2016 FROM INSURANCE WHERE TIV_2015 IN (SELECT TIV_2015 FROM INSURANCE GROUP BY TIV_2015 HAVING COUNT(*) > 1) AND (LAT, LON) NOT IN (SELECT LAT,LON FROM INSURANCE GROUP BY LAT,LON HAVING COUNT(*) > 1 );\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable ACTIONS, Columns = [ *, USER_ID, POST_ID, ACTION_DATE, ACTION, EXTRA ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT EXTRA AS REPORT_REASON, COUNT(DISTINCT POST_ID) AS REPORT_COUNT FROM ACTIONS WHERE ACTION = 'REPORT' AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n[SQL_2] SELECT EXTRA REPORT_REASON, COUNT(DISTINCT POST_ID) REPORT_COUNT FROM ACTIONS WHERE ACTION='REPORT' AND EXTRA IS NOT NULL AND ACTION_DATE = '2019-07-04' GROUP BY EXTRA;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable VIEWS, Columns = [ *, ARTICLE_ID, AUTHOR_ID, VIEWER_ID, VIEW_DATE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT DISTINCT VIEWER_ID AS ID FROM VIEWS GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(DISTINCT ARTICLE_ID) > 1 ORDER BY ID;\n[SQL_2] WITH X AS (SELECT DISTINCT * FROM VIEWS) SELECT DISTINCT VIEWER_ID AS ID FROM X GROUP BY VIEW_DATE, VIEWER_ID HAVING COUNT(VIEWER_ID ) >1 ORDER BY VIEWER_ID ASC;\n\n### Answer",
        "answer": "Non Equivalent"
    },
    {
        "question": "### Task\nGiven the database schema and two SQL queries, SQL_1 and SQL_2, determine if SQL_1 and SQL_2 are \"Equivalent\" or \"Non Equivalent\". Two SQL queries are \"Equivalent\" if both queries produce the same result when executed on the given database schema.\n\n### Database Schema\nThe query will run on a database with the following schema:\n\nTable CUSTOMERS, Columns = [ *, CUSTOMER_ID, CUSTOMER_NAME, EMAIL ]\nTable CONTACTS, Columns = [ *, USER_ID, CONTACT_EMAIL, CONTACT_NAME ]\nTable INVOICES, Columns = [ *, INVOICE_ID, USER_ID, PRICE ]\n\nForeign Keys = [ ADS.CUSTOMER_ID = PLAYBACK.CUSTOMER_ID ]\nPrimary Keys = [ PLAYBACK.SESSION_ID, ADS.AD_ID ]\n\n### SQL\n[SQL_1] SELECT INVOICE_ID, T.CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM INVOICES I LEFT JOIN ( SELECT A.CUSTOMER_ID, CUSTOMER_NAME, COUNT(CONTACT_NAME) AS CONTACTS_CNT, SUM(CASE WHEN CONTACT_EMAIL IN (SELECT EMAIL FROM CUSTOMERS) THEN 1 ELSE 0 END) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS A LEFT JOIN CONTACTS B ON A.CUSTOMER_ID = B.USER_ID GROUP BY A.CUSTOMER_ID, CUSTOMER_NAME ) T ON I.USER_ID = T.CUSTOMER_ID ORDER BY 1;\n[SQL_2] WITH CTE AS (SELECT CUSTOMER_ID, CUSTOMER_NAME, EMAIL, COALESCE(CONTACT_COUNT, 0) AS CONTACTS_CNT, COALESCE(TRUSTED,0) AS TRUSTED_CONTACTS_CNT FROM CUSTOMERS LEFT JOIN ( SELECT USER_ID, SUM(CASE WHEN EMAIL IS NULL THEN 0 ELSE 1 END) AS TRUSTED, COUNT(USER_ID) AS CONTACT_COUNT FROM CONTACTS LEFT JOIN CUSTOMERS ON EMAIL=CONTACT_EMAIL GROUP BY USER_ID ) A ON CUSTOMER_ID=USER_ID) SELECT INVOICE_ID, CUSTOMER_NAME, PRICE, CONTACTS_CNT, TRUSTED_CONTACTS_CNT FROM CTE INNER JOIN INVOICES ON CUSTOMER_ID=USER_ID ORDER BY INVOICE_ID;\n\n### Answer",
        "answer": "Non Equivalent"
    }
]